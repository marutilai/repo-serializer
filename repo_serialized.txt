Directory Structure:
├── README.md
├── backend
│   ├── Dockerfile
│   ├── README.md
│   ├── configs
│   ├── data
│   │   └── preload
│   ├── schemas
│   ├── scripts
│   │   ├── activate.sh
│   │   ├── check_migration.sh
│   │   ├── entrypoint.sh
│   │   ├── generate_migration.sh
│   │   ├── generate_openapi.sh
│   │   ├── load_test.sh
│   │   ├── runbooks
│   │   │   ├── backup_db.sh
│   │   │   ├── restore_db.sh
│   │   │   ├── run_sql.sh
│   │   │   └── run_sql.sql
│   │   └── test.sh
│   └── src
│       ├── __init__.py
│       ├── agents
│       │   ├── __init__.py
│       │   ├── build_tools.py
│       │   └── tools
│       │       ├── __init__.py
│       │       ├── data_analyst
│       │       │   └── sql
│       │       │       ├── __init__.py
│       │       │       ├── demo_schema.sql
│       │       │       ├── demo_schema_notes.txt
│       │       │       └── tool.py
│       │       ├── projects
│       │       │   ├── __init__.py
│       │       │   └── find
│       │       │       ├── __init__.py
│       │       │       ├── models.py
│       │       │       ├── search_index.py
│       │       │       └── tool.py
│       │       ├── rag
│       │       │   ├── __init__.py
│       │       │   └── document.py
│       │       ├── sales
│       │       │   ├── __init__.py
│       │       │   └── generate_interaction_demo.py
│       │       └── staffing
│       │           ├── __init__.py
│       │           └── recommend_tribe_members
│       │               ├── __init__.py
│       │               ├── get_member_profiles.sql
│       │               ├── models.py
│       │               ├── search_index.py
│       │               └── tool.py
│       ├── app
│       │   ├── __init__.py
│       │   ├── apis
│       │   │   ├── __init__.py
│       │   │   ├── endpoints
│       │   │   │   ├── __init__.py
│       │   │   │   ├── agent.py
│       │   │   │   ├── asset.py
│       │   │   │   ├── audit_log.py
│       │   │   │   ├── auth.py
│       │   │   │   ├── conversation.py
│       │   │   │   ├── feedback.py
│       │   │   │   ├── health.py
│       │   │   │   ├── llm.py
│       │   │   │   ├── message.py
│       │   │   │   ├── search.py
│       │   │   │   ├── tool.py
│       │   │   │   └── user.py
│       │   │   └── models
│       │   │       ├── __init__.py
│       │   │       ├── agent.py
│       │   │       ├── agent_config.py
│       │   │       ├── asset.py
│       │   │       ├── audit_log.py
│       │   │       ├── auth.py
│       │   │       ├── conversation.py
│       │   │       ├── feedback.py
│       │   │       ├── llm.py
│       │   │       ├── message.py
│       │   │       ├── search.py
│       │   │       ├── tool.py
│       │   │       └── user.py
│       │   ├── enums.py
│       │   ├── handlers
│       │   │   ├── __init__.py
│       │   │   ├── agent.py
│       │   │   ├── asset.py
│       │   │   ├── asset_file_extensions.py
│       │   │   ├── auth.py
│       │   │   ├── conversation.py
│       │   │   ├── feedback.py
│       │   │   ├── llm.py
│       │   │   ├── message.py
│       │   │   ├── message_sse.py
│       │   │   ├── search.py
│       │   │   └── tool.py
│       │   ├── initialize.py
│       │   ├── middlewares.py
│       │   └── utils
│       │       ├── __init__.py
│       │       ├── error_analytics.py
│       │       └── static_files.py
│       ├── clients
│       │   ├── __init__.py
│       │   └── airtable
│       │       ├── __init__.py
│       │       └── client.py
│       ├── conftest.py
│       ├── db
│       │   ├── __init__.py
│       │   ├── connect.py
│       │   ├── crud
│       │   │   ├── __init__.py
│       │   │   ├── agent.py
│       │   │   ├── agent_config.py
│       │   │   ├── asset.py
│       │   │   ├── audit_log.py
│       │   │   ├── conversation.py
│       │   │   ├── conversation_starter.py
│       │   │   ├── feedback.py
│       │   │   ├── generation_log.py
│       │   │   ├── ingestion_chunk.py
│       │   │   ├── ingestion_document.py
│       │   │   ├── message.py
│       │   │   └── user.py
│       │   ├── initialize.py
│       │   ├── migrations
│       │   │   ├── __init__.py
│       │   │   ├── env.py
│       │   │   ├── script.py.mako
│       │   │   └── versions
│       │   │       ├── __init__.py
│       │   │       ├── version_0_18_0_07bfdbda3a90.py
│       │   │       ├── version_0_1_6_1f66465b90cb.py
│       │   │       ├── version_0_1_7_12ab8425c50e.py
│       │   │       ├── version_0_1_8_f34400c3f9bb.py
│       │   │       ├── version_0_1_9_489e61d9db10.py
│       │   │       ├── version_0_2_0_105890535923.py
│       │   │       ├── version_0_2_1_351cf98653fb.py
│       │   │       ├── version_0_2_2_b7cd3fe6edf0.py
│       │   │       ├── version_0_3_3_4f5f4eb77304.py
│       │   │       ├── version_0_3_4_a85454b5ab59.py
│       │   │       ├── version_0_3_5_f02a984e886d.py
│       │   │       ├── version_0_3_6_97a2df72480e.py
│       │   │       ├── version_0_4_0_6c46933ea606.py
│       │   │       └── version_0_8_0_1578f01e480a.py
│       │   └── models
│       │       ├── __init__.py
│       │       ├── agent.py
│       │       ├── agent_config.py
│       │       ├── asset.py
│       │       ├── audit_log.py
│       │       ├── conversation.py
│       │       ├── conversation_starter.py
│       │       ├── feedback.py
│       │       ├── generation_log.py
│       │       ├── ingestion_chunk.py
│       │       ├── ingestion_document.py
│       │       ├── message.py
│       │       └── user.py
│       ├── exceptions.py
│       ├── ingestion
│       │   ├── __init__.py
│       │   ├── embeddings_caching.py
│       │   ├── indexing_functions
│       │   │   ├── __init__.py
│       │   │   ├── database.py
│       │   │   └── search.py
│       │   ├── initialize.py
│       │   ├── pipeline.py
│       │   └── search_indices
│       │       ├── __init__.py
│       │       ├── ingestion_chunk.py
│       │       └── ingestion_document.py
│       ├── llm
│       │   ├── __init__.py
│       │   └── initialize.py
│       ├── logger.py
│       ├── models
│       │   ├── __init__.py
│       │   ├── agent.py
│       │   ├── agent_config.py
│       │   ├── asset.py
│       │   ├── audit_log.py
│       │   ├── conversation.py
│       │   ├── conversation_starter.py
│       │   ├── feedback.py
│       │   ├── generation_log.py
│       │   ├── ingestion_chunk.py
│       │   ├── ingestion_document.py
│       │   ├── message.py
│       │   └── user.py
│       ├── search
│       │   ├── __init__.py
│       │   ├── connect.py
│       │   ├── indexable_documents.py
│       │   ├── indices.py
│       │   ├── initialize.py
│       │   └── update
│       │       ├── __init__.py
│       │       ├── asset.py
│       │       ├── conversation.py
│       │       └── message.py
│       └── settings.py
├── frontend
│   ├── Dockerfile
│   ├── README.md
│   ├── VERSION
│   ├── commitlint.config.ts
│   ├── eslint.config.js
│   ├── global.d.ts
│   ├── index.html
│   ├── lint-staged.config.js
│   ├── orval.config.ts
│   ├── package.json
│   ├── playwright.config.ts
│   ├── scripts
│   │   ├── entrypoint.sh
│   │   └── schema.sh
│   ├── src
│   │   ├── App.tsx
│   │   ├── api
│   │   │   ├── api-base.tsx
│   │   │   ├── api-sse-base.tsx
│   │   │   ├── custom
│   │   │   │   ├── api.ts
│   │   │   │   └── schema.ts
│   │   │   ├── models
│   │   │   │   ├── agentConfigCreate.ts
│   │   │   │   ├── agentConfigCreateFromExisting.ts
│   │   │   │   ├── agentConfigCreateFromExistingIsActive.ts
│   │   │   │   ├── agentConfigCreateFromExistingName.ts
│   │   │   │   ├── agentConfigCreateFromExistingNotes.ts
│   │   │   │   ├── agentConfigCreateFromExistingPromptTemplate.ts
│   │   │   │   ├── agentConfigCreateNotes.ts
│   │   │   │   ├── agentConfigCreateToolUseSectionTemplates.ts
│   │   │   │   ├── agentConfigReadResponse.ts
│   │   │   │   ├── agentConfigReadResponseNotes.ts
│   │   │   │   ├── agentConfigReadResponseUpdatedAt.ts
│   │   │   │   ├── agentConfigStatus.ts
│   │   │   │   ├── agentConfigsListResponse.ts
│   │   │   │   ├── agentCreate.ts
│   │   │   │   ├── agentCreateBaselineConfigUuid.ts
│   │   │   │   ├── agentCreateDescription.ts
│   │   │   │   ├── agentReadResponse.ts
│   │   │   │   ├── agentReadResponseAssets.ts
│   │   │   │   ├── agentReadResponseDescription.ts
│   │   │   │   ├── agentReadResponseOwnerUsername.ts
│   │   │   │   ├── agentReadResponseOwnerUuid.ts
│   │   │   │   ├── agentStockResponses.ts
│   │   │   │   ├── agentStockResponsesInitialMessage.ts
│   │   │   │   ├── agentType.ts
│   │   │   │   ├── agentUpdate.ts
│   │   │   │   ├── agentUpdateAssetUuids.ts
│   │   │   │   ├── agentUpdateDescription.ts
│   │   │   │   ├── agentUpdateIsPublic.ts
│   │   │   │   ├── agentUpdateLlmModelId.ts
│   │   │   │   ├── agentUpdateName.ts
│   │   │   │   ├── agentsListResponse.ts
│   │   │   │   ├── assetCreateError.ts
│   │   │   │   ├── assetCreateErrorErrorLog.ts
│   │   │   │   ├── assetIndexResults.ts
│   │   │   │   ├── assetIndexResultsFilters.ts
│   │   │   │   ├── assetReadResponse.ts
│   │   │   │   ├── assetReadResponseAgentUuid.ts
│   │   │   │   ├── assetReadResponseConversationUuid.ts
│   │   │   │   ├── assetReadResponseDescription.ts
│   │   │   │   ├── assetReadResponseIngestionErrorLog.ts
│   │   │   │   ├── assetReadResponseIngestionMetadata.ts
│   │   │   │   ├── assetReadResponseIngestionStatus.ts
│   │   │   │   ├── assetReadResponseIngestionStepLogs.ts
│   │   │   │   ├── assetReadResponseMessageUuid.ts
│   │   │   │   ├── assetReadResponseSourceUrl.ts
│   │   │   │   ├── assetSearchResult.ts
│   │   │   │   ├── assetSearchResultAgentUuid.ts
│   │   │   │   ├── assetSearchResultContent.ts
│   │   │   │   ├── assetSearchResultContentHash.ts
│   │   │   │   ├── assetSearchResultConversationName.ts
│   │   │   │   ├── assetSearchResultDescription.ts
│   │   │   │   ├── assetSearchResultIngestionStatus.ts
│   │   │   │   ├── assetSearchResultMessageUuid.ts
│   │   │   │   ├── assetSearchResultSummary.ts
│   │   │   │   ├── assetSearchResultText.ts
│   │   │   │   ├── assetSearchResultUpdatedAt.ts
│   │   │   │   ├── assetType.ts
│   │   │   │   ├── assetsCreateResponse.ts
│   │   │   │   ├── assetsListResponse.ts
│   │   │   │   ├── auditActionType.ts
│   │   │   │   ├── auditLogReadResponse.ts
│   │   │   │   ├── auditLogReadResponseAssetUuid.ts
│   │   │   │   ├── auditLogReadResponseChanges.ts
│   │   │   │   ├── auditLogReadResponseChangesAnyOf.ts
│   │   │   │   ├── auditLogReadResponseContext.ts
│   │   │   │   ├── auditLogReadResponseContextAnyOf.ts
│   │   │   │   ├── auditLogReadResponseConversationUuid.ts
│   │   │   │   ├── auditLogReadResponseEntity.ts
│   │   │   │   ├── auditLogReadResponseEntityUuid.ts
│   │   │   │   ├── auditLogReadResponseMessageUuid.ts
│   │   │   │   ├── auditLogsListResponse.ts
│   │   │   │   ├── availableResponse.ts
│   │   │   │   ├── bodyCreateAssetsApiAssetPost.ts
│   │   │   │   ├── bodyLoginApiAuthLoginPost.ts
│   │   │   │   ├── bodyLoginApiAuthLoginPostClientId.ts
│   │   │   │   ├── bodyLoginApiAuthLoginPostClientSecret.ts
│   │   │   │   ├── bodyLoginApiAuthLoginPostGrantType.ts
│   │   │   │   ├── bodyRunToolApiToolToolRegistryIdPost.ts
│   │   │   │   ├── bodyRunToolApiToolToolRegistryIdPostToolInputs.ts
│   │   │   │   ├── bodyRunToolApiToolToolRegistryIdPostToolOptions.ts
│   │   │   │   ├── bodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf.ts
│   │   │   │   ├── checkUsernameAvailableParams.ts
│   │   │   │   ├── conversationHistoryResponse.ts
│   │   │   │   ├── conversationIndexResults.ts
│   │   │   │   ├── conversationIndexResultsFilters.ts
│   │   │   │   ├── conversationListResponse.ts
│   │   │   │   ├── conversationPatchRequest.ts
│   │   │   │   ├── conversationPatchRequestName.ts
│   │   │   │   ├── conversationReadResponse.ts
│   │   │   │   ├── conversationReadResponseUpdatedAt.ts
│   │   │   │   ├── conversationSearchResult.ts
│   │   │   │   ├── conversationSearchResultText.ts
│   │   │   │   ├── conversationSearchResultUpdatedAt.ts
│   │   │   │   ├── conversationStarter.ts
│   │   │   │   ├── conversationStarterListResponse.ts
│   │   │   │   ├── createAssetsParams.ts
│   │   │   │   ├── defaultConversationSettings.ts
│   │   │   │   ├── deleteQueryFromSearchHistoryParams.ts
│   │   │   │   ├── feedbackCreate.ts
│   │   │   │   ├── feedbackCreateRating.ts
│   │   │   │   ├── feedbackCreateTargetUuid.ts
│   │   │   │   ├── feedbackCreateUrl.ts
│   │   │   │   ├── feedbackRating.ts
│   │   │   │   ├── feedbackResponse.ts
│   │   │   │   ├── feedbackResponseAgentUuid.ts
│   │   │   │   ├── feedbackResponseAssetUuid.ts
│   │   │   │   ├── feedbackResponseConversationUuid.ts
│   │   │   │   ├── feedbackResponseMessageUuid.ts
│   │   │   │   ├── feedbackResponseRating.ts
│   │   │   │   ├── feedbackResponseUpdatedAt.ts
│   │   │   │   ├── feedbackResponseUrl.ts
│   │   │   │   ├── feedbackTarget.ts
│   │   │   │   ├── feedbackType.ts
│   │   │   │   ├── finishReason.ts
│   │   │   │   ├── generationMetadata.ts
│   │   │   │   ├── generationMetadataCostUsd.ts
│   │   │   │   ├── generationMetadataDurationMs.ts
│   │   │   │   ├── generationMetadataFinishReason.ts
│   │   │   │   ├── generationMetadataOutputTokens.ts
│   │   │   │   ├── generationMetadataSettings.ts
│   │   │   │   ├── generationMetadataTimeToFirstTokenMs.ts
│   │   │   │   ├── generationMetadataTokensPerSecond.ts
│   │   │   │   ├── generationMetadataToolCalls.ts
│   │   │   │   ├── generationSettings.ts
│   │   │   │   ├── generationSettingsExtra.ts
│   │   │   │   ├── generationSettingsMaxOutputTokens.ts
│   │   │   │   ├── generationSettingsReasoningEffort.ts
│   │   │   │   ├── getAllAssetsParams.ts
│   │   │   │   ├── getAllAuditLogsParams.ts
│   │   │   │   ├── getAvailableLlmInfosParams.ts
│   │   │   │   ├── getConversationStartersParams.ts
│   │   │   │   ├── getSearchHistoryParams.ts
│   │   │   │   ├── getSupportedExtensionsParams.ts
│   │   │   │   ├── hTTPValidationError.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── ingestionErrorLog.ts
│   │   │   │   ├── ingestionErrorType.ts
│   │   │   │   ├── ingestionMetadata.ts
│   │   │   │   ├── ingestionMetadataFailedAt.ts
│   │   │   │   ├── ingestionMetadataIndexingCompletedAt.ts
│   │   │   │   ├── ingestionMetadataIngestedAt.ts
│   │   │   │   ├── ingestionMetadataParsingCompletedAt.ts
│   │   │   │   ├── ingestionMetadataProcessingCompletedAt.ts
│   │   │   │   ├── ingestionStatus.ts
│   │   │   │   ├── ingestionStepLog.ts
│   │   │   │   ├── ingestionStepLogCompletedAt.ts
│   │   │   │   ├── ingestionStepLogExecutionDetails.ts
│   │   │   │   ├── lLMInfo.ts
│   │   │   │   ├── lLMInfoListResponse.ts
│   │   │   │   ├── lLMInfoResponse.ts
│   │   │   │   ├── lLMInfoResponseNotSelectableReason.ts
│   │   │   │   ├── lLMMessageRole.ts
│   │   │   │   ├── lLMMessageType.ts
│   │   │   │   ├── lLMNotSelectableReason.ts
│   │   │   │   ├── lLMProviderInfo.ts
│   │   │   │   ├── lLMProviderInfoDescription.ts
│   │   │   │   ├── lLMProviderInfoImageUrl.ts
│   │   │   │   ├── messageCreate.ts
│   │   │   │   ├── messageCreateAgentConfigUuid.ts
│   │   │   │   ├── messageCreateAssetUuids.ts
│   │   │   │   ├── messageIndexResults.ts
│   │   │   │   ├── messageIndexResultsFilters.ts
│   │   │   │   ├── messageReadResponse.ts
│   │   │   │   ├── messageReadResponseAgentConfigVersion.ts
│   │   │   │   ├── messageReadResponseAssets.ts
│   │   │   │   ├── messageReadResponseConversationNameUpdatedStreaming.ts
│   │   │   │   ├── messageReadResponseGenerationMetadata.ts
│   │   │   │   ├── messageReadResponseLlmModelId.ts
│   │   │   │   ├── messageReadResponseReasoning.ts
│   │   │   │   ├── messageReadResponseToolUseResponse.ts
│   │   │   │   ├── messageReadResponseUpdatedAt.ts
│   │   │   │   ├── messageRole.ts
│   │   │   │   ├── messageSearchResult.ts
│   │   │   │   ├── messageSearchResultAgentUuid.ts
│   │   │   │   ├── messageSearchResultAuthorImageUrl.ts
│   │   │   │   ├── messageSearchResultLlmModelId.ts
│   │   │   │   ├── messageSearchResultText.ts
│   │   │   │   ├── messageSearchResultUpdatedAt.ts
│   │   │   │   ├── messageSearchResultUserUuid.ts
│   │   │   │   ├── messageStatus.ts
│   │   │   │   ├── messageType.ts
│   │   │   │   ├── messageUpdate.ts
│   │   │   │   ├── messageUpdateAssetUuids.ts
│   │   │   │   ├── messageUpdateContent.ts
│   │   │   │   ├── patchUserMessageParams.ts
│   │   │   │   ├── patchUserMessageStreamingParams.ts
│   │   │   │   ├── patchUserRequest.ts
│   │   │   │   ├── patchUserRequestAppSettings.ts
│   │   │   │   ├── patchUserRequestCountry.ts
│   │   │   │   ├── patchUserRequestDefaultConversationSettings.ts
│   │   │   │   ├── patchUserRequestDescription.ts
│   │   │   │   ├── patchUserRequestFamilyName.ts
│   │   │   │   ├── patchUserRequestGivenName.ts
│   │   │   │   ├── patchUserRequestImageUrl.ts
│   │   │   │   ├── patchUserRequestLanguageCode.ts
│   │   │   │   ├── patchUserRequestLocale.ts
│   │   │   │   ├── patchUserRequestTimezone.ts
│   │   │   │   ├── promptTemplateInput.ts
│   │   │   │   ├── promptTemplateInputCompletionTemplate.ts
│   │   │   │   ├── promptTemplateInputMessagesTemplate.ts
│   │   │   │   ├── promptTemplateInputSectionsTemplate.ts
│   │   │   │   ├── promptTemplateOutput.ts
│   │   │   │   ├── promptTemplateOutputCompletionTemplate.ts
│   │   │   │   ├── promptTemplateOutputMessagesTemplate.ts
│   │   │   │   ├── promptTemplateOutputSectionsTemplate.ts
│   │   │   │   ├── reasoningDetection.ts
│   │   │   │   ├── reasoningEffort.ts
│   │   │   │   ├── rebuildSearchIndicesParams.ts
│   │   │   │   ├── regenerateAgentMessageParams.ts
│   │   │   │   ├── regenerateAgentMessageStreamingParams.ts
│   │   │   │   ├── runTool200.ts
│   │   │   │   ├── runToolParams.ts
│   │   │   │   ├── searchHistoryResponse.ts
│   │   │   │   ├── searchRequest.ts
│   │   │   │   ├── searchRequestConversationUuidFilter.ts
│   │   │   │   ├── searchRequestMessageRoleFilter.ts
│   │   │   │   ├── searchRequestMessageTypeFilter.ts
│   │   │   │   ├── searchRequestTruncateTextFieldsToLength.ts
│   │   │   │   ├── searchResultsResponse.ts
│   │   │   │   ├── searchResultsResponseAsset.ts
│   │   │   │   ├── searchResultsResponseConversation.ts
│   │   │   │   ├── searchResultsResponseMessage.ts
│   │   │   │   ├── sendMessageAndReceiveGeneratedAgentResponseStreamingParams.ts
│   │   │   │   ├── sendMessageAndReceiveGeneratedResponseParams.ts
│   │   │   │   ├── supportedFileExtensionsResponse.ts
│   │   │   │   ├── tags.ts
│   │   │   │   ├── textMessageSectionID.ts
│   │   │   │   ├── textMessageSectionTemplate.ts
│   │   │   │   ├── textMessageSectionTemplateId.ts
│   │   │   │   ├── textMessageSectionTemplateTitle.ts
│   │   │   │   ├── textMessageSectionTemplateUuid.ts
│   │   │   │   ├── textMessageTemplate.ts
│   │   │   │   ├── textMessageTemplateUuid.ts
│   │   │   │   ├── tool.ts
│   │   │   │   ├── toolCall.ts
│   │   │   │   ├── toolOptions.ts
│   │   │   │   ├── toolOptionsAnyOf.ts
│   │   │   │   ├── toolOutputFile.ts
│   │   │   │   ├── toolOutputFileDescription.ts
│   │   │   │   ├── toolOutputFileLocalPath.ts
│   │   │   │   ├── toolOutputFileRemotePath.ts
│   │   │   │   ├── toolOutputFormatting.ts
│   │   │   │   ├── toolReadResponse.ts
│   │   │   │   ├── toolReadResponseInputsSchema.ts
│   │   │   │   ├── toolReadResponseOptionsSchema.ts
│   │   │   │   ├── toolReadResponseOptionsSchemaAnyOf.ts
│   │   │   │   ├── toolReadResponseOutputsSchema.ts
│   │   │   │   ├── toolUseConfig.ts
│   │   │   │   ├── toolUseInfo.ts
│   │   │   │   ├── toolUseInfoCompletedAt.ts
│   │   │   │   ├── toolUseInfoGenerationContext.ts
│   │   │   │   ├── toolUseInfoInputs.ts
│   │   │   │   ├── toolUseInfoInputsAnyOf.ts
│   │   │   │   ├── toolUseInfoOutputs.ts
│   │   │   │   ├── toolUseInfoOutputsAnyOf.ts
│   │   │   │   ├── toolUseOptions.ts
│   │   │   │   ├── toolUsePromptTemplateSections.ts
│   │   │   │   ├── toolUseResponse.ts
│   │   │   │   ├── toolUseStatus.ts
│   │   │   │   ├── toolsListResponse.ts
│   │   │   │   ├── userAppSettings.ts
│   │   │   │   ├── userAppSettingsTheme.ts
│   │   │   │   ├── userProfile.ts
│   │   │   │   ├── userProfileCountry.ts
│   │   │   │   ├── userProfileDescription.ts
│   │   │   │   ├── userProfileFamilyName.ts
│   │   │   │   ├── userProfileGivenName.ts
│   │   │   │   ├── userProfileImageUrl.ts
│   │   │   │   ├── userProfileLanguageCode.ts
│   │   │   │   ├── userProfileLocale.ts
│   │   │   │   ├── userProfileTimezone.ts
│   │   │   │   ├── userRegistrationRequest.ts
│   │   │   │   ├── userRegistrationRequestCountry.ts
│   │   │   │   ├── userRegistrationRequestDescription.ts
│   │   │   │   ├── userRegistrationRequestFamilyName.ts
│   │   │   │   ├── userRegistrationRequestGivenName.ts
│   │   │   │   ├── userRegistrationRequestImageUrl.ts
│   │   │   │   ├── userRegistrationRequestLanguageCode.ts
│   │   │   │   ├── userRegistrationRequestLocale.ts
│   │   │   │   ├── userRegistrationRequestTimezone.ts
│   │   │   │   ├── validationError.ts
│   │   │   │   └── validationErrorLocItem.ts
│   │   │   ├── mutator
│   │   │   │   ├── custom-form-data.ts
│   │   │   │   ├── custom-form-url-encoded.ts
│   │   │   │   └── custom-instance.ts
│   │   │   ├── schemas
│   │   │   │   └── zod.ts
│   │   │   ├── services
│   │   │   │   └── api.ts
│   │   │   └── utils
│   │   │       └── handle-401-error.ts
│   │   ├── components
│   │   │   ├── common
│   │   │   │   ├── ErrorBoundary.tsx
│   │   │   │   ├── ErrorMessage.tsx
│   │   │   │   ├── FormWrapper.tsx
│   │   │   │   ├── GoBackIconButton.tsx
│   │   │   │   ├── Icon.tsx
│   │   │   │   ├── LinkListItem.tsx
│   │   │   │   ├── TypographyWithAnimation.tsx
│   │   │   │   ├── TypographyWithGradient.tsx
│   │   │   │   ├── avatars
│   │   │   │   │   ├── AssistantAvatar.tsx
│   │   │   │   │   ├── CompanyAvatar.tsx
│   │   │   │   │   └── UserAvatar.tsx
│   │   │   │   └── index.ts
│   │   │   ├── interactive
│   │   │   │   ├── DropzoneInput.tsx
│   │   │   │   ├── LoginWithGoogleButton.tsx
│   │   │   │   ├── ModalDialog.tsx
│   │   │   │   ├── Textarea.tsx
│   │   │   │   ├── TextareaAssetInput.tsx
│   │   │   │   ├── TextareaAssetList.tsx
│   │   │   │   ├── TextareaToolbar.tsx
│   │   │   │   ├── UserInput.tsx
│   │   │   │   └── index.ts
│   │   │   └── layout
│   │   │       ├── AppModeWrapper.tsx
│   │   │       ├── Container.tsx
│   │   │       ├── ErrorContainer.tsx
│   │   │       ├── Main.tsx
│   │   │       ├── MobileBottomNavigation.tsx
│   │   │       ├── Modals.tsx
│   │   │       ├── PublicMain.tsx
│   │   │       ├── ScrollContainer.tsx
│   │   │       ├── Sidebar.tsx
│   │   │       ├── SplashScreen.tsx
│   │   │       ├── StandaloneContainer.tsx
│   │   │       ├── TopNavigation.tsx
│   │   │       ├── WidgetModeContainer.tsx
│   │   │       └── index.ts
│   │   ├── env.ts
│   │   ├── features
│   │   │   ├── agent
│   │   │   │   ├── components
│   │   │   │   │   ├── AgentActionsMenu.tsx
│   │   │   │   │   ├── AgentAssetsForm.tsx
│   │   │   │   │   ├── AgentConfigForm.tsx
│   │   │   │   │   ├── AgentConfigTextarea.tsx
│   │   │   │   │   ├── AgentConfigTools.tsx
│   │   │   │   │   ├── AgentConfigVersionChip.tsx
│   │   │   │   │   ├── AgentConfiguration.tsx
│   │   │   │   │   ├── AgentCreateModal.tsx
│   │   │   │   │   ├── AgentDeleteButton.tsx
│   │   │   │   │   ├── AgentDuplicateButton.tsx
│   │   │   │   │   ├── AgentGeneralForm.tsx
│   │   │   │   │   ├── AgentHistory.tsx
│   │   │   │   │   ├── AgentInitialMessage.tsx
│   │   │   │   │   ├── AgentModal.tsx
│   │   │   │   │   ├── AgentModelSelectionDropdown.tsx
│   │   │   │   │   ├── AgentSelectionDropdown.tsx
│   │   │   │   │   ├── AgentSidePanel.tsx
│   │   │   │   │   ├── AgentTabList.tsx
│   │   │   │   │   ├── AgentTabPanels.tsx
│   │   │   │   │   └── AgentTitle.tsx
│   │   │   │   ├── hooks.ts
│   │   │   │   └── store.ts
│   │   │   ├── conversation
│   │   │   │   ├── components
│   │   │   │   │   ├── ConversationScrollToBottomButton.tsx
│   │   │   │   │   ├── ConversationSettingsForm.tsx
│   │   │   │   │   ├── ConversationSettingsModal.tsx
│   │   │   │   │   ├── ConversationStarterCard.tsx
│   │   │   │   │   ├── ConversationTable.tsx
│   │   │   │   │   ├── ConversationTextarea.tsx
│   │   │   │   │   ├── ConversationTopbar.tsx
│   │   │   │   │   └── conversation-message
│   │   │   │   │       ├── ConversationMessage.tsx
│   │   │   │   │       ├── ConversationMessageAssetList.tsx
│   │   │   │   │       ├── ConversationMessageAvatar.tsx
│   │   │   │   │       ├── ConversationMessageBubble.tsx
│   │   │   │   │       ├── ConversationMessageCodeblock.tsx
│   │   │   │   │       ├── ConversationMessageContent.tsx
│   │   │   │   │       ├── ConversationMessageCopyButton.tsx
│   │   │   │   │       ├── ConversationMessageEditMode.tsx
│   │   │   │   │       ├── ConversationMessageHeader.tsx
│   │   │   │   │       ├── ConversationMessageList.tsx
│   │   │   │   │       ├── ConversationMessageMarkdownRender.tsx
│   │   │   │   │       ├── ConversationMessageMetadata.tsx
│   │   │   │   │       ├── ConversationMessageSkeleton.tsx
│   │   │   │   │       ├── ConversationMessageStatusChip.tsx
│   │   │   │   │       ├── ConversationMessageTitle.tsx
│   │   │   │   │       └── ConversationMessageToolbar.tsx
│   │   │   │   ├── context.tsx
│   │   │   │   ├── hooks.tsx
│   │   │   │   ├── index.ts
│   │   │   │   ├── store.ts
│   │   │   │   └── utils.ts
│   │   │   ├── feedback
│   │   │   │   ├── components
│   │   │   │   │   ├── FeedbackModal.tsx
│   │   │   │   │   ├── FeedbackModalActions.tsx
│   │   │   │   │   ├── FeedbackModalAdditionalFeedbackTextarea.tsx
│   │   │   │   │   ├── FeedbackModalContent.tsx
│   │   │   │   │   └── FeedbackRadioGroup.tsx
│   │   │   │   ├── index.tsx
│   │   │   │   └── store.ts
│   │   │   ├── home
│   │   │   │   └── components
│   │   │   │       ├── ConversationStarters.tsx
│   │   │   │       ├── HomeTextarea.tsx
│   │   │   │       ├── HomeTopbar.tsx
│   │   │   │       ├── IntroductoryNotification.tsx
│   │   │   │       ├── IntroductoryText.tsx
│   │   │   │       └── index.ts
│   │   │   ├── layouts
│   │   │   │   ├── AuthenticatedLayout.tsx
│   │   │   │   ├── PublicLayout.tsx
│   │   │   │   └── index.ts
│   │   │   ├── router
│   │   │   │   ├── components
│   │   │   │   │   ├── RouteLoading.tsx
│   │   │   │   │   └── RouteNotFound.tsx
│   │   │   │   ├── context.tsx
│   │   │   │   ├── index.ts
│   │   │   │   └── routes.tsx
│   │   │   ├── search
│   │   │   │   ├── components
│   │   │   │   │   ├── SearchBar.tsx
│   │   │   │   │   ├── SearchFilters.tsx
│   │   │   │   │   ├── SearchModal.tsx
│   │   │   │   │   └── SearchModalContent.tsx
│   │   │   │   ├── hooks.ts
│   │   │   │   └── store.ts
│   │   │   └── settings
│   │   │       ├── components
│   │   │       │   ├── ApplicationSettings.tsx
│   │   │       │   └── SettingsModal.tsx
│   │   │       ├── index.tsx
│   │   │       └── store.ts
│   │   ├── main.tsx
│   │   ├── pages
│   │   │   ├── conversation.tsx
│   │   │   ├── conversations.tsx
│   │   │   ├── home.tsx
│   │   │   ├── index.ts
│   │   │   ├── login.tsx
│   │   │   └── register.tsx
│   │   ├── shared
│   │   │   ├── analytics
│   │   │   │   ├── error.ts
│   │   │   │   ├── hooks.ts
│   │   │   │   ├── product.tsx
│   │   │   │   └── utils.ts
│   │   │   ├── configuration
│   │   │   │   ├── constants.ts
│   │   │   │   ├── context.tsx
│   │   │   │   ├── hooks.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks.ts
│   │   │   ├── i18n.ts
│   │   │   ├── store.ts
│   │   │   ├── theme
│   │   │   │   ├── components
│   │   │   │   │   └── GlobalStyles.tsx
│   │   │   │   ├── context.tsx
│   │   │   │   ├── icons.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── theme.ts
│   │   │   │   └── utils
│   │   │   │       └── generate-shades.ts
│   │   │   └── utils
│   │   │       ├── capitalise-first-letter.ts
│   │   │       ├── case-transformers.ts
│   │   │       ├── currency-formatter.ts
│   │   │       ├── has-token-expired.ts
│   │   │       ├── local-storage.ts
│   │   │       └── redirect-to-login.ts
│   │   └── vite-env.d.ts
│   ├── tsconfig.app.json
│   ├── tsconfig.node.json
│   └── vite.config.ts
├── manifests
│   └── cluster
│       ├── base
│       │   ├── chat-api
│       │   ├── chat-app
│       │   ├── chat-data-analytics
│       │   └── otel-lgtm
│       └── overlays
│           ├── dev
│           │   ├── configs
│           │   ├── helm
│           │   ├── resources
│           │   └── secrets
│           ├── k3d
│           │   ├── configs
│           │   ├── deps
│           │   │   ├── helm
│           │   │   │   └── values
│           │   │   └── otel-lgtm
│           │   └── secrets
│           └── prod
│               ├── configs
│               ├── posthog-proxy
│               ├── resources
│               └── secrets
├── scripts
│   ├── activate.sh
│   ├── cluster
│   │   ├── dev.sh
│   │   ├── down.sh
│   │   ├── logs.sh
│   │   └── up.sh
│   ├── dev.sh
│   └── setup.sh
└── secrets.env.sample

Files Content:

--- Start of README.md ---

# Tribe Platform Chat

## Description

A complete chat platform for Tribe AI that enables conversations with intelligent agents. This monorepo contains both the frontend application and backend API services.

## Architecture

- **Frontend**:
  - Modern React application with React Query and React Router
  - Fast development experience with Vite build system
  - Comprehensive testing with Playwright and Vitest
  - Theme customization and internationalization support
- **Backend API**:
  - User management and authentication
  - Conversation handling and persistence
  - Real-time message processing with streaming responses
  - Agent abstraction and integration
  - Comprehensive feedback system
  - OpenAPI schema generation for frontend client
  - Automated database migrations
- **Kubernetes Deployment**:
  - Local Kubernetes cluster for development and testing
  - CI/CD pipeline for automated deployments

## Quick Start Guide

### Prerequisites

- Docker
- Git
- Node.js
- AWS CLI configured with appropriate credentials (for production)

### Setup

### Installation

1. Clone the repository

   ```sh
   git clone https://github.com/TribeAI/tribe-platform-chat-backend-api.git
   cd tribe-platform-chat-backend-api
   ```

2. Run the setup script

   ```sh
   ./scripts/setup.sh
   ```

3. Configure AWS credentials

   - Ensure an admin has added you to AWS SSO and sent you a password reset email
   - Note your username (e.g., `michaelve` if tribe email is `michaelve@tribe.ai`)
   - Run `aws configure sso` and enter the following details:
     - SSO session name: anything (e.g., `tribe`)
     - SSO start URL: `https://d-90679e070c.awsapps.com/start`
     - SSO region: `us-east-1`
     - SSO Registration Scopes: (leave empty)
     - CLI default client Region: `us-east-1`
     - CLI default output Format: `json`
     - CLI profile name: (leave as is)

4. Authenticate with SSO

   ```sh
   aws sso login --profile <profile name from previous step>
   ```

5. Activate your profile

   ```sh
   export AWS_PROFILE=<profile name>
   ```

   Verify with `aws configure list`

6. Create and configure secrets

   ```sh
   cp secrets.env.sample secrets.env
   ```

   Edit `secrets.env` and set at least `DATA_ANALYTICS__DB__PASSWORD` and `SEARCH__PASSWORD` (ensure the latter has a strong password with uppercase and lowercase letters, numbers, and special characters)

7. Run the application in development mode

   ```sh
   ./scripts/dev.sh
   ```

### Reactivating Your Environment

If you've already set up the environment but need to reactivate:

1. Authenticate with SSO

   ```sh
   aws sso login --profile <profile name>
   ```

   If you don't remember your profile name, use `aws configure list-profiles`

2. Activate your profile

   ```sh
   export AWS_PROFILE=<profile name>
   ```

3. Activate the virtual environment (if needed)

   ```sh
   source ./scripts/activate.sh
   ```

4. Run in development mode

   ```sh
   ./scripts/cluster/dev.sh
   ```

## Key Scripts

```sh
# Setup environment
./scripts/setup.sh

# Activate virtual environment
source ./scripts/activate.sh

# Run in development mode
./scripts/dev.sh

# Run the local Kubernetes cluster
./scripts/cluster/up.sh

# Stop cluster
./scripts/cluster/down.sh

# View cluster logs
./scripts/cluster/logs.sh
```

## Development Workflow

### Pre-commit Hooks

We heavily use pre-commit hooks to maintain code quality and consistency:

- **Pre-commit hooks**: Lightweight checks that run quickly on every commit
- **Pre-push hooks**: More thorough checks that run before pushing to remote

Our hooks perform various tasks:

- Code formatting and linting
- Type checking
- Security scanning
- File validation
- Testing (on push)

To use them effectively:

1. Make your changes
2. Stage changes: `git add .`
3. Commit: `git commit -m 'feat: description'`
4. If checks fail:
   - Review automatically fixed issues
   - Re-stage changes: `git add .`
   - Commit again
5. Fix any remaining issues manually

If you want to skip the checks for any reason:

```sh
# skip pre-commit hooks
git commit -m "feat: foo" --no-verify

# skip pre-push hooks
git push --no-verify
```

Hooks, including tests, will still be run in the `pr` checks, so this can be useful if you are confident checks will pass.

## Contributing

1. Ensure you have set up the development environment
2. Create a feature branch from `main`
3. Make your changes following project conventions
4. Ensure all tests pass
5. Ensure pre-commit hooks pass
6. Create a pull request with a clear description of changes

## Troubleshooting

If you encounter issues:

1. Ensure all prerequisites are installed and up-to-date
2. Verify all environment variables are set correctly in `secrets.env`
3. Check logs for error messages using `./scripts/cluster/logs.sh`
4. For AWS-related issues, ensure your credentials are properly configured

## Additional Documentation

Additional documentation is available in the `docs/` directory of each component:

- [Backend Documentation](./backend/docs/)
- [Frontend Documentation](./frontend/docs/)


--- Start of secrets.env.sample ---

ANALYTICS__PRODUCT__API_KEY=...
AUTH__GOOGLE_SSO__CLIENT_ID=...
AUTH__GOOGLE_SSO__CLIENT_SECRET=...
AUTH__SECRET_KEY=local_password_for_development
DATA_ANALYTICS__DB__PASSWORD=local_password_for_development
DB__PASSWORD=chat_api
LLM__ANTHROPIC__API_KEY=...
LLM__BEDROCK__AWS_ACCESS_KEY_ID=...
LLM__BEDROCK__AWS_SECRET_ACCESS_KEY=...
LLM__BEDROCK__AWS_REGION=...
LLM__DEEPSEEK__API_KEY=...
LLM__OPENAI__API_KEY=...
OBJECT_STORAGE__SECRET_KEY=makeSureThisIsActuallyAStrongPassword123!@#
SEARCH__EMBEDDING_API_KEY=...
SEARCH__PASSWORD=Opensearch123!
TOOLS__TRIBE_HUB_DB_URI=...
TOOLS__TRIBE_PROJECTS_AIRTABLE_API_KEY=...
TRACING__LAMINAR__API_KEY=...


--- Start of frontend/tsconfig.node.json ---

{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noEmit": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true
  },
  "include": ["vite.config.ts"]
}


--- Start of frontend/commitlint.config.ts ---

export default {
  extends: ['@commitlint/config-conventional'],
}


--- Start of frontend/index.html ---

<!doctype html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" />
    <link rel="mask-icon" href="/mask-icon.svg" />
    <link rel="manifest" href="/manifest.json" crossorigin="use-credentials" />
    <style>
      /* Use system preference as initial theme */
      @media (prefers-color-scheme: light) {
        body {
          background-color: #ffffff;
        }
      }
      @media (prefers-color-scheme: dark) {
        body {
          background-color: #191a1a;
        }
      }

      body {
        margin: 0;
        padding: 0;
        transition: background-color 0.2s ease;
      }

      #root {
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script>
      const COLORS = {
        light: '#ffffff',
        dark: '#191a1a',
      }

      try {
        const storedTheme = localStorage.getItem('joy-mode')
        if (storedTheme) {
          document.body.style.backgroundColor =
            storedTheme === 'dark' ? COLORS.dark : COLORS.light
        }
      } catch (e) {
        console.error('Error setting initial theme:', e)
      }
    </script>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


--- Start of frontend/tsconfig.app.json ---

{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "jsx": "react-jsx",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "moduleDetection": "force",
    "useDefineForClassFields": true,
    "baseUrl": "./",
    "module": "ESNext",
    /* Bundler mode */
    "moduleResolution": "bundler",
    /* Paths */
    "paths": {
      "@/*": ["./src/*"]
    },
    "resolveJsonModule": true,
    "types": ["vite-plugin-svgr/client"],
    "allowImportingTsExtensions": true,
    /* Linting */
    "strict": true,
    "noFallthroughCasesInSwitch": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noEmit": true,
    "isolatedModules": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*", "tests/**/*", "i18n.ts", "global.d.ts"]
}


--- Start of frontend/Dockerfile ---

FROM node:20.17.0-alpine AS deps
WORKDIR /app
RUN apk add --no-cache libc6-compat
COPY package.json package-lock.json ./
ENV NODE_OPTIONS=--max_old_space_size=8000
RUN npm install

# development runner
FROM deps AS development
WORKDIR /app
COPY . .
# nosemgrep: dockerfile.security.missing-user-entrypoint.missing-user-entrypoint
ENTRYPOINT ["npx", "vite", "--host"]

# production builder
FROM node:20.17.0-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY ./.npmrc \
    ./index.html \
    ./package.json \
    ./package-lock.json \
    ./tsconfig.json \
    ./tsconfig.app.json \
    ./tsconfig.node.json \
    ./vite.config.ts \
    .
COPY ./src ./src
COPY ./public ./public
ENV VITE__E2E_CI_MODE=false
ENV VITE__ENVIRONMENT=production
RUN npm run build

# production runner
FROM nginx:1.27-alpine AS runner
COPY ./nginx.conf /etc/nginx/nginx.conf
COPY ./scripts/entrypoint.sh /custom-entrypoint.sh
COPY --from=builder /app/dist /usr/share/nginx/html
# NOTE: this is our solution for setting runtime environment variables
#       nginx command set here as setting in entrypoint.sh makes container slow to stop
# nosemgrep: dockerfile.security.missing-user-entrypoint.missing-user-entrypoint
ENTRYPOINT ["/bin/sh", "-c", "/custom-entrypoint.sh && nginx -g 'daemon off;'"]


--- Start of frontend/lint-staged.config.js ---


export default {
  // prettier
  '**/*.{js,jsx,ts,tsx,yaml,yml,json,svg}': 'npm run lint:fix',
  '**/*.{js,jsx,ts,tsx,yaml,yml,json,md,html,css,scss,less,svg}':
    'prettier --write',
  '**/*.(ts|tsx)': () => 'npm run type-check',
}


--- Start of frontend/orval.config.ts ---

import { defineConfig } from 'orval'

// This configuration will be used to generate the API client services, models and the Zod schemas based on the backend OpenAPI spec.
// Go here https://orval.dev/reference/configuration/output for more information on the configuration options.
export default defineConfig({
  // generate API client from the openapi file
  api: {
    input: {
      target: '../backend/schemas/openapi.yaml',
      // validation: true, // Enable validation of the input file.
    },
    output: {
      schemas: 'src/api/models',
      target: 'src/api/services/api.ts',
      client: 'react-query',
      clean: true,
      prettier: true,

      override: {
        formData: {
          path: 'src/api/mutator/custom-form-data.ts',
          name: 'customFormData',
        },
        mutator: {
          path: 'src/api/mutator/custom-instance.ts',
          name: 'customInstance',
        },
        formUrlEncoded: {
          path: 'src/api/mutator/custom-form-url-encoded.ts',
          name: 'customFormUrlEncoded',
        },
      },
    },
  },

  // generate zod schemas from the openapi file
  zod: {
    input: {
      target: '../backend/schemas/openapi.yaml',
      // validation: true, // Enable validation of the input file.
    },
    output: {
      prettier: true,
      target: 'src/api/schemas/zod.ts',
      clean: true,
      client: 'zod',
      mode: 'single',
    },
  },
})


--- Start of frontend/README.md ---

# Frontend

## Description

- Frontend application for the Tribe Platform that provides a modern, responsive UI for the chat functionality. Built with Vite, React, and Tanstack tools for optimal performance and developer experience.

## Features

- Fast development experience with Vite build system
- Data fetching and state management with React Query
- Modern routing with React Router
- Comprehensive testing suite with Playwright and Vitest
- Consistent code quality with ESLint and Prettier
- Production-ready authentication system

## Quick Start Guide

### Prerequisites

- Node.js
- npm

### Installation and Setup

```bash
./scripts/setup.sh
```

### VSCode Setup

For optimal development experience in VSCode, add the following to your settings.json:

```json
{
  "prettier.enable": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,

  // Auto fix
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit",
    "source.organizeImports": "never"
  },
  // Enable eslint for all supported languages
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact",
    "html",
    "markdown",
    "json",
    "yaml",
    "xml",
    "css",
    "scss",
    "pcss",
    "postcss"
  ]
}
```

## Key Scripts

```sh
# Run development server
npm run dev

# Build for production
npm run build

# Serve production build
npm run preview

# Run unit tests
npm run test:unit

# Run end-to-end tests
npm run e2e

# Run end-to-end tests in UI mode
npm run e2e:ui

# View end-to-end test report
npm run e2e:report

# Run ESLint
npm run lint

# Fix ESLint issues
npm run lint:fix

# See ESLint rules
npm run lint:inspect
```

## Development Workflow

### Testing

We have two types of tests:

1. **E2E tests**: Built with Playwright, located in the `tests/e2e/` directory

   - Tests full application flows from the user's perspective
   - Run with `npm run e2e` or `npm run e2e:ui` for visual mode

2. **Unit tests**: Using Vitest and React Testing Library, located in the `tests/` directory
   - Tests business logic and component behavior
   - Run with `npm run test:unit`

### Linting and Formatting

We use ESLint for linting and Prettier for formatting:

- Run `npm run lint` to check for issues
- Run `npm run lint:fix` to automatically fix issues
- Run `npm run lint:inspect` to see the ESLint rules in use

### Commit Guidelines

We use commitlint to enforce conventional commits, ensuring consistent and meaningful commit messages.

## Technical Architecture

### Framework

Our project uses Vite as the build system. Vite offers:

- A fast dev server with hot module replacement (HMR)
- Optimized production builds using Rollup

### API Integration

React Query is used for data fetching. It provides a powerful and flexible API to manage data fetching and caching.

### Routing

React Router is used for routing. It provides a simple and flexible way to handle client-side routing.

### Authentication

We use HTTP cookies for authentication where all requests to the backend include a cookie. If the backend throws a `401`, the user is considered no longer authenticated and will be redirected to login, handled by an axios interceptor.

### Environment Variables

We support both build-time and runtime environment variables:

- A custom tool scans for Vite environment variables (`import.meta.env`)
- Variables are injected into `index.html` as templates
- At runtime, `envsubst` command substitutes actual values
- Environment variables are validated using Zod

## Troubleshooting

If you encounter issues:

1. Ensure all prerequisites are installed and up-to-date
2. Verify the backend API is running and accessible
3. Check browser console for error messages
4. Clear browser cache and cookies if authentication issues occur


--- Start of frontend/package.json ---

{
  "name": "tribe-platform-frontend-chat-app",
  "type": "module",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "build:analyze": "npx vite-bundle-visualizer",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "lint:inspect": "npx @eslint/config-inspector",
    "preview": "vite preview",
    "format": "prettier --write .",
    "unit": "vitest --run",
    "unit:watch": "vitest",
    "unit:coverage": "vitest run --coverage",
    "type-check": "tsc -p tsconfig.json --noEmit",
    "e2e": "playwright test",
    "e2e:ui": "playwright test --ui",
    "e2e:report": "playwright show-report",
    "test": "npm run unit && npm run e2e",
    "generate": "npx orval --config ./orval.config.ts"
  },
  "dependencies": {
    "@emotion/react": "11.13.0",
    "@emotion/styled": "11.13.0",
    "@hookform/resolvers": "3.9.0",
    "@microsoft/fetch-event-source": "^2.0.1",
    "@mui/joy": "5.0.0-beta.48",
    "@sentry/react": "^8.34.0",
    "@sentry/vite-plugin": "2.22.3",
    "@tanstack/react-query": "5.51.21",
    "@tanstack/react-query-devtools": "5.51.21",
    "axios": "^1.7.7",
    "date-fns": "3.6.0",
    "i18next": "23.12.7",
    "i18next-fetch-backend": "^6.0.0",
    "lodash.debounce": "^4.0.8",
    "lucide-react": "0.424.0",
    "posthog-js": "1.207.3",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-dropzone": "^14.3.5",
    "react-error-boundary": "4.0.13",
    "react-helmet": "^2.0.5",
    "react-helmet-async": "^2.0.5",
    "react-hook-form": "7.52.2",
    "react-i18next": "15.0.1",
    "react-markdown": "9.0.1",
    "react-resizable-panels": "^2.1.7",
    "react-router-dom": "6.26.2",
    "react-syntax-highlighter": "15.5.0",
    "remark-gfm": "^4.0.0",
    "vite-plugin-runtime-env": "0.1.1",
    "vite-plugin-svgr": "4.2.0",
    "zustand": "4.5.5"
  },
  "devDependencies": {
    "@antfu/eslint-config": "3.8.0",
    "@commitlint/cli": "^19.3.0",
    "@commitlint/config-conventional": "^19.2.2",
    "@commitlint/types": "^19.0.3",
    "@eslint-react/eslint-plugin": "^1.8.0",
    "@ianvs/prettier-plugin-sort-imports": "^4.4.1",
    "@playwright/test": "^1.45.3",
    "@tanstack/eslint-plugin-query": "^5.51.15",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^13.2.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/lodash.debounce": "^4.0.9",
    "@types/node": "^22.0.2",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@types/react-helmet": "^6.1.11",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@vitejs/plugin-react": "^4.3.1",
    "ajv": "^8.17.1",
    "dotenv": "^16.4.5",
    "eslint": "^9.8.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-playwright": "^1.6.2",
    "eslint-plugin-react-hooks": "5.0.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "jsdom": "^24.0.0",
    "lint-staged": "^15.2.7",
    "orval": "^7.2.0",
    "path": "^0.12.7",
    "prettier": "3.4.2",
    "typescript": "^5.2.2",
    "vite": "^5.4.9",
    "vitest": "2.0.5",
    "zod": "3.23.8"
  }
}


--- Start of frontend/VERSION ---

0.0.1


--- Start of frontend/global.d.ts ---

declare module '*.svg' {
  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>
  const src: string
  export default src
}

export {}


--- Start of frontend/playwright.config.ts ---

import { defineConfig, devices } from '@playwright/test'
import dotenv from 'dotenv'

// Load environment variables from .env file
const {
  parsed: { VITE__E2E_CI_MODE, VITE__BASE_URL },
} = dotenv.config({ path: '.env' }) as {
  parsed: Record<string, string>
}

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: './tests/e2e',
  quiet: false,

  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on VITE__E2E_CI_MODE if you accidentally left test.only in the source code. */
  forbidOnly: !!VITE__E2E_CI_MODE,
  /* Retry on CI only */
  retries: VITE__E2E_CI_MODE ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: VITE__E2E_CI_MODE ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  outputDir: './tests/e2e/reports',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: VITE__BASE_URL,

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },

    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* Test against mobile viewports. */
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    {
      name: 'Google Chrome',
      use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    port: 3000,
    timeout: 120 * 1000,
    reuseExistingServer: !VITE__E2E_CI_MODE,
  },
})


--- Start of frontend/eslint.config.js ---

import antfu from '@antfu/eslint-config'
import eslintConfigPrettier from 'eslint-config-prettier'
import playwright from 'eslint-plugin-playwright'

/**
 * Configuration for ESLint. Run npm run lint:inspect to see
 * the full configuration and the rules that are being applied.
 */

export default antfu(
  {
    react: true,
    test: true, // Linting for vitest
    rules: {
      'perfectionist/sort-imports': 'off',
      'perfectionist/sort-exports': 'off',
      'perfectionist/sort-named-exports': 'off',
      'perfectionist/sort-named-imports': 'off',
    },

    ignores: [
      'src/routeTree.gen.ts', // Generated code
      'src/api/models', // Generated models
      'src/api/schemas', // Generated schemas
      'src/api/services', // Generated services
    ],
  },
  eslintConfigPrettier,
  {
    ...playwright.configs['flat/recommended'],
    files: ['tests/**'],
    name: 'playwright',
    ignores: ['tests/unit/**'],
  },
)


--- Start of frontend/vite.config.ts ---

/// <reference types="vitest" />

import path from 'node:path'
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'
import runtimeEnv from 'vite-plugin-runtime-env'
import svgr from 'vite-plugin-svgr'

export default defineConfig(() => {
  return {
    plugins: [
      react(),
      svgr(),
      runtimeEnv({
        ignoreEnv: [
          // get build envs from env file and get buildEnvs from env file
          'VITE__E2E_CI_MODE',
          'VITE__ENVIRONMENT',
        ],
      }),
    ],
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    test: {
      // use jsdom as the test environment
      environment: 'jsdom',
      // setup file to import necessary dependencies
      setupFiles: ['./tests/unit/setup.ts'],
      env: {
        VITE__API_BASE_URL: 'http://localhost:8000',
      },
      // run tests only in the tests/unit directory
      include: ['tests/unit/**/*{spec,test}.{js,ts,jsx,tsx}'],
    },
    server: {
      port: 3000,
    },
    preview: {
      port: 3000,
    },
  }
})


--- Start of frontend/scripts/schema.sh ---

#!/usr/bin/env bash
set -euo pipefail

[[ -d ../.git ]] || { echo "Script should be run from the frontend/ dir"; exit 1; }

echo "Removing current generated client"
rm -rf src/api/models src/api/services

echo "Generating client from schemas"
npm run generate

# Function to convert snake_case to camelCase
snake_to_camel() {
  local result="$1"
  while [[ $result == *_* ]]; do
    # Find position of first underscore
    local under_pos=$(echo "$result" | grep -b -o "_" | head -n1 | cut -d: -f1)
    # Get the character after underscore
    local char_after=$(echo "$result" | cut -c$((under_pos+2)))
    # Convert to uppercase
    local upper_char=$(echo "$char_after" | tr '[:lower:]' '[:upper:]')
    # Replace _x with X
    result="${result:0:$under_pos}${upper_char}${result:$((under_pos+2))}"
  done
  echo "$result"
}

process_file() {
  local file="$1"
  local tmp_file="${file}.tmp"

  # Process the file line by line
  while IFS= read -r line; do
    # Check for export const declarations
    if [[ $line =~ ^export\ const\ ([a-z_][a-z0-9_]*) ]]; then
      const_name="${BASH_REMATCH[1]}"
      if [[ $const_name == *_* ]]; then
        camel_name=$(snake_to_camel "$const_name")
        line="${line/export const $const_name/export const $camel_name}"
      fi
    fi

    # Check for property names inside Zod objects
    if [[ $line =~ [[:space:]]+([a-z_][a-z0-9_]*)[?]?: ]]; then
      # Capture the property name and check if it has an optional modifier
      prop_name="${BASH_REMATCH[1]}"

      if [[ $prop_name == *_* ]]; then
        camel_prop=$(snake_to_camel "$prop_name")

        # Replace the property name while preserving the optional modifier
        # First check if there's a question mark (optional property)
        if [[ $line =~ [[:space:]]+([a-z_][a-z0-9_]*)[?]: ]]; then
          line="${line/$prop_name?:/$camel_prop?:}"
        else
          line="${line/$prop_name:/$camel_prop:}"
        fi
      fi
    fi

    echo "$line" >> "$tmp_file"
  done < "$file"

  mv "$tmp_file" "$file"
}

echo "Converting schemas (adjusting cases)"
cd src/api/schemas
for file in *.ts; do
  echo "Converting $file"
  process_file "$file"
done

echo "Converting models (adjusting cases)"
cd ../models
for file in *.ts; do
  echo "Converting $file"
  process_file "$file"
done

echo "Linting"
npx lint-staged


--- Start of frontend/scripts/entrypoint.sh ---

#!/bin/sh

INDEX_HTML_PATH_IN_NGINX_CONTAINER=/usr/share/nginx/html/index.html
INDEX_HTML_PATH_TEMP=/usr/share/nginx/html/index.html.temp

echo "  VITE__API_BASE_URL=${VITE__API_BASE_URL}"

cp ${INDEX_HTML_PATH_IN_NGINX_CONTAINER} ${INDEX_HTML_PATH_TEMP}
envsubst < ${INDEX_HTML_PATH_TEMP} > ${INDEX_HTML_PATH_IN_NGINX_CONTAINER}
echo "Replaced environment variables in index.html"

echo "Running original entrypoint.sh"
/docker-entrypoint.sh

echo "Starting nginx"


--- Start of frontend/src/App.tsx ---

import { HelmetProvider } from 'react-helmet-async'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

import { extendTheme } from '@mui/joy'

import { env } from '@/env'
import { ProductAnalyticsProvider } from '@/shared/analytics/product'
import {
  AppConfigurationProvider,
  type AppConfiguration,
} from '@/shared/configuration'
import { getTheme } from '@/shared/theme'
import { ThemeProvider } from '@/shared/theme/context'
import { Router } from '@/features/router'
import { ErrorBoundary } from '@/components/common/ErrorBoundary'
import { AppModeWrapper } from '@/components/layout/AppModeWrapper'

// eslint-disable-next-line react-refresh/only-export-components
export const queryClient = new QueryClient()

export function App({
  appConfiguration,
}: {
  appConfiguration: AppConfiguration
}) {
  const theme = extendTheme(getTheme(appConfiguration))
  const showReactQueryDevtools =
    appConfiguration.enableReactQueryDevtools &&
    env?.VITE__ENVIRONMENT === 'local'
  return (
    <ErrorBoundary>
      <AppConfigurationProvider appConfiguration={appConfiguration}>
        <ThemeProvider theme={theme}>
          <ProductAnalyticsProvider>
            <HelmetProvider>
              <QueryClientProvider client={queryClient}>
                <AppModeWrapper>
                  <Router />
                  {showReactQueryDevtools && (
                    <ReactQueryDevtools initialIsOpen={false} />
                  )}
                </AppModeWrapper>
              </QueryClientProvider>
            </HelmetProvider>
          </ProductAnalyticsProvider>
        </ThemeProvider>
      </AppConfigurationProvider>
    </ErrorBoundary>
  )
}


--- Start of frontend/src/main.tsx ---

import { StrictMode, Suspense } from 'react'
import ReactDOM from 'react-dom/client'

import { App } from '@/App'
import { initializeErrorAnalytics } from '@/shared/analytics/error'
import { initializeAppConfiguration } from '@/shared/configuration/hooks'
import { initializeTranslations } from '@/shared/i18n'
import { SplashScreen } from '@/components/layout/SplashScreen'

async function renderApp() {
  const [appConfiguration] = await Promise.all([
    initializeAppConfiguration(),
    initializeErrorAnalytics(),
    initializeTranslations(),
  ])

  const rootElement = document.getElementById('root')
  if (!rootElement) {
    throw new Error('Root element not found')
  }

  ReactDOM.createRoot(rootElement).render(
    <StrictMode>
      <Suspense fallback={<SplashScreen />}>
        <App appConfiguration={appConfiguration} />
      </Suspense>
    </StrictMode>,
  )
}

renderApp().catch(console.error)


--- Start of frontend/src/vite-env.d.ts ---

/// <reference types="vite/client" />
/// <reference types="vite-plugin-svgr/client" />


--- Start of frontend/src/env.ts ---

import z from 'zod'

/*
* This file provides a way to define and validate environment variables for the application.
* and exposes a validated `env` object that can be used throughout the application.

* Runtime environment variables:
* Ensure no sensitive information is stored in these variables, as they are exposed to the client.
*
* Build-time environment variables:
  These are baked into the build artifact.
*/

/*
 * Schemas
 */
export const runtimeEnvSchema = z.object({
  VITE__API_BASE_URL: z.string().min(1).url().trim(),
  VITE__ERROR_ANALYTICS_DSN: z.string().optional(), // Sentry DSN
  VITE__PRODUCT_ANALYTICS_HOST: z.string().optional(), // Posthog host
  VITE__PRODUCT_ANALYTICS_API_KEY: z.string().optional(), // Posthog key
  VITE__ERROR_ANALYTICS_ORGANIZATION: z.string().trim().optional(),
  VITE__ERROR_ANALYTICS_PROJECT_ID: z
    .string()
    .transform((val) => Number(val))
    .refine((num) => !Number.isNaN(num), { message: 'Must be a valid number' }) // Ensuring valid number
    .optional(),
  VITE__ERROR_ANALYTICS_ERROR_SAMPLE_RATE: z
    .string()
    .transform((val) => Number(val))
    .refine(
      (num) => {
        if (Number.isNaN(num)) {
          return false
        }
        return num >= 0 && num <= 1
      },
      { message: 'Must be a valid number between 0 and 1' },
    )
    .optional(),
})

export const buildEnvSchema = z.object({
  VITE__ENVIRONMENT: z.string().optional(),
  VITE__E2E_CI_MODE: z.string().optional(),
})

export const envSchema = runtimeEnvSchema.merge(buildEnvSchema)

/*
 * Environment variables
 */

// These are injected into the DOM and so can be configured at runtime.
export const runtimeEnvs: RuntimeEnv = {
  VITE__API_BASE_URL:
    window?.env?.VITE__API_BASE_URL ?? import.meta.env.VITE__API_BASE_URL,
  VITE__PRODUCT_ANALYTICS_API_KEY:
    window?.env?.VITE__PRODUCT_ANALYTICS_API_KEY ??
    import.meta.env.VITE__PRODUCT_ANALYTICS_API_KEY,
  VITE__PRODUCT_ANALYTICS_HOST:
    window?.env?.VITE__PRODUCT_ANALYTICS_HOST ??
    import.meta.env.VITE__PRODUCT_ANALYTICS_HOST,
  VITE__ERROR_ANALYTICS_DSN:
    window?.env?.VITE__ERROR_ANALYTICS_DSN ??
    import.meta.env.VITE__ERROR_ANALYTICS_DSN,
  VITE__ERROR_ANALYTICS_ORGANIZATION:
    window?.env?.VITE__ERROR_ANALYTICS_ORGANIZATION ??
    import.meta.env.VITE__ERROR_ANALYTICS_ORGANIZATION,
  VITE__ERROR_ANALYTICS_PROJECT_ID:
    window?.env?.VITE__ERROR_ANALYTICS_PROJECT_ID ??
    import.meta.env.VITE__ERROR_ANALYTICS_PROJECT_ID,
  VITE__ERROR_ANALYTICS_ERROR_SAMPLE_RATE:
    window?.env?.VITE__ERROR_ANALYTICS_ERROR_SAMPLE_RATE ??
    import.meta.env.VITE__ERROR_ANALYTICS_ERROR_SAMPLE_RATE,
}

// These are baked into the build.
export const buildEnvs: BuildEnv = {
  VITE__ENVIRONMENT: import.meta.env.VITE__ENVIRONMENT,
  VITE__E2E_CI_MODE: import.meta.env.VITE__E2E_CI_MODE,
}

// Merge the runtime and build-time environment variables
export const allEnvs = {
  ...runtimeEnvs,
  ...buildEnvs,
}

/*
 * Validation
 */

const envValidation = envSchema.safeParse(allEnvs)

export const env = envValidation.data

if (!envValidation.success) {
  console.error('Invalid environment variables:', envValidation.error.errors)
}

/*
 * Type definitions
 */

export type Env = z.infer<typeof envSchema>
export type RuntimeEnv = z.infer<typeof runtimeEnvSchema>
export type BuildEnv = z.infer<typeof buildEnvSchema>

declare global {
  interface Window {
    env: Partial<RuntimeEnv> // Partial to allow for possible undefined properties during runtime
  }
}


--- Start of frontend/src/features/settings/index.tsx ---

import { SettingsModal } from '@/features/settings/components/SettingsModal'

export { SettingsModal }


--- Start of frontend/src/features/settings/store.ts ---

import { create } from 'zustand'

interface SettingsStore {
  settingsModalOpen: boolean
  setSettingsModalOpen: ({ open }: { open?: boolean }) => void
}
const useSettingsStore = create<SettingsStore>((set) => ({
  settingsModalOpen: false,
  setSettingsModalOpen: ({ open }) => set({ settingsModalOpen: open }),
}))

export { useSettingsStore }


--- Start of frontend/src/features/settings/components/ApplicationSettings.tsx ---

import { useCallback } from 'react'
import { Controller, useForm } from 'react-hook-form'
import { useTranslation } from 'react-i18next'
import { useQueryClient } from '@tanstack/react-query'

import { useColorScheme } from '@mui/joy'
import Chip from '@mui/joy/Chip'
import FormControl from '@mui/joy/FormControl'
import FormLabel from '@mui/joy/FormLabel'
import Option from '@mui/joy/Option'
import Select from '@mui/joy/Select'
import Skeleton from '@mui/joy/Skeleton'
import Stack from '@mui/joy/Stack'

import { UserAppSettingsTheme, type PatchUserRequest } from '@/api/models'
import {
  getGetUserProfileQueryKey,
  useGetUserProfile,
  useUpdateUserProfile,
} from '@/api/services/api'

export function ApplicationSettings() {
  const queryClient = useQueryClient()
  const { setMode } = useColorScheme()
  const { t } = useTranslation()

  const { mutate } = useUpdateUserProfile()
  const { data: userProfile, isLoading } = useGetUserProfile()

  const { control } = useForm<{
    appSettings: {
      theme?: UserAppSettingsTheme
    }
  }>({
    defaultValues: {
      appSettings: {
        theme: 'system',
      },
    },
    values: {
      appSettings: {
        theme: userProfile?.appSettings?.theme,
      },
    },
  })

  const handleUpdateUserProfile = useCallback(
    (data: PatchUserRequest) => {
      mutate(
        { data },
        {
          onSuccess() {
            queryClient.invalidateQueries({
              queryKey: getGetUserProfileQueryKey(),
            })
          },
        },
      )
    },
    [mutate, queryClient],
  )

  return (
    <Stack spacing={2} py={2}>
      <FormControl
        size="sm"
        orientation="horizontal"
        sx={{
          width: '100%',
          justifyContent: 'space-between',
        }}
      >
        <FormLabel>Theme</FormLabel>

        {isLoading ?
          <Skeleton width={100} height={32} />
        : <Controller
            control={control}
            name="appSettings.theme"
            render={({ field }) => (
              <Select
                {...field}
                slotProps={{
                  listbox: {
                    sx: { zIndex: (theme) => theme.zIndex.modal + 1 },
                  },
                }}
                onChange={(_e, newValue) => {
                  if (!newValue) {
                    return
                  }

                  setMode(newValue)
                  field.onChange(newValue)

                  handleUpdateUserProfile({
                    appSettings: {
                      theme: newValue,
                    },
                  })
                }}
                variant="plain"
                defaultValue={userProfile?.appSettings?.theme}
                renderValue={(item) => (
                  <Chip>{t(`settings.theme.${item?.value}`)}</Chip>
                )}
              >
                {Object.values(UserAppSettingsTheme)?.map((theme) => (
                  <Option key={theme} value={theme}>
                    {theme}
                  </Option>
                ))}
              </Select>
            )}
          />
        }
      </FormControl>
    </Stack>
  )
}


--- Start of frontend/src/features/settings/components/SettingsModal.tsx ---

import { useTranslation } from 'react-i18next'

import DialogContent from '@mui/joy/DialogContent'
import DialogTitle from '@mui/joy/DialogTitle'
import Divider from '@mui/joy/Divider'

import { ApplicationSettings } from '@/features/settings/components/ApplicationSettings'
import { useSettingsStore } from '@/features/settings/store'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export function SettingsModal() {
  const { t } = useTranslation()
  const { setSettingsModalOpen, settingsModalOpen } = useSettingsStore()
  return (
    <ModalDialogBase
      onClose={() => setSettingsModalOpen({ open: false })}
      open={settingsModalOpen}
      modalDialogProps={{
        maxWidth: 'sm',
      }}
    >
      <DialogTitle>{t(`settings.title`)}</DialogTitle>
      <Divider />

      <DialogContent
        component="form"
        sx={{
          display: 'flex',
          flexDirection: 'column',
          gap: 4,
          py: 2,
          width: '100%',
        }}
      >
        <ApplicationSettings />
      </DialogContent>
    </ModalDialogBase>
  )
}


--- Start of frontend/src/features/home/components/HomeTopbar.tsx ---

import { memo } from 'react'
import { useTranslation } from 'react-i18next'

import IconButton from '@mui/joy/IconButton'
import Stack from '@mui/joy/Stack'
import Tooltip from '@mui/joy/Tooltip'

import { useResponsiveAppMode } from '@/shared/configuration'
import { AgentSelectionDropdown } from '@/features/agent/components/AgentSelectionDropdown'
import { useAgentStore } from '@/features/agent/store'
import { Icon } from '@/components/common'
import { TopNavigation, TopNavigationTitle } from '@/components/layout'

export const HomeTopbar = memo(() => {
  const { t } = useTranslation()
  const { isSmallScreen } = useResponsiveAppMode()
  const {
    setAgentConfigurationSidePanelOpen,
    agentConfigurationSidePanelOpen,
  } = useAgentStore()

  return (
    <TopNavigation justifyContent="space-between">
      <Stack
        direction="row"
        gap={1}
        flexShrink={1}
        alignItems="center"
        overflow="hidden"
      >
        <AgentSelectionDropdown />
      </Stack>
      {isSmallScreen && (
        <TopNavigationTitle>{t('home.title')}</TopNavigationTitle>
      )}
      <Stack direction="row" gap={0.5}>
        <Tooltip title="Configuration" arrow variant="soft">
          <IconButton
            size="sm"
            onClick={() =>
              setAgentConfigurationSidePanelOpen({
                open: !agentConfigurationSidePanelOpen,
              })
            }
          >
            <Icon name="config" />
          </IconButton>
        </Tooltip>
      </Stack>
    </TopNavigation>
  )
})


--- Start of frontend/src/features/home/components/ConversationStarters.tsx ---

import Box from '@mui/joy/Box'
import Skeleton from '@mui/joy/Skeleton'

import { useResponsiveAppMode } from '@/shared/configuration'
import { useGetConversationStarters } from '@/api/services/api'
import { ConversationStarterCard } from '@/features/conversation/components/ConversationStarterCard'
import { ErrorMessage } from '@/components/common'

export function ConversationStarters({
  conversationUuid,
}: {
  conversationUuid: string
}) {
  const { data, isError, isLoading, error } = useGetConversationStarters(
    {
      numStarters: 4,
    },
    {
      query: {
        refetchOnWindowFocus: false,
        staleTime: 1000 * 60 * 60,
      },
    },
  )

  if (isError) {
    return (
      <ErrorMessage
        error={`Error loading conversation starters: ${error?.message}`}
      />
    )
  }

  return (
    <ConversationStarterGrid>
      {isLoading ?
        Array.from({ length: 4 }).map((_) => (
          <Skeleton
            key={Math.random()}
            variant="rectangular"
            height={60}
            width="100%"
            animation="wave"
          />
        ))
      : data?.items.map((item) => (
          <ConversationStarterCard
            key={item?.title + item?.description + item?.messagePrefill}
            description={item?.description}
            title={item?.title}
            messagePrefill={item?.messagePrefill}
            conversationUuid={conversationUuid}
          />
        ))
      }
    </ConversationStarterGrid>
  )
}

function ConversationStarterGrid({ children }: { children: React.ReactNode }) {
  const { isSmallScreen, responsiveAppMode } = useResponsiveAppMode()
  if (isSmallScreen) {
    return (
      <Box display="flex" flexWrap="wrap" gap={2}>
        {children}
      </Box>
    )
  }
  return (
    <Box
      display="grid"
      gridTemplateColumns="repeat(auto-fill, minmax(200px, 1fr))"
      gap={responsiveAppMode === 'widget' ? 1 : 2}
    >
      {children}
    </Box>
  )
}


--- Start of frontend/src/features/home/components/IntroductoryText.tsx ---

import { memo } from 'react'
import { useTranslation } from 'react-i18next'

import Skeleton from '@mui/joy/Skeleton'
import Stack from '@mui/joy/Stack'
import Typography from '@mui/joy/Typography'

import { useResponsiveAppMode } from '@/shared/configuration'
import { capitaliseFirstLetter } from '@/shared/utils/capitalise-first-letter'
import { TypographyWithGradient } from '@/components/common'

export const IntroductoryText = memo(
  ({ isLoading, username }: { isLoading: boolean; username?: string }) => {
    const { t } = useTranslation()
    const { isSmallScreen } = useResponsiveAppMode()
    return (
      <Stack justifyContent="center" alignItems="center">
        <TypographyWithGradient>
          {isLoading ?
            <Skeleton variant="text" />
          : t('home.welcomeMessage', {
              name: capitaliseFirstLetter(username) || 'User',
            })
          }
        </TypographyWithGradient>

        <Typography
          level={isSmallScreen ? 'h2' : 'h1'}
          textColor="text.secondary"
        >
          {t('home.welcomeQuestion')}
        </Typography>
      </Stack>
    )
  },
)


--- Start of frontend/src/features/home/components/index.ts ---

import { ConversationStarters } from '@/features/home/components/ConversationStarters'
import { HomeTextarea } from '@/features/home/components/HomeTextarea'
import { HomeTopbar } from '@/features/home/components/HomeTopbar'
import { IntroductoryNotification } from '@/features/home/components/IntroductoryNotification'
import { IntroductoryText } from '@/features/home/components/IntroductoryText'

export {
  ConversationStarters,
  IntroductoryText,
  HomeTextarea,
  HomeTopbar,
  IntroductoryNotification,
}


--- Start of frontend/src/features/home/components/HomeTextarea.tsx ---

import {
  useGetSupportedExtensions,
  useGetUserProfile,
} from '@/api/services/api'
import { useSendInitialMessageAndNavigate } from '@/features/conversation/hooks'
import { useMessageStore } from '@/features/conversation/store'
import { Textarea } from '@/components/interactive'

function useGetLlmModelSupportedExtensions() {
  const { data: userProfile } = useGetUserProfile()
  const { data: supportedExtensions } = useGetSupportedExtensions(
    {
      agentUuid: userProfile?.defaultConversationSettings?.agentUuid,
    },
    {
      query: {
        enabled: !!userProfile?.defaultConversationSettings?.agentUuid,
      },
    },
  )
  return supportedExtensions
}

export function HomeTextarea({
  conversationUuid,
}: {
  conversationUuid: string
}) {
  const { message } = useMessageStore()
  const supportedExtensions = useGetLlmModelSupportedExtensions()
  const { handleSendMessage } = useSendInitialMessageAndNavigate({
    conversationUuid,
  })
  return (
    <Textarea
      conversationUuid={undefined}
      supportedExtensions={supportedExtensions}
      onSendMessage={() => handleSendMessage({ conversationUuid, message })}
    />
  )
}


--- Start of frontend/src/features/home/components/IntroductoryNotification.tsx ---

import { useTranslation } from 'react-i18next'

import Alert from '@mui/joy/Alert'
import IconButton from '@mui/joy/IconButton'
import Typography from '@mui/joy/Typography'

import { useAppConfiguration } from '@/shared/configuration'
import { useLocalStorage } from '@/shared/hooks'
import { Icon } from '@/components/common'

export function IntroductoryNotification() {
  const { t } = useTranslation()
  const { enableIntroductoryNotification } = useAppConfiguration()
  const [
    enableIntroductoryNotificationLS,
    setEnableIntroductoryNotificationLS,
  ] = useLocalStorage('enableIntroductoryNotification', true)

  const handleDismissAlert = () => {
    setEnableIntroductoryNotificationLS(false)
  }

  if (!enableIntroductoryNotification || !enableIntroductoryNotificationLS) {
    return null
  }

  return (
    <Alert
      color="neutral"
      invertedColors
      size="sm"
      variant="outlined"
      sx={{ alignItems: 'start' }}
      endDecorator={
        <IconButton onClick={handleDismissAlert}>
          <Icon name="close" />
        </IconButton>
      }
      startDecorator={<Icon name="info" />}
    >
      <Typography level="body-sm" textColor="text.primary">
        {t('home.introductoryNotificationText')}
      </Typography>
    </Alert>
  )
}


--- Start of frontend/src/features/agent/hooks.ts ---

import { useCallback } from 'react'
import { useQueryClient } from '@tanstack/react-query'

import {
  getGetAllAgentsQueryKey,
  getGetUserProfileQueryKey,
  useUpdateUserProfile,
} from '@/api/services/api'

export function useChangeAgent() {
  const queryClient = useQueryClient()
  const updateUser = useUpdateUserProfile()

  const handleChangeAgent = useCallback(
    (agentUuid: string) => {
      updateUser?.mutate(
        {
          data: {
            defaultConversationSettings: {
              agentUuid,
            },
          },
        },
        {
          onSuccess() {
            queryClient.invalidateQueries({
              queryKey: getGetUserProfileQueryKey(),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
          },
        },
      )
    },
    [queryClient, updateUser],
  )

  return { handleChangeAgent, ...updateUser }
}


--- Start of frontend/src/features/agent/store.ts ---

import { create } from 'zustand'

interface AgentStore {
  agentCreateModalOpen: boolean
  setAgentCreateModalOpen: ({ open }: { open: boolean }) => void
  agentConfigurationSidePanelOpen: boolean
  setAgentConfigurationSidePanelOpen: ({ open }: { open: boolean }) => void
}
const useAgentStore = create<AgentStore>((set) => ({
  agentCreateModalOpen: false,
  setAgentCreateModalOpen: ({ open }) => set({ agentCreateModalOpen: open }),
  agentConfigurationSidePanelOpen: false,
  setAgentConfigurationSidePanelOpen: ({ open }) =>
    set({ agentConfigurationSidePanelOpen: open }),
}))

export { useAgentStore }


--- Start of frontend/src/features/agent/components/AgentCreateModal.tsx ---

import { useCallback, useEffect } from 'react'
import { FormProvider, useForm } from 'react-hook-form'
import { useChangeAgent } from '../hooks'
import { useQueryClient } from '@tanstack/react-query'

import Button from '@mui/joy/Button'
import DialogActions from '@mui/joy/DialogActions'
import DialogContent from '@mui/joy/DialogContent'
import DialogTitle from '@mui/joy/DialogTitle'
import Divider from '@mui/joy/Divider'

import type {
  AgentConfigCreateFromExisting,
  AgentStockResponsesInitialMessage,
  TextMessageSectionTemplate,
  Tool,
} from '@/api/models'
import {
  getGetAllAgentsQueryKey,
  useCreateAgentConfig,
  useCreateNewAgent,
  useGetUserProfile,
} from '@/api/services/api'
import { AgentConfigTextarea } from '@/features/agent/components/AgentConfigTextarea'
import { AgentConfigTools } from '@/features/agent/components/AgentConfigTools'
import {
  DescriptionField,
  ModelSelection,
  NameField,
} from '@/features/agent/components/AgentGeneralForm'
import { useAgentStore } from '@/features/agent/store'
import { ErrorMessage } from '@/components/common'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export interface AgentConfigFormFields {
  role?: TextMessageSectionTemplate['template']
  instructions?: TextMessageSectionTemplate['template']
  isActive?: boolean
  version?: number
  initialMessage?: AgentStockResponsesInitialMessage
  tools?: AgentConfigCreateFromExisting['tools']
}
const fields = [
  {
    name: 'role' as const,
    label: 'Role',
    helperText:
      "Describe the role of the agent. It's good to be overly complimentary. E.g. You are the world leading expert in...",
    placeholder:
      "Describe the role of the agent. It's good to be overly complimentary. E.g. You are the world leading expert in...",
  },
  {
    name: 'instructions' as const,
    label: 'Instructions',
    helperText:
      'Describe the task the agent is to perform. E.g. Please provide a summary of the article...',
    placeholder:
      'Describe the task the agent is to perform. E.g. Please provide a summary of the article...',
  },
  {
    name: 'initialMessage' as const,
    label: "Agent's Initial Message",
    helperText:
      "The first message the agent will send to the user. E.g. Hi, I'm here to help you with...",
    placeholder:
      "The first message the agent will send to the user. E.g. Hi, I'm here to help you with...",
  },
]

export function AgentCreateModal() {
  const queryClient = useQueryClient()
  const { data: userProfile } = useGetUserProfile()
  const { agentCreateModalOpen, setAgentCreateModalOpen } = useAgentStore()
  const agentCreateForm = useForm({
    defaultValues: {
      name: '',
      description: '',
      isPublic: false,
      llmModelId: '',
      assetUuids: [],
      initialMessage: '',
      instructions: '',
      role: '',
      tools: [] as Tool[],
    },
  })

  const {
    mutateAsync: createNewAgent,
    isPending: createAgentIsPending,
    isSuccess: createAgentIsSuccess,
    isError: createAgentIsError,
    error: createAgentError,
  } = useCreateNewAgent()
  const {
    mutate: createAgentConfig,
    isPending: createAgentConfigIsPending,
    isSuccess: createAgentConfigIsSuccess,
    isError: createAgentConfigIsError,
    error: createAgentConfigError,
  } = useCreateAgentConfig()
  const { handleChangeAgent } = useChangeAgent()

  const handleClose = useCallback(() => {
    setAgentCreateModalOpen({ open: false })
  }, [setAgentCreateModalOpen])

  const handleCreateAgent = useCallback(
    async (data: {
      name: string
      description: string
      isPublic: boolean
      llmModelId: string
      assetUuids: string[]
      initialMessage: string
      instructions: string
      tools: AgentConfigCreateFromExisting['tools']
      role: string
    }) => {
      if (!userProfile?.defaultConversationSettings?.agentUuid) {
        return
      }

      if ((await agentCreateForm.trigger()) === false) {
        return
      }

      const {
        role,
        name,
        instructions,
        initialMessage,
        description,
        llmModelId,
      } = data
      const newAgent = await createNewAgent({
        data: {
          llmModelId,
          name,
          description,
        },
      })
      if (!newAgent) {
        return
      }
      createAgentConfig(
        {
          agentUuid: newAgent?.uuid,
          data: {
            name,
            isActive: true,
            stockResponses: {
              initialMessage,
              maxLengthReached: "Sorry, I can't accept any more text",
            },
            promptTemplate: {
              name: 'default',
              sectionsTemplate: [
                {
                  id: 'role',
                  template: role ?? '',
                  role: 'system',
                },
                {
                  id: 'task_instructions',
                  template: instructions ?? '',
                  role: 'system',
                },
              ],
            },
            tools: data.tools,
          },
        },
        {
          onSuccess() {
            handleChangeAgent(newAgent.uuid)
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
          },
        },
      )
    },
    [
      agentCreateForm,
      createAgentConfig,
      createNewAgent,
      handleChangeAgent,
      queryClient,
      userProfile?.defaultConversationSettings?.agentUuid,
    ],
  )

  useEffect(() => {
    if (createAgentIsSuccess && createAgentConfigIsSuccess) {
      agentCreateForm.reset()
      handleClose()
    }
  }, [
    createAgentIsSuccess,
    createAgentConfigIsSuccess,
    handleClose,
    agentCreateForm,
  ])

  return (
    <FormProvider {...agentCreateForm}>
      <ModalDialogBase
        open={agentCreateModalOpen}
        onClose={handleClose}
        modalDialogProps={{
          sx: {
            overflow: 'hidden',
            backgroundColor: 'background.body',
          },
        }}
      >
        <DialogTitle>Create Agent</DialogTitle>
        <Divider />
        <DialogContent
          sx={{
            display: 'flex',
            flexDirection: 'column',
            gap: 2,
            height: '100%',
            mb: 2,
          }}
        >
          {(createAgentIsError || createAgentConfigIsError) && (
            <ErrorMessage error={createAgentError ?? createAgentConfigError} />
          )}
          <NameField
            options={{
              required: 'Name is required',
            }}
          />
          <DescriptionField />
          <ModelSelection
            options={{
              required: 'Model is required',
            }}
          />
          {fields.map((field) => (
            <AgentConfigTextarea
              key={field.name}
              name={field.name}
              label={field.label}
              helperText={field.helperText}
              placeholder={field.placeholder}
            />
          ))}
          <AgentConfigTools />
        </DialogContent>

        <DialogActions
          sx={{ display: 'flex', justifyContent: 'space-between' }}
        >
          <Button
            variant="solid"
            size="sm"
            color="primary"
            loading={createAgentIsPending || createAgentConfigIsPending}
            onClick={agentCreateForm.handleSubmit(handleCreateAgent)}
          >
            Create
          </Button>
          <Button
            variant="soft"
            color="neutral"
            size="sm"
            onClick={handleClose}
          >
            Cancel
          </Button>
        </DialogActions>
      </ModalDialogBase>
    </FormProvider>
  )
}


--- Start of frontend/src/features/agent/components/AgentConfigVersionChip.tsx ---

import Chip from '@mui/joy/Chip'
import Tooltip from '@mui/joy/Tooltip'

import type { AgentConfigReadResponseNotes } from '@/api/models'

export function AgentConfigVersionChip({
  version,
  notes,
}: {
  version?: number
  notes?: AgentConfigReadResponseNotes
}) {
  return (
    <Tooltip title={notes} arrow variant="soft">
      <Chip size="sm" variant="outlined" color="neutral">
        {`v${version}`}
      </Chip>
    </Tooltip>
  )
}


--- Start of frontend/src/features/agent/components/AgentModal.tsx ---

import type { ReactNode } from 'react'

import DialogTitle from '@mui/joy/DialogTitle'
import IconButton from '@mui/joy/IconButton'
import Skeleton from '@mui/joy/Skeleton'
import Stack from '@mui/joy/Stack'

import type { AgentConfigReadResponse, AgentReadResponse } from '@/api/models'
import { AgentActionsMenu } from '@/features/agent/components/AgentActionsMenu'
import { AgentTitle } from '@/features/agent/components/AgentTitle'
import { useAgentStore } from '@/features/agent/store'
import { Icon } from '@/components/common'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export function AgentModalHeader({
  agentName,
  agentUuid,
  isPublic,
  ownerUsername,
  version,
  userUuid,
  isLoading,
}: {
  agentName?: string
  isPublic?: boolean
  ownerUsername?: AgentReadResponse['ownerUsername']
  agentUuid?: string
  version?: AgentConfigReadResponse['version']
  userUuid?: string
  isLoading?: boolean
}) {
  const { setAgentConfigurationSidePanelOpen } = useAgentStore()
  const handleClose = () => {
    setAgentConfigurationSidePanelOpen({ open: false })
  }
  return (
    <DialogTitle
      sx={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
      }}
    >
      {isLoading ?
        <Skeleton variant="text" width={100} />
      : <AgentTitle
          agentName={agentName}
          isPublic={isPublic}
          ownerUsername={ownerUsername}
          version={version}
        />
      }
      <Stack direction="row" gap={0.5}>
        {agentUuid && (
          <AgentActionsMenu agentUuid={agentUuid} userUuid={userUuid} />
        )}
        <IconButton size="sm" onClick={handleClose}>
          <Icon name="close" />
        </IconButton>
      </Stack>
    </DialogTitle>
  )
}

export function AgentModal({ children }: { children: ReactNode }) {
  const {
    agentConfigurationSidePanelOpen,
    setAgentConfigurationSidePanelOpen,
  } = useAgentStore()
  const handleClose = () => {
    setAgentConfigurationSidePanelOpen({ open: false })
  }
  return (
    <ModalDialogBase
      open={agentConfigurationSidePanelOpen}
      onClose={handleClose}
      withCloseButton={false}
      modalDialogProps={{
        sx: {
          overflow: 'hidden',
          backgroundColor: 'background.body',
        },
      }}
    >
      {children}
    </ModalDialogBase>
  )
}


--- Start of frontend/src/features/agent/components/AgentGeneralForm.tsx ---

import { useCallback } from 'react'
import {
  Controller,
  FormProvider,
  useForm,
  useFormContext,
  type RegisterOptions,
} from 'react-hook-form'
import { useQueryClient } from '@tanstack/react-query'

import Box from '@mui/joy/Box'
import FormControl from '@mui/joy/FormControl'
import FormHelperText from '@mui/joy/FormHelperText'
import FormLabel from '@mui/joy/FormLabel'
import Input from '@mui/joy/Input'
import Switch from '@mui/joy/Switch'

import type {
  AgentReadResponse,
  AgentReadResponseDescription,
  HTTPValidationError,
} from '@/api/models'
import type { ErrorType } from '@/api/mutator/custom-instance'
import {
  getGetAgentByUuidQueryKey,
  getGetAllAgentsQueryKey,
  getGetUserProfileQueryKey,
  useUpdateAgentByUuid,
} from '@/api/services/api'
import { AgentModelSelectionDropdown } from '@/features/agent/components/AgentModelSelectionDropdown'

export interface AgentGeneralFormFields {
  name?: string
  description?: AgentReadResponseDescription
  isPublic?: boolean
  llmModelId?: string
  assetUuids?: string[]
}
export function AgentGeneralForm({
  enableReadOnly,
  agentUuid,
  activeAgentData,
}: {
  enableReadOnly: boolean
  agentUuid: string
  activeAgentData?: AgentReadResponse
}) {
  const queryClient = useQueryClient()
  const agentGeneralForm = useForm<AgentGeneralFormFields>({
    defaultValues: {
      name: activeAgentData?.name ?? '',
      description: activeAgentData?.description ?? '',
      isPublic: activeAgentData?.isPublic ?? false,
      llmModelId: activeAgentData?.llmModelId ?? '',
    },
  })
  const { mutate: updateAgent, error: updateAgentError } =
    useUpdateAgentByUuid()

  const handleUpdateAgent = useCallback(
    async (data: Partial<AgentGeneralFormFields>) => {
      if (!agentUuid) {
        return
      }

      // Only validate if we're updating name or description
      const isNameOrDescription = data.name || data.description
      const isTriggerValid = (await agentGeneralForm?.trigger()) !== false
      if (isNameOrDescription && !isTriggerValid) {
        return
      }

      updateAgent(
        {
          agentUuid,
          data: {
            name: data.name,
            isPublic: data.isPublic,
            description: data.description,
            llmModelId: data.llmModelId,
          },
        },
        {
          onSuccess() {
            queryClient.invalidateQueries({
              queryKey: getGetAgentByUuidQueryKey(agentUuid),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
            queryClient.invalidateQueries({
              queryKey: getGetUserProfileQueryKey(),
            })
          },
        },
      )
    },
    [agentUuid, agentGeneralForm, queryClient, updateAgent],
  )

  return (
    <FormProvider {...agentGeneralForm}>
      <Box
        sx={{
          display: 'flex',
          flexDirection: 'column',
          gap: 4,
          height: '100%',
          mb: 2,
        }}
      >
        <PublicToggle
          disabled={enableReadOnly}
          onToggle={(checked) => handleUpdateAgent({ isPublic: checked })}
        />
        <ModelSelection
          disabled={enableReadOnly}
          handleChangeAgent={(data) => handleUpdateAgent(data)}
          error={updateAgentError}
          options={{ required: 'Model is required' }}
        />
        <NameField
          disabled={enableReadOnly}
          onBlur={(value) => handleUpdateAgent({ name: value })}
          error={updateAgentError}
          options={{ required: 'Name is required' }}
        />
        <DescriptionField
          disabled={enableReadOnly}
          onBlur={(value) => handleUpdateAgent({ description: value })}
          error={updateAgentError}
        />
      </Box>
    </FormProvider>
  )
}

export function PublicToggle({
  disabled,
  onToggle,
  error,
  options,
}: {
  disabled?: boolean
  onToggle?: (checked: boolean) => void
  error?: ErrorType<HTTPValidationError> | null
  options?: RegisterOptions<AgentGeneralFormFields, 'isPublic'> | undefined
}) {
  const { control } = useFormContext<AgentGeneralFormFields>()
  return (
    <FormControl size="sm" error={!!error} disabled={disabled}>
      <Box display="flex" justifyContent="space-between" alignItems="center">
        <FormLabel> Make public (visible to all users) </FormLabel>
        <Controller
          name="isPublic"
          control={control}
          defaultValue={false}
          rules={options}
          render={({ field }) => (
            <Switch
              checked={field.value}
              onChange={(e) => {
                field.onChange(e.target.checked)
                onToggle?.(e.target.checked)
              }}
              size="md"
              disabled={disabled}
            />
          )}
        />
      </Box>

      {error && (
        <FormHelperText color="danger">{error?.message}</FormHelperText>
      )}
    </FormControl>
  )
}

export function NameField({
  disabled,
  onBlur,
  error,
  options,
}: {
  disabled?: boolean
  onBlur?: (value: string) => void
  error?: ErrorType<HTTPValidationError> | null
  options?: RegisterOptions<AgentGeneralFormFields, 'name'> | undefined
}) {
  const {
    register,
    formState: { errors },
  } = useFormContext<AgentGeneralFormFields>()
  return (
    <FormControl size="sm">
      <FormLabel>Name</FormLabel>
      <Input
        size="sm"
        placeholder="Give your agent a name"
        error={!!errors?.name}
        disabled={disabled}
        variant="plain"
        {...register('name', {
          onBlur: (e) => onBlur?.(e.target.value),
          ...options,
        })}
      />
      {errors?.name && (
        <FormHelperText color="danger">{errors.name.message}</FormHelperText>
      )}
      {error && (
        <FormHelperText color="danger">{error?.message}</FormHelperText>
      )}
    </FormControl>
  )
}

export function DescriptionField({
  disabled,
  onBlur,
  error,
}: {
  disabled?: boolean
  onBlur?: (value: string) => void
  error?: ErrorType<HTTPValidationError> | null
}) {
  const {
    register,
    formState: { errors },
  } = useFormContext<AgentGeneralFormFields>()
  return (
    <FormControl size="sm">
      <FormLabel>Description</FormLabel>
      <Input
        size="sm"
        placeholder="Add a description"
        error={!!errors?.description}
        disabled={disabled}
        variant="plain"
        {...register('description', {
          onBlur: (e) => onBlur?.(e.target.value),
        })}
      />
      {errors?.description && (
        <FormHelperText color="danger">
          {errors.description.message}
        </FormHelperText>
      )}
      {error && <FormHelperText color="danger">{error?.name}</FormHelperText>}
    </FormControl>
  )
}

export function ModelSelection({
  handleChangeAgent,
  disabled,
  error,
  options,
}: {
  handleChangeAgent?: (data: { llmModelId: string }) => void
  disabled?: boolean
  error?: ErrorType<HTTPValidationError> | null
  options?: RegisterOptions<AgentGeneralFormFields, 'llmModelId'> | undefined
}) {
  const {
    formState: { errors },
  } = useFormContext<AgentGeneralFormFields>()
  return (
    <FormControl size="sm" error={!!errors.llmModelId}>
      <FormLabel>Model</FormLabel>
      <AgentModelSelectionDropdown
        disabled={disabled}
        handleChangeAgent={handleChangeAgent}
        options={options}
      />
      {error && (
        <FormHelperText color="danger">{error?.message}</FormHelperText>
      )}

      {errors.llmModelId && (
        <FormHelperText color="danger">
          {errors.llmModelId.message}
        </FormHelperText>
      )}
    </FormControl>
  )
}


--- Start of frontend/src/features/agent/components/AgentModelSelectionDropdown.tsx ---

import {
  Controller,
  useFormContext,
  type RegisterOptions,
} from 'react-hook-form'
import type { AgentGeneralFormFields } from './AgentGeneralForm'

import Box from '@mui/joy/Box'
import List from '@mui/joy/List'
import ListItem from '@mui/joy/ListItem'
import Option from '@mui/joy/Option'
import Select from '@mui/joy/Select'
import Typography from '@mui/joy/Typography'

import { useResponsiveAppMode } from '@/shared/configuration/hooks'
import type { LLMInfo } from '@/api/models'
import { useGetAvailableLlmInfos } from '@/api/services/api'
import { AssistantAvatar } from '@/components/common/avatars/AssistantAvatar'

function groupModelsByProvider(
  availableModels: LLMInfo[] = [],
): Record<string, LLMInfo[]> {
  const modelsGroupedByProvider =
    availableModels?.reduce(
      (acc, model) => {
        // take some data and group it by provider name
        const providerName = model.provider.name
        if (!acc[providerName]) {
          acc[providerName] = []
        }
        acc[providerName].push(model)
        return acc
      },
      {} as Record<string, LLMInfo[]>,
    ) ?? {}
  return modelsGroupedByProvider
}

export function AgentModelSelectionDropdown({
  disabled,
  handleChangeAgent,
  options,
}: {
  disabled?: boolean
  handleChangeAgent?: (data: { llmModelId: string }) => void
  options?: RegisterOptions<AgentGeneralFormFields, 'llmModelId'> | undefined
}) {
  const { isSmallScreen, responsiveAppMode } = useResponsiveAppMode()
  const { control } = useFormContext()
  const { data: availableLlmInfos } = useGetAvailableLlmInfos()
  const modelsGroupedByProvider = groupModelsByProvider(
    availableLlmInfos?.items,
  )

  return (
    <Controller
      control={control}
      name="llmModelId"
      defaultValue={null}
      rules={options}
      render={({ field: { onChange, ...rest } }) => {
        return (
          <Select
            placeholder="Select a model"
            {...rest}
            onChange={(_e, newValue) => {
              if (!newValue) {
                return
              }
              onChange(newValue)
              handleChangeAgent?.({ llmModelId: newValue })
            }}
            disabled={disabled}
            slotProps={{
              listbox: {
                disablePortal: responsiveAppMode === 'widget',
              },
            }}
            variant="plain"
            size="sm"
            sx={{ width: 1 }}
            renderValue={(value) => {
              const model = availableLlmInfos?.items?.find(
                ({ llmModelId }) => llmModelId === value?.value,
              )
              return (
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <AssistantAvatar
                    size="sm"
                    sx={{
                      width: '18px',
                      height: '18px',
                    }}
                    src={model?.provider?.imageUrl ?? undefined}
                  />
                  <Typography
                    level="body-sm"
                    textColor="text.primary"
                    display={isSmallScreen ? 'none' : 'block'}
                  >
                    {model?.llmModelDisplayName}
                  </Typography>
                </Box>
              )
            }}
          >
            {Object.entries(modelsGroupedByProvider || {}).map(
              ([providerName, models]) => (
                <ListItem nested key={providerName}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Typography level="title-sm" py={1}>
                      {providerName}
                    </Typography>
                  </Box>
                  <List
                    sx={{
                      '--ListItem-radius': (theme) => theme.vars.radius.sm,
                    }}
                  >
                    {models.map((model) => (
                      <Option
                        value={model.llmModelId}
                        key={model.llmModelId}
                        sx={{
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          gap: 1,
                        }}
                      >
                        <Box
                          sx={{ display: 'flex', alignItems: 'center', gap: 1 }}
                        >
                          <AssistantAvatar
                            size="sm"
                            sx={{
                              width: '18px',
                              height: '18px',
                            }}
                            src={model?.provider?.imageUrl ?? undefined}
                          />
                          <Typography level="body-sm" textColor="text.primary">
                            {model.llmModelDisplayName}
                          </Typography>
                        </Box>
                      </Option>
                    ))}
                  </List>
                </ListItem>
              ),
            )}
          </Select>
        )
      }}
    />
  )
}


--- Start of frontend/src/features/agent/components/AgentSelectionDropdown.tsx ---

import { useState } from 'react'
import { useFeatureFlagEnabled } from 'posthog-js/react'

import { ListItemButton, Tooltip } from '@mui/joy'
import Divider from '@mui/joy/Divider'
import Dropdown from '@mui/joy/Dropdown'
import IconButton from '@mui/joy/IconButton'
import List from '@mui/joy/List'
import ListItem from '@mui/joy/ListItem'
import ListItemContent from '@mui/joy/ListItemContent'
import ListItemDecorator from '@mui/joy/ListItemDecorator'
import Menu from '@mui/joy/Menu'
import MenuButton from '@mui/joy/MenuButton'
import MenuItem from '@mui/joy/MenuItem'
import Skeleton from '@mui/joy/Skeleton'
import Typography from '@mui/joy/Typography'

import { useResponsiveAppMode } from '@/shared/configuration'
import { capitaliseFirstLetter } from '@/shared/utils/capitalise-first-letter'
import type { AgentReadResponse, LLMInfoListResponse } from '@/api/models'
import {
  useGetAllAgents,
  useGetAvailableLlmInfos,
  useGetUserProfile,
} from '@/api/services/api'
import { useChangeAgent } from '@/features/agent/hooks'
import { useAgentStore } from '@/features/agent/store'
import { AssistantAvatar } from '@/components/common/avatars/AssistantAvatar'
import { Icon } from '@/components/common/Icon'

export function AgentSelectionDropdown() {
  const { setAgentCreateModalOpen } = useAgentStore()
  const [agentSelectModalOpen, setAgentSelectModalOpen] = useState(false)
  const { isSmallScreen } = useResponsiveAppMode()
  const featureAgentCreationEnabled = useFeatureFlagEnabled('agent-creation')
  const { handleChangeAgent, isError } = useChangeAgent()
  const { data: user, isLoading: userIsLoading } = useGetUserProfile()
  const { data: agents, isLoading: agentsIsLoading } = useGetAllAgents()
  const { data: availableLlmInfos, isLoading: availableLlmInfosIsLoading } =
    useGetAvailableLlmInfos()

  const publicAgents = agents?.items?.filter((agent) => agent.isPublic)
  const privateAgents = agents?.items?.filter((agent) => !agent.isPublic)
  const activeAgent = agents?.items?.find(
    (agent) => agent.uuid === user?.defaultConversationSettings?.agentUuid,
  )
  const activeLlModel = availableLlmInfos?.items?.find(
    (llmInfo) => llmInfo.llmModelId === activeAgent?.llmModelId,
  )
  const isLoading =
    agentsIsLoading || userIsLoading || availableLlmInfosIsLoading

  return (
    <Dropdown>
      <MenuButton
        size="sm"
        onClick={() => setAgentSelectModalOpen(!agentSelectModalOpen)}
        variant="soft"
        endDecorator={
          isError ? <Icon name="regenerate" /> : <Icon name="downChevron" />
        }
        disabled={agentsIsLoading || userIsLoading}
        color={isError ? 'danger' : 'neutral'}
        startDecorator={
          <AssistantAvatar
            src={activeLlModel?.provider?.imageUrl ?? undefined}
            sx={{
              width: '18px',
              height: '18px',
              flexShrink: 0, // Prevent avatar shrinking
            }}
          />
        }
        sx={{ maxWidth: 1 }}
      >
        {isLoading ?
          <Skeleton variant="text" width={100} />
        : !isSmallScreen && (
            <Typography
              level="inherit"
              textColor="text.primary"
              sx={{
                flexGrow: 1,
                flexShrink: 1,
                minWidth: 0,
                maxWidth: '100%',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
              }}
            >
              {activeAgent?.name}
            </Typography>
          )
        }
      </MenuButton>
      <Menu
        placement="bottom-start"
        sx={{
          minHeight: 0,
          maxHeight: { xs: 'calc(100vh - 64px)', sm: 'calc(100vh - 72px)' },
          minWidth: 288,
          py: 0,
        }}
      >
        <List sx={{ overflowY: 'auto' }}>
          {isLoading ?
            Array.from({ length: 5 }).map((_) => (
              <ListItem key={crypto.randomUUID()} sticky>
                <ListItemDecorator>
                  <Skeleton variant="circular" width={40} height={40} />
                </ListItemDecorator>
                <ListItemContent>
                  <Skeleton variant="text" width={100} />
                  <Skeleton variant="text" width={200} />
                </ListItemContent>
              </ListItem>
            ))
          : <>
              {privateAgents?.length ?
                <>
                  <ListItem sticky sx={{ justifyContent: 'space-between' }}>
                    <Typography
                      level="body-xs"
                      textColor="text.secondary"
                      startDecorator={<Icon name="private" size={12} />}
                    >
                      Your Agents
                    </Typography>

                    {(
                      featureAgentCreationEnabled === true ||
                      featureAgentCreationEnabled === undefined
                    ) ?
                      <IconButton
                        size="sm"
                        onClick={() => setAgentCreateModalOpen({ open: true })}
                        variant="plain"
                      >
                        <Icon name="add" size={16} />
                      </IconButton>
                    : null}
                  </ListItem>
                  {privateAgents.map((agent) => (
                    <AgentListItem
                      key={agent.uuid}
                      agent={agent}
                      onClick={() => handleChangeAgent(agent.uuid)}
                      selectedUuid={activeAgent?.uuid}
                      availableLlmInfos={availableLlmInfos}
                      isOwner
                    />
                  ))}
                </>
              : null}

              <Divider />
              {publicAgents?.length ?
                <>
                  <ListItem sticky>
                    <Typography
                      level="body-xs"
                      textColor="text.secondary"
                      startDecorator={<Icon name="public" size={12} />}
                    >
                      Public Agents
                    </Typography>
                  </ListItem>
                  {publicAgents.map((agent) => (
                    <AgentListItem
                      key={agent.uuid}
                      agent={agent}
                      onClick={() => handleChangeAgent(agent.uuid)}
                      selectedUuid={activeAgent?.uuid}
                      availableLlmInfos={availableLlmInfos}
                    />
                  ))}
                </>
              : null}
            </>
          }
          <ListItem
            sticky
            sx={{
              bottom: 0,
              borderTop: (theme) => `1px solid ${theme.palette.divider}`,
            }}
          >
            <ListItemButton
              onClick={() => setAgentCreateModalOpen({ open: true })}
            >
              <Typography level="body-xs">Create a new agent</Typography>
              <ListItemDecorator>
                <Tooltip title="Create a new agent">
                  <Icon name="add" size={16} />
                </Tooltip>
              </ListItemDecorator>
            </ListItemButton>
          </ListItem>
        </List>
      </Menu>
    </Dropdown>
  )
}

function AgentListItem({
  agent,
  onClick,
  selectedUuid,
  availableLlmInfos,
  isOwner,
}: {
  agent?: AgentReadResponse
  onClick?: () => void
  selectedUuid?: string
  availableLlmInfos?: LLMInfoListResponse
  isOwner?: boolean
}) {
  const isSelected = selectedUuid === agent?.uuid
  const activeLlModel = availableLlmInfos?.items?.find(
    (llmInfo) => llmInfo.llmModelId === agent?.llmModelId,
  )
  return (
    <MenuItem onClick={onClick} selected={isSelected}>
      <ListItemDecorator>
        <AssistantAvatar
          src={activeLlModel?.provider?.imageUrl ?? undefined}
          size="sm"
        />
      </ListItemDecorator>
      <ListItemContent>
        <Typography level="body-xs" textColor="text.primary" noWrap>
          {agent?.name}
        </Typography>

        {agent?.ownerUsername && (
          <Typography level="body-xs" textColor="text.secondary" noWrap>
            Created by{' '}
            {isOwner ? 'You' : capitaliseFirstLetter(agent.ownerUsername)}
          </Typography>
        )}
      </ListItemContent>

      {isSelected ?
        <ListItemDecorator>
          <Icon name="checkCircle" size={16} color="primary" />
        </ListItemDecorator>
      : null}
    </MenuItem>
  )
}


--- Start of frontend/src/features/agent/components/AgentActionsMenu.tsx ---

import { useCallback, useState } from 'react'
import { useQueryClient } from '@tanstack/react-query'

import Button from '@mui/joy/Button'
import DialogActions from '@mui/joy/DialogActions'
import DialogTitle from '@mui/joy/DialogTitle'
import Divider from '@mui/joy/Divider'
import Dropdown from '@mui/joy/Dropdown'
import IconButton from '@mui/joy/IconButton'
import Menu from '@mui/joy/Menu'
import MenuButton from '@mui/joy/MenuButton'
import MenuItem from '@mui/joy/MenuItem'
import Typography from '@mui/joy/Typography'

import {
  getGetAllAgentsQueryKey,
  getGetUserProfileQueryKey,
  useCreateAgentFromExisting,
  useDeleteAgentByUuid,
  useGetAllAgents,
} from '@/api/services/api'
import { useChangeAgent } from '@/features/agent/hooks'
import { useAgentStore } from '@/features/agent/store'
import { useFeedbackStore } from '@/features/feedback/store'
import { Icon } from '@/components/common/Icon'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export function AgentActionsMenu({
  agentUuid,
  userUuid,
}: {
  agentUuid?: string
  userUuid?: string
}) {
  const queryClient = useQueryClient()
  const [openConfirmDelete, setOpenConfirmDelete] = useState(false)
  const { setFeedbackModalOpen } = useFeedbackStore()
  const { setAgentConfigurationSidePanelOpen } = useAgentStore()
  const { setAgentCreateModalOpen } = useAgentStore()
  const {
    mutate: duplicateAgent,
    isPending: duplicationIsPending,
    isError,
  } = useCreateAgentFromExisting()
  const { mutate: deleteAgentByUuid, isPending: deleteAgentIsPending } =
    useDeleteAgentByUuid()
  const { handleChangeAgent } = useChangeAgent()

  const { data: allAgents } = useGetAllAgents()

  const agent = allAgents?.items?.find((agent) => agent.uuid === agentUuid)
  const deleteIsDisabled =
    allAgents?.items?.length === 1 ||
    (agent?.isPublic && agent?.ownerUuid !== userUuid)

  const handleDeleteAgent = async () => {
    const anotherAgent = allAgents?.items.filter(
      (agent) => agent.uuid !== agentUuid,
    )[0]
    if (!agentUuid) {
      return
    }

    await deleteAgentByUuid(
      { agentUuid },
      {
        onSuccess() {
          queryClient.invalidateQueries({ queryKey: getGetAllAgentsQueryKey() })
          setAgentConfigurationSidePanelOpen({ open: false })
          if (anotherAgent) {
            handleChangeAgent(anotherAgent.uuid)
          }
        },
      },
    )
  }

  const handleOpenConfirmDelete = () => {
    setOpenConfirmDelete(true)
  }
  const handleCloseConfirmDelete = () => {
    setOpenConfirmDelete(false)
  }

  const handleCloneAgent = useCallback(() => {
    if (!agentUuid) {
      return
    }
    duplicateAgent(
      { agentUuid },
      {
        onSuccess(data) {
          queryClient.invalidateQueries({ queryKey: getGetAllAgentsQueryKey() })
          queryClient.invalidateQueries({
            queryKey: getGetUserProfileQueryKey(),
          })
          if (data?.uuid) {
            handleChangeAgent(data?.uuid)
          }
        },
      },
    )
  }, [agentUuid, duplicateAgent, queryClient, handleChangeAgent])

  return (
    <>
      <Dropdown>
        <MenuButton
          slots={{
            root: IconButton,
          }}
          slotProps={{
            root: {
              onClick: (e) => e.stopPropagation(),
              variant: 'plain',
              size: 'sm',
              loading: duplicationIsPending || deleteAgentIsPending,
            },
          }}
        >
          <Icon name="more" />
        </MenuButton>
        <Menu
          placement="bottom-end"
          sx={{
            zIndex: (theme) => theme.zIndex.modal + 1,
          }}
        >
          <MenuItem
            disabled={duplicationIsPending}
            onClick={handleCloneAgent}
            sx={{
              display: 'flex',
              gap: 4,
              justifyContent: 'space-between',
            }}
          >
            <Typography level="body-sm" textColor="text.primary">
              {isError ? 'Retry' : 'Duplicate'}
            </Typography>
            <Icon
              name="duplicate"
              size={16}
              color={isError ? 'danger' : 'secondary'}
            />
          </MenuItem>
          <MenuItem
            onClick={() => setAgentCreateModalOpen({ open: true })}
            sx={{
              display: 'flex',
              gap: 4,
              justifyContent: 'space-between',
            }}
          >
            <Typography level="body-sm" textColor="text.primary">
              Create new
            </Typography>
            <Icon name="add" size={16} />
          </MenuItem>

          <MenuItem
            onClick={() => setFeedbackModalOpen({ open: true, scope: 'agent' })}
            sx={{
              display: 'flex',
              gap: 4,
              justifyContent: 'space-between',
            }}
          >
            <Typography level="body-sm" textColor="text.primary">
              Feedback
            </Typography>
            <Icon name="thumbsUp" size={16} />
          </MenuItem>

          {!deleteIsDisabled && (
            <>
              <Divider />
              <MenuItem
                onClick={() => handleOpenConfirmDelete()}
                disabled={deleteAgentIsPending || deleteIsDisabled}
                sx={{
                  display: 'flex',
                  gap: 4,
                  justifyContent: 'space-between',
                }}
              >
                <Typography level="body-sm" textColor="text.primary">
                  Delete
                </Typography>
                <Icon name="delete" size={16} />
              </MenuItem>
            </>
          )}
        </Menu>
      </Dropdown>
      <AgentDeleteConfirmationDialog
        open={openConfirmDelete}
        onClose={handleCloseConfirmDelete}
        onConfirm={handleDeleteAgent}
        disabled={deleteIsDisabled}
        deleteAgentIsPending={deleteAgentIsPending}
      />
    </>
  )
}

function AgentDeleteConfirmationDialog({
  open,
  onClose,
  onConfirm,
  disabled,
  deleteAgentIsPending,
}: {
  open: boolean
  onClose: () => void
  onConfirm: () => void
  disabled?: boolean
  deleteAgentIsPending?: boolean
}) {
  return (
    <ModalDialogBase
      open={open}
      onClose={onClose}
      disablePortal={false}
      modalDialogProps={{
        maxWidth: 'sm',
      }}
    >
      <DialogTitle> Are you sure you want to delete this agent? </DialogTitle>
      <Divider />

      <DialogActions>
        <Button
          onClick={onConfirm}
          size="sm"
          disabled={disabled}
          endDecorator={<Icon name="delete" />}
          variant="outlined"
          color="danger"
          loading={deleteAgentIsPending}
        >
          Yes, delete
        </Button>
        <Button
          onClick={onClose}
          size="sm"
          disabled={disabled}
          variant="outlined"
          color="neutral"
        >
          No, cancel
        </Button>
      </DialogActions>
    </ModalDialogBase>
  )
}


--- Start of frontend/src/features/agent/components/AgentDuplicateButton.tsx ---

import { useCallback } from 'react'
import { useQueryClient } from '@tanstack/react-query'

import IconButton from '@mui/joy/IconButton'
import Tooltip from '@mui/joy/Tooltip'

import {
  getGetAllAgentsQueryKey,
  getGetUserProfileQueryKey,
  useCreateAgentFromExisting,
} from '@/api/services/api'
import { useChangeAgent } from '@/features/agent/hooks'
import { Icon } from '@/components/common/Icon'

export function AgentDuplicateButton({ agentUuid }: { agentUuid: string }) {
  const queryClient = useQueryClient()
  const { mutate, isPending, isError } = useCreateAgentFromExisting()
  const { handleChangeAgent } = useChangeAgent()

  const handleCloneAgent = useCallback(
    (e: React.MouseEvent<HTMLAnchorElement>) => {
      e.preventDefault()
      e.stopPropagation()

      mutate(
        { agentUuid },
        {
          onSuccess(data) {
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
            queryClient.invalidateQueries({
              queryKey: getGetUserProfileQueryKey(),
            })
            if (data?.uuid) {
              handleChangeAgent(data?.uuid)
            }
          },
        },
      )
    },
    [mutate, agentUuid, queryClient, handleChangeAgent],
  )

  return (
    <Tooltip title={isError ? 'Retry' : 'Duplicate agent'} arrow variant="soft">
      <IconButton
        size="sm"
        color={isError ? 'danger' : 'neutral'}
        loading={isPending}
        onClick={(e) => {
          handleCloneAgent(e)
        }}
      >
        <Icon name={isError ? 'regenerate' : 'duplicate'} />
      </IconButton>
    </Tooltip>
  )
}


--- Start of frontend/src/features/agent/components/AgentConfigTools.tsx ---

import { useCallback } from 'react'
import { Controller, useFormContext } from 'react-hook-form'
import { useQueryClient } from '@tanstack/react-query'
import debounce from 'lodash.debounce'

import Box from '@mui/joy/Box'
import Checkbox from '@mui/joy/Checkbox'
import Chip from '@mui/joy/Chip'
import FormControl from '@mui/joy/FormControl'
import FormHelperText from '@mui/joy/FormHelperText'
import FormLabel from '@mui/joy/FormLabel'
import Input from '@mui/joy/Input'
import Option from '@mui/joy/Option'
import Select from '@mui/joy/Select'
import Skeleton from '@mui/joy/Skeleton'
import Switch from '@mui/joy/Switch'

import { capitaliseFirstLetter } from '@/shared/utils/capitalise-first-letter'
import type { ToolReadResponse } from '@/api/models'
import {
  getGetAgentByUuidQueryKey,
  getGetAllAgentsQueryKey,
  getGetAllToolsQueryKey,
  useCreateAgentConfigFromExisting,
  useGetAllTools,
} from '@/api/services/api'
import { ErrorMessage } from '@/components/common'

interface ToolReadResponseOptionsSchema {
  properties: {
    [key: string]: {
      default: any
      enum?: string[]
      title?: string
      description?: string
      type: string
      minimum?: number
      maximum?: number
      exclusiveMinimum?: number
      exclusiveMaximum?: number
    }
  }
  type: string
  title?: string
  additionalProperties: boolean
}

interface ToolOption {
  registryId: string
  options: Record<string, any>
}

export function AgentConfigTools({
  agentUuid,
  agentConfigUuid,
  enableReadOnly = false,
}: {
  agentUuid?: string
  agentConfigUuid?: string
  enableReadOnly?: boolean
}) {
  const queryClient = useQueryClient()
  const {
    data: tools,
    isLoading: allToolsIsLoading,
    isError: allToolsIsError,
    error: allToolsError,
  } = useGetAllTools()
  const { control, watch, setValue } = useFormContext()
  const selectedTools = watch('tools') || []

  const {
    mutate: updateAgentConfig,
    isError: updateAgentConfigIsError,
    error: updateAgentConfigError,
  } = useCreateAgentConfigFromExisting()

  const debouncedUpdate = useCallback(
    debounce((updatedTools: ToolOption[]) => {
      if (!agentUuid || !agentConfigUuid) {
        return
      }
      updateAgentConfig(
        {
          agentUuid,
          agentConfigUuid,
          data: {
            isActive: true,
            tools: updatedTools.filter(Boolean),
          },
        },
        {
          onSuccess() {
            queryClient.invalidateQueries({
              queryKey: getGetAgentByUuidQueryKey(agentUuid),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllToolsQueryKey(),
            })
          },
          onError() {},
        },
      )
    }, 300),
    [agentUuid, agentConfigUuid],
  )

  return (
    <FormControl role="group" aria-labelledby="tools" size="sm">
      <FormLabel id="tools">Tools</FormLabel>
      {allToolsIsLoading ?
        <Skeleton variant="text" />
      : allToolsIsError ?
        <ErrorMessage error={allToolsError} />
      : <Box display="flex" flexDirection="column" gap={3}>
          {updateAgentConfigIsError && (
            <ErrorMessage error={updateAgentConfigError} />
          )}
          {tools?.items?.map((tool) => (
            <ToolSelection
              key={tool.toolRegistryId}
              tool={tool}
              selectedTools={selectedTools}
              control={control}
              setValue={setValue}
              onUpdate={debouncedUpdate}
              disabled={enableReadOnly}
            />
          ))}
        </Box>
      }
    </FormControl>
  )
}

function ToolSelection({
  tool,
  selectedTools,
  control,
  setValue,
  onUpdate,
  disabled,
}: {
  tool: ToolReadResponse
  selectedTools: ToolOption[]
  control: any
  setValue: any
  onUpdate: (tools: ToolOption[]) => void
  disabled?: boolean
}) {
  const isSelected = selectedTools.some(
    (t) => t.registryId === tool?.toolRegistryId,
  )

  const handleToolSelect = (checked: boolean) => {
    const updatedTools =
      checked ?
        [
          ...selectedTools,
          {
            registryId: tool?.toolRegistryId,
            options: initializeOptions(
              tool?.optionsSchema?.properties || ({} as any),
            ),
          },
        ]
      : selectedTools?.filter((t) => t.registryId !== tool.toolRegistryId)

    setValue('tools', updatedTools, {
      shouldDirty: true,
      shouldValidate: true,
    })
    onUpdate(updatedTools)
  }

  return (
    <FormControl size="sm">
      <Controller
        control={control}
        name="tools"
        render={() => (
          <Checkbox
            size="sm"
            label={tool.name}
            checked={isSelected}
            disabled={disabled}
            onChange={(e) => handleToolSelect(e.target.checked)}
          />
        )}
      />
      <FormHelperText>{tool.description}</FormHelperText>

      {isSelected && tool.optionsSchema && (
        <ToolOptions
          toolId={tool.toolRegistryId}
          options={
            tool.optionsSchema
              .properties as ToolReadResponseOptionsSchema['properties']
          }
          control={control}
          selectedTools={selectedTools}
          onUpdate={onUpdate}
          disabled={disabled}
        />
      )}
    </FormControl>
  )
}

function ToolOptions({
  toolId,
  options,
  control,
  selectedTools,
  onUpdate,
  disabled,
}: {
  toolId: string
  options: ToolReadResponseOptionsSchema['properties']
  control: any
  selectedTools: ToolOption[]
  onUpdate: (tools: ToolOption[]) => void
  disabled?: boolean
}) {
  const toolIndex = selectedTools.findIndex((t) => t.registryId === toolId)

  const handleOptionChange = (key: string, value: any) => {
    const updatedTools = selectedTools?.map((tool, index) => {
      if (index === toolIndex) {
        return {
          ...tool,
          options: {
            ...tool.options,
            [key]: value,
          },
        }
      }
      return tool
    })
    onUpdate(updatedTools)
  }

  return (
    <FormControl sx={{ ml: 3, mt: 1 }} size="sm">
      {Object.entries(options)?.map(([objKey, value]) => {
        const optionLabel = value.title || capitaliseFirstLetter(objKey)
        return (
          <ToolOptionsInputMapping
            key={objKey}
            objKey={objKey}
            value={value}
            optionLabel={optionLabel}
            control={control}
            toolIndex={toolIndex}
            disabled={disabled}
            handleOptionChange={handleOptionChange}
          />
        )
      })}
    </FormControl>
  )
}

function ToolOptionsInputMapping({
  objKey,
  value,
  optionLabel,
  control,
  toolIndex,
  disabled,
  handleOptionChange,
}: {
  objKey: string
  value: ToolReadResponseOptionsSchema['properties'][string]
  optionLabel: string
  control: any
  toolIndex: number
  disabled?: boolean
  handleOptionChange: (objKey: string, value: any) => void
}) {
  if (value.type === 'integer' || value.type === 'number') {
    return (
      <FormControl size="sm">
        <FormLabel>{optionLabel}</FormLabel>
        <Controller
          control={control}
          name={`tools.${toolIndex}.options.${objKey}`}
          defaultValue={value.default}
          render={({ field }) => (
            <Input
              type="number"
              value={field.value}
              variant="plain"
              onChange={(e) => {
                const numValue = Number.parseFloat(e.target.value)
                field.onChange(numValue)
                handleOptionChange(objKey, numValue)
              }}
              disabled={disabled}
              slotProps={{
                input: {
                  min:
                    value.minimum || value.exclusiveMinimum ?
                      value.exclusiveMinimum !== undefined ?
                        value.exclusiveMinimum + 1
                      : value.minimum
                    : undefined,
                  max:
                    value.maximum || value.exclusiveMaximum ?
                      (value?.exclusiveMaximum ?? 0 - 1)
                    : undefined,
                },
              }}
            />
          )}
        />
        {value?.description && (
          <FormHelperText>{value?.description}</FormHelperText>
        )}
      </FormControl>
    )
  }

  // Handle boolean input (as Switch)
  if (value.type === 'boolean') {
    return (
      <FormControl
        size="sm"
        sx={{ alignItems: 'start' }}
        orientation="horizontal"
      >
        <FormLabel>{optionLabel}</FormLabel>
        <Controller
          control={control}
          name={`tools.${toolIndex}.options.${objKey}`}
          defaultValue={value.default}
          render={({ field }) => (
            <Switch
              checked={!!field.value}
              onChange={(e) => {
                field.onChange(e.target.checked)
                handleOptionChange(objKey, e.target.checked)
              }}
              disabled={disabled}
            />
          )}
        />
        {value?.description && (
          <FormHelperText>{value?.description}</FormHelperText>
        )}
      </FormControl>
    )
  }

  if (value.enum && Array.isArray(value.enum)) {
    return (
      <FormControl size="sm">
        <FormLabel>{optionLabel}</FormLabel>
        <Controller
          control={control}
          name={`tools.${toolIndex}.options.${objKey}`}
          defaultValue={value.default}
          render={({ field }) => (
            <Select
              variant="plain"
              renderValue={(selected) => (
                <Chip variant="outlined" color="primary">
                  {selected?.value && capitaliseFirstLetter(selected.value)}
                </Chip>
              )}
              value={field.value}
              onChange={(_e, newValue) => {
                field.onChange(newValue)
                handleOptionChange(objKey, newValue)
              }}
              disabled={disabled}
            >
              {value?.enum?.map((option) => (
                <Option key={option} value={option}>
                  {capitaliseFirstLetter(option)}
                </Option>
              ))}
            </Select>
          )}
        />
        {value?.description && (
          <FormHelperText>{value?.description}</FormHelperText>
        )}
      </FormControl>
    )
  }

  // Default to string input for all other types
  return (
    <FormControl size="sm">
      <FormLabel>{optionLabel}</FormLabel>
      <Controller
        control={control}
        name={`tools.${toolIndex}.options.${objKey}`}
        defaultValue={value.default || ''}
        render={({ field }) => (
          <Input
            value={field.value}
            onChange={(e) => {
              field.onChange(e.target.value)
              handleOptionChange(objKey, e.target.value)
            }}
            disabled={disabled}
          />
        )}
      />
      {value?.description && (
        <FormHelperText>{value?.description}</FormHelperText>
      )}
    </FormControl>
  )
}

function initializeOptions(
  properties: ToolReadResponseOptionsSchema['properties'],
) {
  return Object.entries(properties).reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]: value.default,
    }),
    {},
  )
}


--- Start of frontend/src/features/agent/components/AgentDeleteButton.tsx ---

import { useState } from 'react'
import { useQueryClient } from '@tanstack/react-query'

import Button from '@mui/joy/Button'
import DialogActions from '@mui/joy/DialogActions'
import DialogTitle from '@mui/joy/DialogTitle'
import IconButton from '@mui/joy/IconButton'
import Tooltip from '@mui/joy/Tooltip'
import Typography from '@mui/joy/Typography'

import {
  getGetAllAgentsQueryKey,
  useDeleteAgentByUuid,
  useGetAllAgents,
} from '@/api/services/api'
import { useChangeAgent } from '@/features/agent/hooks'
import { useAgentStore } from '@/features/agent/store'
import { Icon } from '@/components/common'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export function AgentDeleteButton({
  as = 'button',
  agentUuid,
  userUuid,
}: {
  as?: 'iconButton' | 'button'
  agentUuid?: string
  userUuid?: string
}) {
  const queryClient = useQueryClient()
  const [openConfirmDelete, setOpenConfirmDelete] = useState(false)
  const { setAgentConfigurationSidePanelOpen } = useAgentStore()

  const { handleChangeAgent } = useChangeAgent()
  const { mutate: deleteAgentByUuid, isPending: deleteAgentIsPending } =
    useDeleteAgentByUuid()
  const { data: allAgents } = useGetAllAgents()

  const agent = allAgents?.items?.find((agent) => agent.uuid === agentUuid)
  const deleteIsDisabled =
    allAgents?.items?.length === 1 ||
    (agent?.isPublic && agent?.ownerUuid !== userUuid)

  const handleDeleteAgent = async () => {
    const anotherAgent = allAgents?.items.filter(
      (agent) => agent.uuid !== agentUuid,
    )[0]
    if (!agentUuid) {
      return
    }

    await deleteAgentByUuid(
      { agentUuid },
      {
        onSuccess() {
          queryClient.invalidateQueries({ queryKey: getGetAllAgentsQueryKey() })
          setAgentConfigurationSidePanelOpen({ open: false })
          if (anotherAgent) {
            handleChangeAgent(anotherAgent.uuid)
          }
        },
      },
    )
  }

  const handleOpenConfirmDelete = (e: React.MouseEvent<HTMLAnchorElement>) => {
    e.preventDefault()
    e.stopPropagation()
    setOpenConfirmDelete(true)
  }
  const handleCloseConfirmDelete = () => {
    setOpenConfirmDelete(false)
  }

  return (
    <>
      {as === 'iconButton' ?
        <Tooltip title="Delete agent" arrow variant="soft">
          <IconButton
            loading={deleteAgentIsPending}
            onClick={(e) => {
              handleOpenConfirmDelete(e)
            }}
            size="sm"
            disabled={deleteAgentIsPending}
          >
            <Icon name="delete" />
          </IconButton>
        </Tooltip>
      : <Button
          loading={deleteAgentIsPending}
          onClick={(e) => {
            handleOpenConfirmDelete(e)
          }}
          size="sm"
          disabled={deleteAgentIsPending || deleteIsDisabled}
          endDecorator={<Icon name="delete" />}
          variant="outlined"
          color="neutral"
        >
          <Typography level="inherit" noWrap textColor="text.primary">
            Delete Agent
          </Typography>
        </Button>
      }
      <ModalDialogBase
        open={openConfirmDelete}
        onClose={handleCloseConfirmDelete}
        disablePortal={false}
        modalDialogProps={{
          maxWidth: 'sm',
        }}
      >
        <DialogTitle> Are you sure you want to delete this agent? </DialogTitle>

        <DialogActions>
          <Button
            onClick={handleDeleteAgent}
            size="sm"
            disabled={deleteAgentIsPending}
            endDecorator={<Icon name="delete" />}
            variant="outlined"
            color="danger"
            loading={deleteAgentIsPending}
          >
            Yes, delete
          </Button>
          <Button
            onClick={handleCloseConfirmDelete}
            size="sm"
            disabled={deleteAgentIsPending}
            variant="outlined"
            color="neutral"
          >
            No, cancel
          </Button>
        </DialogActions>
      </ModalDialogBase>
    </>
  )
}


--- Start of frontend/src/features/agent/components/AgentTabPanels.tsx ---

import TabPanel from '@mui/joy/TabPanel'

import { useResponsiveAppMode } from '@/shared/configuration'
import type { AgentReadResponse } from '@/api/models'
import { AgentAssetsForm } from '@/features/agent/components/AgentAssetsForm'
import { AgentConfigForm } from '@/features/agent/components/AgentConfigForm'
import { AgentGeneralForm } from '@/features/agent/components/AgentGeneralForm'
import { AgentHistory } from '@/features/agent/components/AgentHistory'

export function AgentTabPanels({
  activeAgentData,
  enableReadOnly,
}: {
  activeAgentData?: AgentReadResponse
  enableReadOnly: boolean
}) {
  const { isSmallScreen } = useResponsiveAppMode()
  if (!activeAgentData) {
    return null
  }
  const agentConfig = activeAgentData?.agentConfigs?.find(
    (config) => config?.status === 'active',
  )
  return (
    <>
      <TabPanel value={0} sx={{ px: isSmallScreen ? 0 : 2, py: 2 }}>
        <AgentGeneralForm
          enableReadOnly={enableReadOnly}
          agentUuid={activeAgentData?.uuid}
          activeAgentData={activeAgentData}
        />
      </TabPanel>
      <TabPanel value={1} sx={{ px: isSmallScreen ? 0 : 2, py: 2 }}>
        <AgentConfigForm
          enableReadOnly={enableReadOnly}
          agentConfigUuid={agentConfig?.uuid}
          agentUuid={activeAgentData?.uuid}
          activeConfig={agentConfig}
        />
      </TabPanel>
      <TabPanel value={2} sx={{ px: isSmallScreen ? 0 : 2, py: 2 }}>
        <AgentAssetsForm
          enableReadOnly={enableReadOnly}
          activeAgentData={activeAgentData}
        />
      </TabPanel>
      <TabPanel value={3} sx={{ px: isSmallScreen ? 0 : 2, py: 2 }}>
        <AgentHistory
          activeAgentData={activeAgentData}
          enableReadOnly={enableReadOnly}
        />
      </TabPanel>
    </>
  )
}


--- Start of frontend/src/features/agent/components/AgentTitle.tsx ---

import Box from '@mui/joy/Box'
import Divider from '@mui/joy/Divider'
import Typography from '@mui/joy/Typography'

import { capitaliseFirstLetter } from '@/shared/utils/capitalise-first-letter'
import type { AgentConfigReadResponse, AgentReadResponse } from '@/api/models'
import { Icon } from '@/components/common/Icon'

export function AgentTitle({
  agentName,
  ownerUsername,
  isPublic,
  version,
}: {
  agentName?: string
  ownerUsername: AgentReadResponse['ownerUsername']
  isPublic?: boolean
  version?: AgentConfigReadResponse['version']
}) {
  return (
    <Box
      overflow="hidden"
      textOverflow="ellipsis"
      whiteSpace="nowrap"
      display="flex"
      flexDirection="column"
      gap={0.5}
    >
      <Typography
        level="title-lg"
        textColor="text.primary"
        noWrap
        maxWidth="100%"
      >
        {agentName}
      </Typography>
      <Box display="flex" gap={1} alignItems="center">
        <Typography
          level="body-xs"
          textColor="text.secondary"
          noWrap
          maxWidth="100%"
          endDecorator={
            <Icon name={isPublic ? 'public' : 'private'} size={12} />
          }
        >
          {isPublic ? 'Public' : 'Private'}
        </Typography>
        <Divider orientation="vertical" />
        <Typography
          level="body-xs"
          textColor="text.secondary"
          noWrap
          maxWidth="100%"
        >
          v{version}
        </Typography>
        <Divider orientation="vertical" />
        {ownerUsername && (
          <Typography
            level="body-xs"
            textColor="text.secondary"
            noWrap
            maxWidth="100%"
          >
            Created by {capitaliseFirstLetter(ownerUsername)}
          </Typography>
        )}
      </Box>
    </Box>
  )
}


--- Start of frontend/src/features/agent/components/AgentTabList.tsx ---

import Box from '@mui/joy/Box'
import Tab, { tabClasses } from '@mui/joy/Tab'
import TabList from '@mui/joy/TabList'
import Typography from '@mui/joy/Typography'

import { Icon } from '@/components/common'
import type { IconName } from '@/components/common/Icon'

interface TabsI {
  key: string
  label: string
  icon: IconName
}
const TABS: TabsI[] = [
  {
    key: 'general',
    label: 'General',
    icon: 'settings',
  },
  {
    key: 'config',
    label: 'Configuration',
    icon: 'config',
  },
  {
    key: 'knowledge',
    label: 'Knowledge',
    icon: 'assetUpload',
  },
  {
    key: 'history',
    label: 'History',
    icon: 'history',
  },
]

export function AgentTabList() {
  return (
    <TabList
      key="tablist"
      variant="plain"
      size="sm"
      sticky="top"
      sx={{
        position: 'sticky',
        top: 0,
        [`&& .${tabClasses.root}`]: {
          bgcolor: 'transparent',
          '&:hover': { bgcolor: 'transparent' },
          [`&.${tabClasses.selected}`]: { bgcolor: 'transparent' },
        },
      }}
    >
      {TABS.map((tab, index) => (
        <Tab key={tab.key} value={index}>
          <Box flexShrink={0} display="flex" alignItems="center">
            <Icon name={tab.icon} />
          </Box>
          <Typography level="inherit" textColor="text.primary" noWrap>
            {tab.label}
          </Typography>
        </Tab>
      ))}
    </TabList>
  )
}


--- Start of frontend/src/features/agent/components/AgentInitialMessage.tsx ---

import { useEffect, useState } from 'react'

import type {
  AgentReadResponse,
  AgentStockResponsesInitialMessage,
  LLMInfoResponse,
} from '@/api/models'
import { ConversationMessage } from '@/features/conversation/components/conversation-message/ConversationMessage'
import { ConversationMessagesListWrapper } from '@/features/conversation/components/conversation-message/ConversationMessageList'

export function AgentInitialMessage({
  initialMessage,
  llmInfo,
  activeAgent,
  currentAgentConfig,
}: {
  initialMessage?: AgentStockResponsesInitialMessage
  llmInfo?: LLMInfoResponse
  activeAgent?: AgentReadResponse
  currentAgentConfig?: AgentReadResponse['agentConfigs'][0]
}) {
  const [currentText, setCurrentText] = useState('')
  const [currentIndex, setCurrentIndex] = useState(0)

  useEffect(() => {
    if (!initialMessage) {
      return
    }

    // Reset the text and index when `initialMessage` or `currentAgentConfig` changes
    setCurrentText('')
    setCurrentIndex(0)
  }, [initialMessage, currentAgentConfig])

  useEffect(() => {
    if (!initialMessage || typeof initialMessage !== 'string') {
      return
    }

    const chunkSize = 5 // Number of characters to append at once
    const delay = 10 // Delay in milliseconds

    if (currentIndex < initialMessage.length) {
      const timeout = setTimeout(() => {
        setCurrentText(
          (prevText) =>
            prevText +
            initialMessage.slice(currentIndex, currentIndex + chunkSize),
        )
        setCurrentIndex((prevIndex) => prevIndex + chunkSize)
      }, delay)

      return () => {
        clearTimeout(timeout)
      }
    }
  }, [currentIndex, initialMessage, currentAgentConfig])

  return (
    <ConversationMessagesListWrapper>
      <ConversationMessage
        toolsEnabled={false}
        isLastMessage
        modelImageUrl={llmInfo?.provider?.imageUrl ?? undefined}
        message={{
          llmModelId: activeAgent?.llmModelId,
          authorName: currentAgentConfig?.name ?? activeAgent?.name ?? '-',
          content: currentText,
          role: 'assistant',
          createdAt: new Date().toISOString(),
          uuid: crypto.randomUUID(),
          conversationUuid: '',
          status: 'completed',
          totalCostUsd: 0,
          type: 'text',
        }}
      />
    </ConversationMessagesListWrapper>
  )
}


--- Start of frontend/src/features/agent/components/AgentConfigTextarea.tsx ---

import { useFormContext, type RegisterOptions } from 'react-hook-form'

import Box from '@mui/joy/Box'
import FormControl from '@mui/joy/FormControl'
import FormHelperText from '@mui/joy/FormHelperText'
import FormLabel from '@mui/joy/FormLabel'
import Textarea from '@mui/joy/Textarea'
import Tooltip from '@mui/joy/Tooltip'

import type { HTTPValidationError } from '@/api/models'
import type { ErrorType } from '@/api/mutator/custom-instance'
import type { AgentConfigFormFields } from '@/features/agent/components/AgentConfigForm'
import { Icon } from '@/components/common'

export function AgentConfigTextarea({
  name,
  label,
  helperText,
  placeholder,
  options,
  enableReadOnly,
  isError,
  error,
}: {
  name: keyof AgentConfigFormFields
  label: string
  helperText: string
  placeholder?: string
  options?: RegisterOptions<AgentConfigFormFields, keyof AgentConfigFormFields>
  enableReadOnly?: boolean
  isError?: boolean
  error?: ErrorType<HTTPValidationError> | null
}) {
  const {
    register,
    formState: { errors },
  } = useFormContext<AgentConfigFormFields>()
  return (
    <FormControl key={name} size="sm">
      <FormLabel sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
        {label}
        <Tooltip
          title={helperText}
          arrow
          variant="soft"
          placement="top"
          sx={{ maxWidth: 200 }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
            <Icon name="info" size={16} />
          </Box>
        </Tooltip>
      </FormLabel>
      <Textarea
        error={Boolean(errors[name]) || isError}
        size="sm"
        disabled={enableReadOnly}
        {...register(name, options)}
        variant="plain"
        minRows={3}
        placeholder={placeholder}
      />
      <FormHelperText color={errors[name] || isError ? 'danger' : 'neutral'}>
        {errors[name]?.message ?? error?.message}
      </FormHelperText>
    </FormControl>
  )
}


--- Start of frontend/src/features/agent/components/AgentConfiguration.tsx ---

import { useState } from 'react'

import Box from '@mui/joy/Box'
import Skeleton from '@mui/joy/Skeleton'
import Tabs from '@mui/joy/Tabs'

import { useResponsiveAppMode } from '@/shared/configuration'
import type { AgentReadResponse } from '@/api/models'
import { useGetAgentByUuid, useGetUserProfile } from '@/api/services/api'
import {
  AgentModal,
  AgentModalHeader,
} from '@/features/agent/components/AgentModal'
import {
  AgentSidePanel,
  AgentSidePanelHeader,
} from '@/features/agent/components/AgentSidePanel'
import { AgentTabList } from '@/features/agent/components/AgentTabList'
import { AgentTabPanels } from '@/features/agent/components/AgentTabPanels'
import { ErrorMessage } from '@/components/common'

export function AgentConfiguration() {
  const { isSmallScreen } = useResponsiveAppMode()
  const {
    data: user,
    isLoading: userIsLoading,
    isError: userIsError,
    error: userError,
  } = useGetUserProfile()
  const activeAgentUuid = user?.defaultConversationSettings?.agentUuid as string
  const {
    data: activeAgentData,
    isLoading: activeAgentIsLoading,
    isError: activeAgentIsError,
    error: activeAgentError,
  } = useGetAgentByUuid(activeAgentUuid, {
    query: {
      enabled: !!activeAgentUuid,
    },
  })

  const enableReadOnly = user?.uuid !== activeAgentData?.ownerUuid
  const isLoading = activeAgentIsLoading || userIsLoading
  const isError = activeAgentIsError || userIsError
  const error = activeAgentError || userError

  if (isSmallScreen) {
    return (
      <AgentModal>
        <AgentModalHeader
          agentName={activeAgentData?.name}
          agentUuid={activeAgentData?.uuid}
          isPublic={activeAgentData?.isPublic}
          ownerUsername={activeAgentData?.ownerUsername}
          userUuid={user?.uuid}
          isLoading={isLoading}
          version={activeAgentData?.activeConfig?.version}
        />
        <AgentConfigurationBase
          activeAgentData={activeAgentData}
          enableReadOnly={enableReadOnly}
          isLoading={isLoading}
          isError={isError}
          error={error}
        />
      </AgentModal>
    )
  }

  return (
    <AgentSidePanel>
      <AgentSidePanelHeader
        agentUuid={activeAgentData?.uuid}
        userUuid={user?.uuid}
        isLoading={isLoading}
        activeAgentData={activeAgentData}
      />
      <AgentConfigurationBase
        activeAgentData={activeAgentData}
        enableReadOnly={enableReadOnly}
        isLoading={isLoading}
        isError={isError}
        error={error}
      />
    </AgentSidePanel>
  )
}

export function AgentConfigurationBase({
  activeAgentData,
  enableReadOnly,
  isLoading,
  isError,
  error,
}: {
  activeAgentData?: AgentReadResponse
  enableReadOnly: boolean
  isLoading: boolean
  isError: boolean
  error: unknown
}) {
  const [activeTab, setActiveTab] = useState(0)
  return (
    <Tabs
      variant="plain"
      aria-label="Agent configuration tabs"
      defaultValue={0}
      onChange={(_event, newValue) => setActiveTab(newValue as number)}
      value={activeTab}
      size="sm"
      sx={{
        backgroundColor: 'background.body',
        overflow: 'auto',
        height: '100%',
      }}
      slotProps={{
        root: {
          style: {
            height: '100%',
          },
        },
      }}
    >
      <AgentTabList />

      {isLoading ?
        <Box p={2}>
          <Skeleton variant="text" />
        </Box>
      : isError ?
        <Box p={2}>
          <ErrorMessage error={error} />
        </Box>
      : <AgentTabPanels
          activeAgentData={activeAgentData}
          enableReadOnly={enableReadOnly}
        />
      }
    </Tabs>
  )
}


--- Start of frontend/src/features/agent/components/AgentHistory.tsx ---

import { useMemo } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { formatDistanceToNow } from 'date-fns'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Chip from '@mui/joy/Chip'
import List from '@mui/joy/List'
import ListItem from '@mui/joy/ListItem'
import Typography from '@mui/joy/Typography'

import type { AgentConfigReadResponse, AgentReadResponse } from '@/api/models'
import {
  getGetAgentByUuidQueryKey,
  getGetAllAgentsQueryKey,
  getGetAllToolsQueryKey,
  useCreateAgentConfigFromExisting,
} from '@/api/services/api'
import { Icon } from '@/components/common'

export function AgentHistory({
  activeAgentData,
  enableReadOnly,
}: {
  activeAgentData?: AgentReadResponse
  enableReadOnly?: boolean
}) {
  const sortedAgentConfigs = useMemo(() => {
    return activeAgentData?.agentConfigs?.sort((a, b) => {
      if (!a.createdAt || !b.createdAt) {
        return 0
      }
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    })
  }, [activeAgentData])

  return (
    <List>
      {sortedAgentConfigs?.map((config) => {
        if (config?.uuid == null) {
          return null
        }
        return (
          <AgentHistoryItem
            key={config.uuid}
            config={config}
            activeAgentData={activeAgentData}
            enableReadOnly={enableReadOnly}
          />
        )
      })}
    </List>
  )
}

function AgentHistoryItem({
  config,
  activeAgentData,
  enableReadOnly,
}: {
  config: AgentConfigReadResponse
  activeAgentData?: AgentReadResponse
  enableReadOnly?: boolean
}) {
  const queryClient = useQueryClient()
  const {
    mutate: createAgentConfigFromTemplate,
    isError: createAgentConfigIsError,
    isPending: createAgentConfigIsPending,
  } = useCreateAgentConfigFromExisting()

  const handleRestore = async (agentConfigUuid: string) => {
    if (activeAgentData?.uuid) {
      await createAgentConfigFromTemplate(
        {
          agentConfigUuid,
          agentUuid: activeAgentData.uuid,
          data: {
            isActive: true,
          },
        },
        {
          onSuccess: () => {
            queryClient.invalidateQueries({
              queryKey: getGetAgentByUuidQueryKey(activeAgentData?.uuid),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllToolsQueryKey(),
            })
          },
        },
      )
    }
  }

  if (config?.uuid == null) {
    return null
  }
  return (
    <ListItem
      key={config.uuid}
      sx={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        gap: 1,
      }}
    >
      <Box flex={1} display="flex" alignItems="center">
        <Typography level="body-xs" noWrap>
          v{config.version}
        </Typography>
      </Box>

      <Box flex={1} display="flex" alignItems="center">
        <Chip
          color={
            config.status === 'active' ? 'success'
            : config.status === 'inactive' ?
              'neutral'
            : 'danger'
          }
          size="sm"
        >
          {config.status}
        </Chip>
      </Box>
      {config?.createdAt && (
        <Typography flex={1} noWrap level="body-xs">
          {formatDistanceToNow(new Date(config.createdAt), { addSuffix: true })}
        </Typography>
      )}
      <Box
        flex={1}
        display="flex"
        justifyContent="flex-end"
        gap={1}
        alignItems="center"
      >
        <Button
          variant="soft"
          size="sm"
          color={createAgentConfigIsError ? 'danger' : 'neutral'}
          loading={createAgentConfigIsPending}
          disabled={config.status === 'active' || enableReadOnly}
          onClick={() => handleRestore(config?.uuid as string)}
          endDecorator={
            createAgentConfigIsError ? <Icon name="regenerate" /> : null
          }
        >
          Restore
        </Button>
      </Box>
    </ListItem>
  )
}


--- Start of frontend/src/features/agent/components/AgentSidePanel.tsx ---

import type { ReactNode } from 'react'
import { Panel } from 'react-resizable-panels'

import { Skeleton } from '@mui/joy'
import Box from '@mui/joy/Box'
import IconButton from '@mui/joy/IconButton'
import { useTheme } from '@mui/joy/styles'

import type { AgentReadResponse } from '@/api/models'
import { AgentActionsMenu } from '@/features/agent/components/AgentActionsMenu'
import { AgentTitle } from '@/features/agent/components/AgentTitle'
import { useAgentStore } from '@/features/agent/store'
import { Icon } from '@/components/common/Icon'

export function AgentSidePanel({ children }: { children: ReactNode }) {
  const { setAgentConfigurationSidePanelOpen } = useAgentStore()
  const theme = useTheme()

  return (
    <Panel
      id="agent-side-panel"
      order={2}
      defaultSize={40}
      collapsible
      onCollapse={() => setAgentConfigurationSidePanelOpen({ open: false })}
      collapsedSize={0}
      minSize={20}
      style={{
        backgroundColor: theme.palette.background.body,
        display: 'flex',
        flexDirection: 'column',
        minWidth: theme.spacing(30),
        overflow: 'hidden',
        height: '100%',
      }}
    >
      {children}
    </Panel>
  )
}

export function AgentSidePanelHeader({
  activeAgentData,
  agentUuid,
  userUuid,
  isLoading,
}: {
  activeAgentData?: AgentReadResponse
  agentUuid?: string
  userUuid?: string
  isLoading?: boolean
}) {
  const { setAgentConfigurationSidePanelOpen } = useAgentStore()

  return (
    <Box
      sx={{
        py: 2,
        justifyContent: 'space-between',
        display: 'flex',
        alignItems: 'center',
        width: '100%',
        px: 2,
        gap: 1,
        position: 'sticky',
        top: 0,
      }}
    >
      {isLoading ?
        <Skeleton variant="text" width={100} />
      : <AgentTitle
          agentName={activeAgentData?.name}
          isPublic={activeAgentData?.isPublic}
          ownerUsername={activeAgentData?.ownerUsername}
          version={activeAgentData?.activeConfig?.version}
        />
      }

      <Box
        display="flex"
        gap={1}
        alignItems="center"
        justifyContent="flex-end"
        flex={1}
      >
        <AgentActionsMenu agentUuid={agentUuid} userUuid={userUuid} />
        <IconButton
          onClick={() => setAgentConfigurationSidePanelOpen({ open: false })}
          size="sm"
        >
          <Icon name="close" />
        </IconButton>
      </Box>
    </Box>
  )
}


--- Start of frontend/src/features/agent/components/AgentAssetsForm.tsx ---

import { useCallback } from 'react'
import { useQueryClient } from '@tanstack/react-query'

import Box from '@mui/joy/Box'

import type { AgentReadResponse } from '@/api/models'
import {
  getGetAgentByUuidQueryKey,
  getGetAllAgentsQueryKey,
  useCreateAssets,
  useUpdateAgentByUuid,
} from '@/api/services/api'
import { ErrorMessage } from '@/components/common'
import { AssetList } from '@/components/common/assets/AssetList'
import { DropzoneInput } from '@/components/interactive/DropzoneInput'

export interface AgentAssetsFormFields {
  assetUuids?: string[]
}

export function AgentAssetsForm({
  activeAgentData,
  enableReadOnly,
}: {
  activeAgentData?: AgentReadResponse
  enableReadOnly: boolean
}) {
  const queryClient = useQueryClient()
  const {
    mutateAsync,
    isPending: createAssetsIsLoading,
    isError: createAssetsIsError,
    error: createAssetsError,
    data: createAssetsData,
  } = useCreateAssets()
  const {
    mutate: updateAgent,
    isPending: updateAgentIsPending,
    isError: updateAgentIsError,
    error: updateAgentError,
  } = useUpdateAgentByUuid()

  const handleUploadAssetsAndLinkToAgent = useCallback(
    async (acceptedFiles: File[]) => {
      if (!activeAgentData) {
        return
      }

      const files = acceptedFiles.map((file) => {
        return new File([file], file.name)
      })

      const assets = await mutateAsync({
        data: {
          files,
        },
      })

      updateAgent(
        {
          agentUuid: activeAgentData?.uuid,
          data: {
            assetUuids: [
              ...(activeAgentData?.assets?.map((asset) => asset.uuid) ?? []),
              ...assets.items?.map((asset) => asset.uuid),
            ],
          },
        },
        {
          onSuccess() {
            queryClient.invalidateQueries({
              queryKey: getGetAgentByUuidQueryKey(activeAgentData?.uuid),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
          },
        },
      )
    },
    [activeAgentData, mutateAsync, queryClient, updateAgent],
  )

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        flexGrow: 1,
        height: 1,
      }}
    >
      <DropzoneInput
        onDrop={handleUploadAssetsAndLinkToAgent}
        isPending={createAssetsIsLoading || updateAgentIsPending}
        isError={createAssetsIsError || updateAgentIsError}
        disabled={enableReadOnly}
      />
      {(createAssetsIsError || updateAgentIsError) && (
        <ErrorMessage error={createAssetsError ?? updateAgentError} />
      )}

      <AssetList
        assets={activeAgentData?.assets}
        failedAssets={createAssetsData?.errors}
      />
    </Box>
  )
}


--- Start of frontend/src/features/agent/components/AgentConfigForm.tsx ---

import { useCallback } from 'react'
import { FormProvider, useForm, useFormContext } from 'react-hook-form'
import { useQueryClient } from '@tanstack/react-query'

import Box from '@mui/joy/Box'

import type {
  AgentConfigCreateFromExisting,
  AgentConfigReadResponse,
  AgentConfigReadResponseNotes,
  AgentStockResponsesInitialMessage,
  TextMessageSectionTemplate,
} from '@/api/models'
import {
  getGetAgentByUuidQueryKey,
  getGetAllAgentsQueryKey,
  getGetAllToolsQueryKey,
  useCreateAgentConfigFromExisting,
} from '@/api/services/api'
import { AgentConfigTextarea } from '@/features/agent/components/AgentConfigTextarea'
import { AgentConfigTools } from '@/features/agent/components/AgentConfigTools'

export interface AgentConfigFormFields {
  role?: TextMessageSectionTemplate['template']
  instructions?: TextMessageSectionTemplate['template']
  isActive?: boolean
  notes?: AgentConfigReadResponseNotes
  version?: number
  initialMessage?: AgentStockResponsesInitialMessage
  maxLengthReached?: string
  tools?: AgentConfigCreateFromExisting['tools']
}
const fields = [
  {
    name: 'role' as const,
    label: 'Role',
    helperText:
      "Describe the role of the agent. It's good to be overly complimentary. E.g. You are the world leading expert in...",
    placeholder:
      "Describe the role of the agent. It's good to be overly complimentary. E.g. You are the world leading expert in...",
  },
  {
    name: 'instructions' as const,
    label: 'Instructions',
    helperText:
      'Describe the task the agent is to perform. E.g. Please provide a summary of the article...',
    placeholder:
      'Describe the task the agent is to perform. E.g. Please provide a summary of the article...',
  },
  {
    name: 'initialMessage' as const,
    label: "Agent's Initial Message",
    helperText:
      "The first message the agent will send to the user. E.g. Hi, I'm here to help you with...",
    placeholder:
      "The first message the agent will send to the user. E.g. Hi, I'm here to help you with...",
  },
  {
    name: 'notes' as const,
    label: 'Version Notes',
    helperText:
      "Add any notes or comments about the agent configuration. These won't be visible to the agent.",
    placeholder: 'Add any notes or comments about the agent configuration.',
  },
]

export function AgentConfigForm({
  enableReadOnly = false,
  agentUuid,
  agentConfigUuid,
  activeConfig,
}: {
  enableReadOnly: boolean
  agentUuid?: string
  agentConfigUuid?: string
  activeConfig?: AgentConfigReadResponse
}) {
  const agentConfigForm = useForm<AgentConfigFormFields>({
    defaultValues: {
      role: activeConfig?.promptTemplate?.sectionsTemplate?.find(
        (section) => section.id === 'role',
      )?.template,
      instructions: activeConfig?.promptTemplate?.sectionsTemplate?.find(
        (section) => section.id === 'task_instructions',
      )?.template,
      isActive: activeConfig?.status === 'active',
      notes: activeConfig?.notes,
      initialMessage: activeConfig?.stockResponses?.initialMessage ?? null,
      maxLengthReached: activeConfig?.stockResponses?.maxLengthReached,
      tools: activeConfig?.tools,
    },
  })
  return (
    <FormProvider {...agentConfigForm}>
      <Box display="flex" flexDirection="column" gap={2}>
        <AgentConfigFields
          enableReadOnly={enableReadOnly}
          agentUuid={agentUuid}
          agentConfigUuid={agentConfigUuid}
        />
        <AgentConfigTools
          enableReadOnly={enableReadOnly}
          agentConfigUuid={agentConfigUuid}
          agentUuid={agentUuid}
        />
      </Box>
    </FormProvider>
  )
}

function AgentConfigFields({
  enableReadOnly,
  agentUuid,
  agentConfigUuid,
}: {
  enableReadOnly: boolean
  agentUuid?: string
  agentConfigUuid?: string
}) {
  const queryClient = useQueryClient()
  const {
    watch,
    formState: { errors, dirtyFields },
  } = useFormContext<AgentConfigFormFields>()
  const formData = watch()
  const {
    mutate: createAgentConfigFromTemplate,
    isError: createAgentConfigIsError,
    error: createAgentConfigError,
  } = useCreateAgentConfigFromExisting()

  const updateConfig = useCallback(
    (name: keyof AgentConfigFormFields, data: AgentConfigFormFields) => {
      const shouldNotUpdate =
        !agentUuid || !agentConfigUuid || !dirtyFields[name]
      if (shouldNotUpdate) {
        return
      }

      const isMessageField = name === 'initialMessage'
      const isPromptField = name === 'role' || name === 'instructions'

      createAgentConfigFromTemplate(
        {
          agentUuid,
          agentConfigUuid,
          data: {
            isActive: true,
            stockResponses:
              isMessageField ?
                {
                  initialMessage:
                    data.initialMessage?.length ? data.initialMessage : null,
                  maxLengthReached: "Sorry, I can't accept any more text",
                }
              : undefined,
            promptTemplate:
              isPromptField ?
                {
                  name: 'default',
                  sectionsTemplate: [
                    {
                      id: 'role',
                      template: data.role ?? '',
                      role: 'system',
                    },
                    {
                      id: 'task_instructions',
                      template: data.instructions ?? '',
                      role: 'system',
                    },
                  ],
                }
              : undefined,
            notes: name === 'notes' ? data.notes : undefined,
          },
        },
        {
          onSuccess() {
            queryClient.invalidateQueries({
              queryKey: getGetAgentByUuidQueryKey(agentUuid),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllAgentsQueryKey(),
            })
            queryClient.invalidateQueries({
              queryKey: getGetAllToolsQueryKey(),
            })
          },
        },
      )
    },
    [
      agentUuid,
      agentConfigUuid,
      createAgentConfigFromTemplate,
      queryClient,
      dirtyFields,
    ],
  )

  return (
    <>
      {fields.map(({ name, label, helperText, placeholder }) => (
        <AgentConfigTextarea
          key={name}
          name={name}
          label={label}
          helperText={helperText}
          placeholder={placeholder}
          enableReadOnly={enableReadOnly}
          isError={Boolean(errors[name]) || createAgentConfigIsError}
          error={createAgentConfigError}
          options={{ onBlur: () => updateConfig(name, formData) }}
        />
      ))}
    </>
  )
}


--- Start of frontend/src/features/feedback/index.tsx ---

import { FeedbackModal } from '@/features/feedback/components/FeedbackModal'

export { FeedbackModal }


--- Start of frontend/src/features/feedback/store.ts ---

import { create } from 'zustand'

import type { FeedbackTarget } from '@/api/models'

interface FeedbackStore {
  feedbackModalOpen: boolean
  setFeedbackModalOpen: ({
    open,
    scope,
    feedbackTargetUuid,
  }: {
    open: boolean
    scope?: FeedbackTarget
    feedbackTargetUuid?: string
  }) => void
  feedbackModalScope: FeedbackTarget
  feedbackTargetUuid?: string
}
const useFeedbackStore = create<FeedbackStore>((set) => ({
  feedbackModalOpen: false,
  feedbackTargetUuid: '',
  setFeedbackModalOpen: ({ open, scope = 'application', feedbackTargetUuid }) =>
    set({
      feedbackModalOpen: open,
      feedbackModalScope: scope,
      feedbackTargetUuid,
    }),
  feedbackModalScope: 'application',
}))

export { useFeedbackStore }


--- Start of frontend/src/features/feedback/components/FeedbackModal.tsx ---

import { FormProvider, useForm } from 'react-hook-form'
import { useTranslation } from 'react-i18next'
import { zodResolver } from '@hookform/resolvers/zod'

import DialogTitle from '@mui/joy/DialogTitle'
import Divider from '@mui/joy/Divider'

import { transformStringValueToSnakeCase } from '@/shared/utils/case-transformers'
import type { FeedbackCreate, FeedbackType } from '@/api/models'
import { sendFeedbackBody } from '@/api/schemas/zod'
import { useGetUserProfile, useSendFeedback } from '@/api/services/api'
import { FeedbackModalActions } from '@/features/feedback/components/FeedbackModalActions'
import { FeedbackModalContent } from '@/features/feedback/components/FeedbackModalContent'
import { useFeedbackStore } from '@/features/feedback/store'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export function FeedbackModal() {
  const { t } = useTranslation()
  const { data: userProfile } = useGetUserProfile()
  const {
    feedbackModalOpen,
    setFeedbackModalOpen,
    feedbackModalScope,
    feedbackTargetUuid,
  } = useFeedbackStore()
  const {
    mutate: sendUserFeedbackToServer,
    isPending: sendFeedbackIsPending,
    isError: sendFeedbackIsError,
    error: sendFeedbackError,
    reset: resetSendFeedback,
  } = useSendFeedback()

  const form = useForm<FeedbackCreate>({
    resolver: zodResolver(
      // just the type and feedback are required
      sendFeedbackBody.pick({ type: true, feedback: true, rating: true }),
    ),
  })
  const { handleSubmit, reset } = form

  const sendFeedback = async (data: FeedbackCreate) => {
    if (!userProfile) {
      return
    }

    await sendUserFeedbackToServer(
      {
        data: {
          ...data,
          target: feedbackModalScope,
          type: transformStringValueToSnakeCase(data?.type) as FeedbackType,
          targetUuid:
            feedbackModalScope === 'application' ? undefined : (
              feedbackTargetUuid
            ),
          userUuid: userProfile.uuid,
          url: window.location.href,
        },
      },
      {
        onSuccess() {
          setFeedbackModalOpen({ open: false })
          reset()
          resetSendFeedback()
        },
      },
    )
  }
  const handleCloseModal = () => {
    setFeedbackModalOpen({ open: false })
    reset()
    resetSendFeedback()
  }

  return (
    <FormProvider {...form}>
      <ModalDialogBase
        onClose={handleCloseModal}
        open={feedbackModalOpen}
        modalDialogProps={{ maxWidth: 'sm' }}
      >
        <DialogTitle>{t(`feedback.${feedbackModalScope}`)}</DialogTitle>
        <Divider />

        <FeedbackModalContent
          sendFeedbackIsError={sendFeedbackIsError}
          sendFeedbackError={sendFeedbackError}
        />
        <FeedbackModalActions
          handleSubmit={handleSubmit}
          sendFeedback={sendFeedback}
          sendFeedbackIsPending={sendFeedbackIsPending}
          handleCancel={handleCloseModal}
        />
      </ModalDialogBase>
    </FormProvider>
  )
}


--- Start of frontend/src/features/feedback/components/FeedbackModalAdditionalFeedbackTextarea.tsx ---

import { useFormContext } from 'react-hook-form'

import Box from '@mui/joy/Box'
import FormControl from '@mui/joy/FormControl'
import FormHelperText from '@mui/joy/FormHelperText'
import Textarea from '@mui/joy/Textarea'
import Typography from '@mui/joy/Typography'

import type { FeedbackCreate } from '@/api/models'

export function FeedbackModalAdditionalFeedbackTextarea() {
  const {
    register,
    formState: { errors },
  } = useFormContext<FeedbackCreate>()
  return (
    <Box display="flex" flexDirection="column" gap={2} width="100%">
      <Typography level="title-sm" textColor="text.secondary">
        Additional Feedback
      </Typography>
      <FormControl sx={{ width: '100%' }} error={!!errors.feedback}>
        <Textarea
          error={!!errors.feedback}
          {...register('feedback')}
          minRows={3}
        />
        {errors.feedback && (
          <FormHelperText
            sx={{
              fontSize: (theme) => theme.typography['body-xs'].fontSize,
            }}
          >
            {errors.feedback?.message}
          </FormHelperText>
        )}
      </FormControl>
    </Box>
  )
}


--- Start of frontend/src/features/feedback/components/FeedbackModalActions.tsx ---

import type { UseFormHandleSubmit } from 'react-hook-form'

import Button from '@mui/joy/Button'
import DialogActions from '@mui/joy/DialogActions'

import type { FeedbackCreate } from '@/api/models'

export function FeedbackModalActions({
  handleSubmit,
  sendFeedback,
  sendFeedbackIsPending,
  handleCancel,
}: {
  handleSubmit: UseFormHandleSubmit<FeedbackCreate, undefined>
  sendFeedback: (data: FeedbackCreate) => Promise<void>
  sendFeedbackIsPending: boolean
  handleCancel: () => void
}) {
  return (
    <DialogActions sx={{ width: '100%' }}>
      <Button
        onClick={handleSubmit(sendFeedback)}
        color="primary"
        type="submit"
        disabled={sendFeedbackIsPending}
        loading={sendFeedbackIsPending}
      >
        Submit
      </Button>
      <Button onClick={handleCancel} color="neutral" variant="outlined">
        Cancel
      </Button>
    </DialogActions>
  )
}


--- Start of frontend/src/features/feedback/components/FeedbackRadioGroup.tsx ---

import { useFormContext } from 'react-hook-form'
import { useTranslation } from 'react-i18next'

import FormHelperText from '@mui/joy/FormHelperText'
import FormLabel from '@mui/joy/FormLabel'
import Radio, { radioClasses } from '@mui/joy/Radio'
import RadioGroup from '@mui/joy/RadioGroup'
import Sheet from '@mui/joy/Sheet'

import type { FeedbackCreate, FeedbackRating, FeedbackType } from '@/api/models'
import { Icon } from '@/components/common/Icon'

const colorMap: Record<
  FeedbackRating,
  'secondary' | 'success' | 'danger' | 'warning' | 'neutral'
> = {
  bad: 'warning',
  good: 'neutral',
  great: 'success',
  terrible: 'danger',
}
export function FeedbackRadioGroup({
  name,
  values,
  ariaLabel,
}: {
  name: keyof Pick<FeedbackCreate, 'type' | 'rating'>
  values: string[]
  ariaLabel: string
}) {
  const {
    register,
    formState: { errors },
  } = useFormContext<FeedbackCreate>()
  const { t } = useTranslation()

  return (
    <RadioGroup
      aria-label={ariaLabel}
      overlay
      sx={{
        flexDirection: 'row',
        flexWrap: 'wrap',
        gap: 1,
        [`& .${radioClasses.checked}`]: {
          [`& .${radioClasses.action}`]: {
            inset: -1,
            border: (theme) => `2px solid ${theme.palette.primary[500]}`,
          },
        },
        [`& .${radioClasses.radio}`]: {
          display: 'contents',
          '& > svg': {
            zIndex: (theme) => theme.zIndex.modal + 1,
            position: 'absolute',
            top: '-8px',
            right: '-8px',
            border: (theme) => `2px solid ${theme.palette.primary[500]}`,
            bgcolor: 'background.surface',
            borderRadius: '50%',
          },
        },
      }}
    >
      {values?.map((value) => (
        <Sheet
          key={value}
          variant="outlined"
          sx={{
            borderRadius: 'md',
            display: 'flex',
            alignItems: 'center',
            px: 2,
            py: 1,
          }}
        >
          <Radio
            {...register(name)}
            id={value}
            value={value}
            checkedIcon={<Icon name="check" color="primary" />}
          />
          <Icon
            name={value as FeedbackRating | FeedbackType}
            color={colorMap?.[value as FeedbackRating] ?? 'secondary'}
          />
          <FormLabel
            htmlFor={value}
            sx={{
              ml: 1,
            }}
          >
            {t(`feedback.${value}`)}
          </FormLabel>
        </Sheet>
      ))}
      {errors?.[name] && (
        <FormHelperText sx={{ color: 'danger.500' }}>
          {errors?.[name]?.message}
        </FormHelperText>
      )}
    </RadioGroup>
  )
}


--- Start of frontend/src/features/feedback/components/FeedbackModalContent.tsx ---

import Box from '@mui/joy/Box'
import DialogContent from '@mui/joy/DialogContent'
import Typography from '@mui/joy/Typography'

import { FeedbackRating, FeedbackType } from '@/api/models'
import { FeedbackModalAdditionalFeedbackTextarea } from '@/features/feedback/components/FeedbackModalAdditionalFeedbackTextarea'
import { FeedbackRadioGroup } from '@/features/feedback/components/FeedbackRadioGroup'
import { ErrorMessage } from '@/components/common'

export function FeedbackModalContent({
  sendFeedbackIsError,
  sendFeedbackError,
}: {
  sendFeedbackIsError: boolean
  sendFeedbackError: unknown
}) {
  return (
    <DialogContent
      component="form"
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 4,
        py: 2,
        width: '100%',
      }}
    >
      {sendFeedbackIsError && <ErrorMessage error={sendFeedbackError as any} />}
      <Box display="flex" flexDirection="column" gap={2} width="100%">
        <Typography level="title-sm" textColor="text.secondary">
          Type of Feedback
        </Typography>
        <FeedbackRadioGroup
          name="type"
          values={Object.values(FeedbackType)}
          ariaLabel="type"
        />
      </Box>

      <Box display="flex" flexDirection="column" gap={2} width="100%">
        <Typography level="title-sm" textColor="text.secondary">
          Give a rating
        </Typography>
        <FeedbackRadioGroup
          name="rating"
          values={Object.values(FeedbackRating)}
          ariaLabel="rating"
        />
      </Box>

      <FeedbackModalAdditionalFeedbackTextarea />
    </DialogContent>
  )
}


--- Start of frontend/src/features/search/hooks.ts ---

import { useEffect } from 'react'
import { useLocation } from 'react-router-dom'

import { useSearchStore } from '@/features/search/store'

export function useListenForRouteChangeAndCloseModal() {
  const location = useLocation()
  const { setSearchModalOpen } = useSearchStore()

  useEffect(() => {
    setSearchModalOpen({ open: false })
  }, [location, setSearchModalOpen])
}


--- Start of frontend/src/features/search/store.ts ---

import { create } from 'zustand'

interface SearchStore {
  searchResultsFilter: 'all' | 'conversation' | 'message' | 'asset'
  searchModalOpen: boolean
  searchQuery: string
  searchConversationUuidFilter: string | null
  setSearchResultsFilter: (
    filter: 'all' | 'conversation' | 'message' | 'asset',
  ) => void
  setSearchQuery: (query: string) => void
  setSearchModalOpen: ({ open }: { open: boolean }) => void
  setSearchConversationUuidFilter: (uuid: string | null) => void
}
const useSearchStore = create<SearchStore>((set) => ({
  searchResultsFilter: 'all',
  searchQuery: '',
  searchConversationUuidFilter: null,
  searchModalOpen: false,
  setSearchResultsFilter: (filter) => set({ searchResultsFilter: filter }),
  setSearchModalOpen: ({ open }) => set({ searchModalOpen: open }),
  setSearchQuery: (query: string) => set({ searchQuery: query }),
  setSearchConversationUuidFilter: (uuid: string | null) =>
    set({ searchConversationUuidFilter: uuid }),
}))

export { useSearchStore }


--- Start of frontend/src/features/search/components/SearchModalContent.tsx ---

import { formatDistance } from 'date-fns'

import Accordion from '@mui/joy/Accordion'
import AccordionDetails from '@mui/joy/AccordionDetails'
import AccordionGroup from '@mui/joy/AccordionGroup'
import AccordionSummary from '@mui/joy/AccordionSummary'
import Avatar from '@mui/joy/Avatar'
import Box from '@mui/joy/Box'
import IconButton from '@mui/joy/IconButton'
import List from '@mui/joy/List'
import ListItemButton from '@mui/joy/ListItemButton'
import ListItemContent from '@mui/joy/ListItemContent'
import Stack from '@mui/joy/Stack'
import Typography from '@mui/joy/Typography'

import type {
  AssetReadResponse,
  MessageSearchResult,
  SearchResultsResponse,
} from '@/api/models'
import { ConversationMessageTitle } from '@/features/conversation/components/conversation-message/ConversationMessageTitle'
import { Icon, LinkListItem } from '@/components/common'
import { AssetThumbnail } from '@/components/common/assets/Asset'

export function SearchResultsConversation({
  searchResults,
}: {
  searchResults: SearchResultsResponse['conversation']
}) {
  return (
    <List>
      {searchResults?.hits?.map((result) => (
        <LinkListItem key={result.uuid} to={`/conversations/${result.uuid}`}>
          <ListItemButton
            sx={{ gap: 2, display: 'flex', justifyContent: 'space-between' }}
          >
            <Box
              sx={{
                display: 'flex',
                gap: 2,
                alignItems: 'center',
                flex: 2,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
              }}
            >
              <Avatar variant="outlined" size="sm">
                {result?.name.charAt(0)}
              </Avatar>

              <Typography level="title-sm" textColor="text.primary">
                {result.name}
              </Typography>
            </Box>
            {result.createdAt && (
              <Typography level="body-xs" flex={1}>
                {formatDistance(new Date(result.createdAt), new Date(), {
                  addSuffix: true,
                })}
              </Typography>
            )}

            <IconButton aria-label="more" size="sm">
              <Icon name="arrowRight" />
            </IconButton>
          </ListItemButton>
        </LinkListItem>
      ))}
    </List>
  )
}

export function SearchResultAsset({
  searchResults,
}: {
  searchResults: SearchResultsResponse['asset']
}) {
  return (
    <List>
      {searchResults?.hits?.map((result) => (
        <LinkListItem key={result.uuid} to={`/conversations/${result.uuid}`}>
          <Box
            flex={2}
            sx={{
              gap: 2,
              display: 'flex',
              alignItems: 'center',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            }}
          >
            <AssetThumbnail
              asset={result as AssetReadResponse}
              maxWidth={32}
              maxHeight={32}
            />

            <Typography level="body-md" textColor="text.primary" noWrap>
              {result.name}
            </Typography>
          </Box>
          <Typography level="body-xs" flex={1}>
            {result.type}
          </Typography>
          <IconButton aria-label="more" size="sm">
            <Icon name="arrowRight" />
          </IconButton>
        </LinkListItem>
      ))}
    </List>
  )
}

export function SearchResultsMessage({
  searchResults,
}: {
  searchResults: SearchResultsResponse['message']
}) {
  // if same conversationUuid then group and order by createdAt
  const groupedResults = searchResults?.hits?.reduce(
    (acc, result) => {
      if (acc[result.conversationUuid]) {
        acc[result.conversationUuid].push(result)
      } else {
        acc[result.conversationUuid] = [result]
      }
      return acc
    },
    {} as Record<string, MessageSearchResult[]>,
  )
  return (
    <AccordionGroup disableDivider sx={{}}>
      {Object.values(groupedResults ?? {}).map((results) => {
        const conversationUuid = results[0].conversationUuid
        return (
          <Accordion key={conversationUuid}>
            <AccordionSummary indicator={<Icon name="downChevron" />}>
              <Box
                flex={1}
                sx={{ display: 'flex', gap: 2, alignItems: 'center', flex: 2 }}
              >
                <Avatar
                  variant="outlined"
                  size="sm"
                  src={results[0].authorImageUrl ?? undefined}
                >
                  {results[0].conversationName.charAt(0)}
                </Avatar>
                <Typography level="body-sm" textColor="text.primary" noWrap>
                  {results[0].conversationName}
                </Typography>
              </Box>
              <Typography level="body-xs" flex={1} noWrap>
                {results.length} {results.length > 1 ? 'mentions' : 'mention'}
              </Typography>
            </AccordionSummary>
            <AccordionDetails>
              <List
                size="sm"
                sx={{
                  borderLeft: (theme) => `1px solid ${theme.palette.divider}`,
                  pl: 3.5,
                  ml: 2,
                  gap: 2,
                }}
              >
                {results.map((result) => {
                  if (!result?.content) {
                    return null
                  }
                  return (
                    <LinkListItem
                      key={result.uuid}
                      to={`/conversations/${result.conversationUuid}`}
                      endAction={<Icon name="arrowRight" />}
                    >
                      <ListItemContent
                        sx={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: 1,
                        }}
                      >
                        <Stack
                          direction="row"
                          justifyContent="space-between"
                          alignItems="center"
                          gap={4}
                        >
                          <Box sx={{ display: 'flex', gap: 1 }}>
                            <ConversationMessageTitle
                              authorName={result?.authorName}
                            />
                          </Box>
                        </Stack>
                        <Typography
                          level="body-md"
                          textColor="text.secondary"
                          noWrap
                        >
                          {result.content}
                        </Typography>
                      </ListItemContent>
                    </LinkListItem>
                  )
                })}
              </List>
            </AccordionDetails>
          </Accordion>
        )
      })}
    </AccordionGroup>
  )
}


--- Start of frontend/src/features/search/components/SearchBar.tsx ---

import { useTranslation } from 'react-i18next'

import { useTheme } from '@mui/joy'
import Box from '@mui/joy/Box'
import Chip from '@mui/joy/Chip'
import ChipDelete from '@mui/joy/ChipDelete'
import IconButton from '@mui/joy/IconButton'
import Input from '@mui/joy/Input'

import { useGetConversationByUuid } from '@/api/services/api'
import { useSearchStore } from '@/features/search/store'
import { Icon } from '@/components/common'

export function SearchBar({
  searchIsError,
  searchIsPending,
  handleSearch,
}: {
  searchIsError: boolean
  searchIsPending: boolean
  handleSearch: () => void
}) {
  const theme = useTheme()
  const {
    searchQuery,
    setSearchQuery,
    setSearchConversationUuidFilter,
    searchConversationUuidFilter,
    setSearchModalOpen,
  } = useSearchStore()
  const { t } = useTranslation()
  const { data } = useGetConversationByUuid(
    searchConversationUuidFilter as string,
    { query: { enabled: !!searchConversationUuidFilter } },
  )

  return (
    <Input
      variant="plain"
      size="lg"
      placeholder={t(`search.placeholder`)}
      value={searchQuery}
      onChange={(e) => setSearchQuery(e.target.value)}
      error={searchIsError}
      autoFocus
      sx={{
        '&::before': {
          display: 'none',
        },
        mr: 1,
      }}
      endDecorator={
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          {searchConversationUuidFilter && data && (
            <Chip
              size="lg"
              sx={{
                mr: 1,
                width: {
                  xs: theme.spacing(16),
                  sm: theme.spacing(32),
                },
              }}
              endDecorator={
                <ChipDelete
                  onDelete={() => setSearchConversationUuidFilter(null)}
                />
              }
            >
              {data.name}
            </Chip>
          )}
          <IconButton
            variant="plain"
            type="submit"
            size="sm"
            color={searchQuery.length > 0 ? 'primary' : 'neutral'}
            disabled={searchIsPending}
            onClick={handleSearch}
          >
            <Icon
              name="search"
              color={searchQuery.length > 0 ? 'primary' : 'secondary'}
            />
          </IconButton>

          <IconButton
            variant="plain"
            size="sm"
            onClick={() => {
              setSearchQuery('')
              setSearchConversationUuidFilter(null)
              setSearchModalOpen({ open: false })
            }}
          >
            <Icon name="close" color="secondary" />
          </IconButton>
        </Box>
      }
    />
  )
}


--- Start of frontend/src/features/search/components/SearchFilters.tsx ---

import Chip from '@mui/joy/Chip'
import List from '@mui/joy/List'
import ListItem from '@mui/joy/ListItem'

import { useResponsiveAppMode } from '@/shared/configuration'
import { useSearchStore } from '@/features/search/store'

interface Filter {
  label: string
  value: 'all' | 'conversation' | 'message' | 'asset'
}
const FILTER: Filter[] = [
  {
    label: 'All',
    value: 'all',
  },
  {
    label: 'Conversations',
    value: 'conversation',
  },
  {
    label: 'Messages',
    value: 'message',
  },
  {
    label: 'Assets',
    value: 'asset',
  },
]

export function SearchFilters() {
  const { isSmallScreen } = useResponsiveAppMode()
  const { searchResultsFilter, setSearchResultsFilter } = useSearchStore()

  return (
    <List orientation="horizontal" sx={{ px: 0, gap: 0.5, py: 0.5 }}>
      {FILTER.map(({ value, label }) => (
        <ListItem key={value} sx={{ px: 0 }}>
          <Chip
            onClick={() => setSearchResultsFilter(value)}
            variant={searchResultsFilter === value ? 'outlined' : 'soft'}
            size={isSmallScreen ? 'md' : 'lg'}
          >
            {label}
          </Chip>
        </ListItem>
      ))}
    </List>
  )
}


--- Start of frontend/src/features/search/components/SearchModal.tsx ---

import { useCallback, useEffect } from 'react'

import Box from '@mui/joy/Box'
import DialogContent from '@mui/joy/DialogContent'
import Skeleton from '@mui/joy/Skeleton'
import Tab, { tabClasses } from '@mui/joy/Tab'
import TabList from '@mui/joy/TabList'
import TabPanel from '@mui/joy/TabPanel'
import Tabs from '@mui/joy/Tabs'
import Typography from '@mui/joy/Typography'

import { useResponsiveAppMode } from '@/shared/configuration'
import { useListenForKeyAndCallback } from '@/shared/hooks'
import { useSearch } from '@/api/services/api'
import { SearchBar } from '@/features/search/components/SearchBar'
import {
  SearchResultAsset,
  SearchResultsConversation,
  SearchResultsMessage,
} from '@/features/search/components/SearchModalContent'
import { useListenForRouteChangeAndCloseModal } from '@/features/search/hooks'
import { useSearchStore } from '@/features/search/store'
import { ErrorMessage, Icon } from '@/components/common'
import type { IconName } from '@/components/common/Icon'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

interface TabsI {
  label: string
  value: 'all' | 'conversation' | 'message' | 'asset'
  icon: IconName
}
const TABS: TabsI[] = [
  {
    label: 'All',
    value: 'all',
    icon: 'global',
  },
  {
    label: 'Conversations',
    value: 'conversation',
    icon: 'conversation',
  },
  {
    label: 'Messages',
    value: 'message',
    icon: 'message',
  },
  {
    label: 'Assets',
    value: 'asset',
    icon: 'assetUpload',
  },
]

export function SearchModal() {
  const { responsiveAppMode } = useResponsiveAppMode()
  const {
    searchConversationUuidFilter,
    searchModalOpen,
    setSearchModalOpen,
    searchQuery,
  } = useSearchStore()
  useListenForRouteChangeAndCloseModal()

  const {
    data: searchResults,
    mutate: search,
    isPending: searchIsPending,
    isSuccess: searchIsSuccess,
    isError: searchIsError,
    error: searchError,
    reset: resetSearch,
  } = useSearch()

  const handleSearch = useCallback(async () => {
    if (!searchQuery) {
      return
    }
    await search({
      data: {
        query: searchQuery,
        conversationUuidFilter: searchConversationUuidFilter,
        limit: 10,
      },
    })
  }, [search, searchQuery, searchConversationUuidFilter])

  const handleCloseModal = () => {
    setSearchModalOpen({ open: false })
    resetSearch()
  }

  useEffect(() => {
    if (searchModalOpen) {
      handleSearch()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchModalOpen])

  useListenForKeyAndCallback({
    handkleKeyDown(e) {
      // if user presses enter key
      if (e.key === 'Enter' && searchModalOpen) {
        handleSearch()
      }
    },
  })

  const noResults =
    searchIsSuccess &&
    searchResults?.conversation?.hits?.length === 0 &&
    searchResults?.message?.hits?.length === 0 &&
    searchResults?.asset?.hits?.length === 0

  return (
    <ModalDialogBase
      onClose={handleCloseModal}
      open={searchModalOpen}
      withCloseButton={false}
      disablePortal
      modalDialogProps={{
        sx: {
          px: 0,
          py: 1,
          width: '100%',
          maxWidth: 'sm',
          maxHeight: '100%',
          minHeight: 400,
        },
      }}
    >
      <Tabs
        defaultValue={0}
        sx={{
          backgroundColor: 'transparent',
          [`&& .${tabClasses.root}`]: {
            bgcolor: 'transparent',
            '&:hover': {
              bgcolor: 'transparent',
            },
            [`&.${tabClasses.selected}`]: {
              bgcolor: 'transparent',
            },
          },
          overflowY: 'scroll',
        }}
      >
        <Box
          sx={{
            display: 'flex',
            flexDirection: 'column',
            position: 'sticky',
            top: 0,
            zIndex: (theme) => theme.zIndex.modal,
          }}
        >
          <SearchBar
            searchIsError={searchIsError}
            searchIsPending={searchIsPending}
            handleSearch={handleSearch}
          />

          <TabList>
            {TABS.map((tab, index) => (
              <Tab key={tab.value} value={index}>
                {responsiveAppMode === 'desktop' && <Icon name={tab.icon} />}
                {tab.label}
              </Tab>
            ))}
          </TabList>
        </Box>

        <DialogContent sx={{ height: '100%', overflowY: 'scroll' }}>
          {(() => {
            if (searchIsPending) {
              return (
                <Box
                  sx={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: 2,
                    p: 2,
                  }}
                >
                  <Skeleton variant="text" />
                  <Skeleton variant="text" />
                  <Skeleton variant="text" />
                </Box>
              )
            }

            if (searchIsError) {
              return (
                <Box p={2}>
                  <ErrorMessage error={searchError} />
                </Box>
              )
            }

            if (searchQuery === '') {
              return (
                <Typography level="body-md" p={2}>
                  Please enter a search query to get started
                </Typography>
              )
            }

            if (noResults && searchQuery !== '') {
              return (
                <Typography level="body-md" p={2}>
                  No results found
                </Typography>
              )
            }

            return (
              <>
                <TabPanel value={0}>
                  {searchIsSuccess &&
                    (searchResults?.conversation?.hits?.length ?? 0) > 0 && (
                      <Box sx={{ mb: 2 }}>
                        <Typography level="body-xs" mb={1}>
                          Conversations
                        </Typography>
                        <SearchResultsConversation
                          searchResults={searchResults?.conversation}
                        />
                      </Box>
                    )}
                  {searchIsSuccess &&
                    (searchResults?.message?.hits?.length ?? 0) > 0 && (
                      <Box sx={{ mb: 2 }}>
                        <Typography level="body-xs" mb={1}>
                          Messages
                        </Typography>
                        <SearchResultsMessage
                          searchResults={searchResults?.message}
                        />
                      </Box>
                    )}
                  {searchIsSuccess &&
                    (searchResults?.asset?.hits?.length ?? 0) > 0 && (
                      <Box sx={{ mb: 2 }}>
                        <Typography level="body-xs" mb={1}>
                          Assets
                        </Typography>
                        <SearchResultAsset
                          searchResults={searchResults?.asset}
                        />
                      </Box>
                    )}
                </TabPanel>
                <TabPanel value={1}>
                  <SearchResultsConversation
                    searchResults={searchResults?.conversation}
                  />
                </TabPanel>
                <TabPanel value={2}>
                  <SearchResultsMessage
                    searchResults={searchResults?.message}
                  />
                </TabPanel>
                <TabPanel value={3}>
                  <SearchResultAsset searchResults={searchResults?.asset} />
                </TabPanel>
              </>
            )
          })()}
        </DialogContent>
      </Tabs>
    </ModalDialogBase>
  )
}


--- Start of frontend/src/features/layouts/PublicLayout.tsx ---

import { Navigate, Outlet } from 'react-router-dom'

import { useCheckLogin } from '@/api/services/api'
import { PublicMain } from '@/components/layout'

export function PublicLayout() {
  const { isSuccess: userIsAuthenticated } = useCheckLogin({
    query: { retry: false },
  })

  // If the user is already authenticated, redirect them to the home page
  if (userIsAuthenticated) {
    return <Navigate to="/" replace />
  }

  return (
    <PublicMain>
      <Outlet />
    </PublicMain>
  )
}


--- Start of frontend/src/features/layouts/index.ts ---

import { AuthenticatedLayout } from '@/features/layouts/AuthenticatedLayout'
import { PublicLayout } from '@/features/layouts/PublicLayout'

export { AuthenticatedLayout, PublicLayout }


--- Start of frontend/src/features/layouts/AuthenticatedLayout.tsx ---

import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels'
import { Navigate, Outlet } from 'react-router-dom'

import Box from '@mui/joy/Box'
import { styled } from '@mui/joy/styles'

import { useProductAnalyticsIdentifyUser } from '@/shared/analytics/hooks'
import { useResponsiveAppMode } from '@/shared/configuration/hooks'
import { useGetUserProfile } from '@/api/services/api'
import { AgentConfiguration } from '@/features/agent/components/AgentConfiguration'
import { useAgentStore } from '@/features/agent/store'
import { Modals, Sidebar, SplashScreen } from '@/components/layout'

function useCheckAuthentication() {
  const result = useGetUserProfile({
    query: {
      retry: false,
    },
  })

  return {
    ...result,
    checkingAuthentication: result.isLoading,
    authenticated: result.isSuccess,
    notAuthenticated: result.isError && result.error?.response?.status === 401,
    error: result.error,
  }
}

// use theme from MUI
const StyledPanelResizeHandle = styled(PanelResizeHandle)(({ theme }) => ({
  cursor: 'ew-resize',
  height: '100%',
  width: 1,
  padding: 2,
  transition: 'background-color 0.2s',
  '&:hover': {
    backgroundColor: theme.palette.primary[500],
    width: 2,
  },
}))

export function AuthenticatedLayout() {
  const { isSmallScreen, responsiveAppMode } = useResponsiveAppMode()
  const { notAuthenticated, checkingAuthentication, isSuccess, data } =
    useCheckAuthentication()
  const { agentConfigurationSidePanelOpen } = useAgentStore()

  useProductAnalyticsIdentifyUser({
    identifier: data?.username,
    shouldIdentify: isSuccess,
  })

  if (checkingAuthentication) {
    return <SplashScreen />
  }

  if (notAuthenticated) {
    return <Navigate to="/login" replace />
  }

  if (isSmallScreen) {
    return (
      <Box
        height={responsiveAppMode === 'widget' ? '100%' : '100svh'}
        display="flex"
        flexDirection="column"
        overflow="hidden"
        position="relative"
      >
        <Outlet />
        <AgentConfiguration />
        <Modals />
      </Box>
    )
  }

  return (
    <Box
      height="100vh"
      display="flex"
      overflow="hidden"
      bgcolor={(theme) => theme.palette.background.body}
    >
      <Sidebar />
      <PanelGroup direction="horizontal">
        <Panel
          id="main-panel"
          minSize={30}
          style={{ display: 'flex', flexDirection: 'column', height: '100dvh' }}
          order={0}
        >
          <Outlet />
        </Panel>
        {agentConfigurationSidePanelOpen && (
          <>
            <StyledPanelResizeHandle />
            <AgentConfiguration />
          </>
        )}
        <Modals />
      </PanelGroup>
    </Box>
  )
}


--- Start of frontend/src/features/conversation/hooks.tsx ---

import { useCallback, useContext, useEffect, useState } from 'react'
import { useMatch, useNavigate } from 'react-router-dom'
import { useMutationState, useQueryClient } from '@tanstack/react-query'

import {
  useAbortController,
  usePatchUserMessage,
  useRegenerateMessage,
  useSendMessageAndReceiveStreamedResponse,
} from '@/api/custom/api'
import type {
  AssetReadResponse,
  ConversationHistoryResponse,
  ConversationListResponse,
  ConversationReadResponse,
  MessageReadResponse,
} from '@/api/models'
import {
  getGetAllAssetsQueryKey,
  getGetAllConversationsQueryKey,
  getGetConversationByUuidQueryKey,
  getGetConversationHistoryQueryKey,
  useDeleteConversation,
  type PatchUserMessageMutationBody,
} from '@/api/services/api'
import {
  MessageContext,
  type MessageContextType,
} from '@/features/conversation/context'
import {
  useMessageAssetsStore,
  useMessageStore,
} from '@/features/conversation/store'

export function useHandleStopSteaming() {
  const { patchMessage, regenerateMessage, sendMessage } = useMessageContext()

  const { onStopPatchMessageStream } = patchMessage
  const { onStopRegenerateMessageStream } = regenerateMessage
  const { onStopSendMessageStream } = sendMessage

  const handleStopStream = useCallback(() => {
    onStopSendMessageStream?.()
    onStopPatchMessageStream?.()
    onStopRegenerateMessageStream?.()
  }, [
    onStopSendMessageStream,
    onStopPatchMessageStream,
    onStopRegenerateMessageStream,
  ])

  return { handleStopStream }
}

export function useHandleResetSteamingError() {
  const { patchMessage, regenerateMessage, sendMessage } = useMessageContext()

  const { patchMessageMutation } = patchMessage
  const { regenerateMutation } = regenerateMessage
  const { sendMessageMutation } = sendMessage

  const handleResetError = useCallback(() => {
    if (patchMessageMutation.status === 'error') {
      patchMessageMutation.reset()
    }
    if (regenerateMutation.status === 'error') {
      regenerateMutation.reset()
    }
    if (sendMessageMutation.status === 'error') {
      sendMessageMutation.reset()
    }
  }, [patchMessageMutation, regenerateMutation, sendMessageMutation])

  return { handleResetError }
}

export function useMessageStreamingState({
  conversationUuid,
}: {
  conversationUuid?: string
}) {
  const { patchMessage, regenerateMessage } = useMessageContext()
  const { patchMessageMutation } = patchMessage
  const { regenerateMutation } = regenerateMessage
  const { status = 'idle', error = null } =
    useGetConversationMessageStreamMutationState({ conversationUuid }) || {}

  const messageStreamIsPending =
    status === 'pending' ||
    patchMessageMutation.status === 'pending' ||
    regenerateMutation.status === 'pending'
  const messageStreamIsError =
    status === 'error' ||
    patchMessageMutation.status === 'error' ||
    regenerateMutation.status === 'error'
  const messageStreamError =
    error || patchMessageMutation.error || regenerateMutation.error

  return {
    messageStreamIsPending,
    messageStreamIsError,
    messageStreamError,
  }
}

// This is a custom hook that returns the latest mutation state for a conversation message stream.
// This makes it possible to navigate away, and then come back to the conversation and have the correct mutation state.
export function useGetConversationMessageStreamMutationState({
  conversationUuid,
}: {
  conversationUuid?: string
}) {
  const mutations = useMutationState({
    filters: { mutationKey: ['/api/message/streaming'] },
  }) as any[]
  const filteredMutations = mutations.filter(
    (mutation) =>
      mutation.variables?.params?.conversationUuid === conversationUuid,
  )
  return filteredMutations[filteredMutations.length - 1]
}

export function useSendInitialMessageAndNavigate({
  conversationUuid,
}: {
  conversationUuid: string
}) {
  const navigate = useNavigate()
  const queryClient = useQueryClient()
  const { sendMessage } = useMessageContext()
  const { resetMessageStore } = useMessageStore()
  const { messageAssets, resetMessageAssetsStore } = useMessageAssetsStore()
  const mutationState = useGetConversationMessageStreamMutationState({
    conversationUuid,
  })

  const handleSendMessage = useCallback(
    ({
      conversationUuid,
      message,
    }: {
      conversationUuid: string
      message: string
    }) => {
      if (!conversationUuid || mutationState?.status === 'pending') {
        return
      }

      sendMessage?.handleSendMessageAndReceiveMessage({
        conversationUuid,
        content: message,
        messageAssets,
        onSSEOpen() {
          queryClient?.setQueryData(
            getGetAllConversationsQueryKey(),
            (cachedData: ConversationListResponse) => {
              if (cachedData == null) {
                return cachedData
              }
              return {
                ...cachedData,
                items: [
                  {
                    uuid: conversationUuid,
                    name: 'New Conversation',
                    createdAt: Date.now(),
                    isPending: true,
                  },
                  ...cachedData.items,
                ],
              }
            },
          )
        },
        onSSEMessage({ data }) {
          queryClient?.setQueryData(
            getGetAllConversationsQueryKey(),
            (cachedData: ConversationListResponse) => {
              if (
                cachedData == null ||
                data?.conversationNameUpdatedStreaming == null
              ) {
                return cachedData
              }
              const conversationExists = cachedData?.items?.find(
                ({ uuid }) => uuid === conversationUuid,
              )
              if (conversationExists) {
                return {
                  ...cachedData,
                  items: cachedData.items.map((item) => {
                    if (item.uuid === conversationUuid) {
                      return {
                        ...item,
                        name: data?.conversationNameUpdatedStreaming,
                      }
                    }
                    return item
                  }),
                }
              }
              return {
                ...cachedData,
                items: [
                  {
                    uuid: conversationUuid,
                    name: data?.conversationNameUpdatedStreaming,
                    createdAt: data?.createdAt,
                  },
                  ...cachedData.items,
                ],
              }
            },
          )
        },
      })
    },
    [mutationState?.status, sendMessage, queryClient, messageAssets],
  )

  useEffect(() => {
    if (mutationState?.status === 'pending') {
      resetMessageStore()
      resetMessageAssetsStore()
      navigate(`/conversations/${conversationUuid}`, { replace: true })
    }
  }, [
    conversationUuid,
    mutationState?.status,
    navigate,
    resetMessageAssetsStore,
    resetMessageStore,
  ])

  return {
    handleSendMessage,
    messageStreamIsPending: sendMessage?.sendMessageMutation.isPending,
  }
}

function sendAndReceiveMessageOptimisticUpdate({
  cachedData,
  newData,
}: {
  cachedData: ConversationHistoryResponse
  newData?: MessageReadResponse
}) {
  if (cachedData == null && newData == null) {
    return null
  }

  // if there is no cached data, create a new cache item
  if (cachedData == null) {
    return {
      items: [newData],
    }
  }

  // if there is no new data, return the cached data
  if (newData == null) {
    return cachedData
  }

  const existingMessageIndex = cachedData?.items?.findIndex(
    ({ uuid }) => uuid === newData.uuid,
  )
  const copyCached = [...cachedData.items]

  // if the message does not exist, add it to the cache
  if (existingMessageIndex === -1) {
    return {
      ...cachedData,
      items: [...copyCached, newData],
    }
  }
  copyCached[existingMessageIndex] = newData

  // if the message exists, update it
  return {
    ...cachedData,
    items: copyCached,
  }
}

function conversationNameOptimisticUpdate({
  cachedData,
  newData,
}: {
  cachedData: ConversationReadResponse
  newData?: MessageReadResponse
}) {
  if (cachedData == null) {
    return cachedData
  }
  return { ...cachedData, name: newData?.conversationNameUpdatedStreaming }
}

function invalidateConversationQueries(
  queryClient: ReturnType<typeof useQueryClient>,
  conversationUuid: string,
) {
  queryClient.invalidateQueries({
    queryKey: getGetAllConversationsQueryKey(),
  })
  queryClient.invalidateQueries({
    queryKey: getGetConversationHistoryQueryKey(conversationUuid),
  })
  queryClient.invalidateQueries({
    queryKey: getGetConversationByUuidQueryKey(conversationUuid),
  })
  queryClient.invalidateQueries({
    queryKey: getGetAllAssetsQueryKey({ conversationUuid }),
  })
}

export function useHandleSendMessageAndReceiveStreamedResponse() {
  const queryClient = useQueryClient()
  const { abortController, handleStopStream } = useAbortController()
  const { messageAssets, resetMessageAssetsStore } = useMessageAssetsStore()
  const { resetMessageStore } = useMessageStore()
  const sendMessageMutation = useSendMessageAndReceiveStreamedResponse(
    abortController,
    {
      async onMutate({ params, data }) {
        if (params?.conversationUuid == null || data == null) {
          return
        }
        const newMessage: MessageReadResponse = {
          authorName: 'You',
          createdAt: new Date().toISOString(),
          role: 'user',
          status: 'completed',
          type: 'text',
          uuid: crypto.randomUUID(),
          conversationUuid: params?.conversationUuid,
          content: data?.content,
          assets: messageAssets,
          totalCostUsd: 0,
        }
        resetMessageStore()
        resetMessageAssetsStore()
        queryClient.cancelQueries({
          queryKey: getGetConversationHistoryQueryKey(params?.conversationUuid),
        })
        queryClient.setQueryData(
          getGetConversationHistoryQueryKey(params?.conversationUuid),
          (cachedData: ConversationHistoryResponse) =>
            sendAndReceiveMessageOptimisticUpdate({
              cachedData,
              newData: newMessage,
            }),
        )
      },
    },
  )
  const handleSendMessageAndReceiveMessage = useCallback(
    ({
      conversationUuid,
      content,
      messageAssets,
      onSSEMessage,
      onSSEOpen,
      onSuccess,
    }: {
      conversationUuid: string
      content: string
      messageAssets?: AssetReadResponse[]
      onSSEMessage?: ({ data }: { data: MessageReadResponse }) => void
      onSSEOpen?: () => void
      onSuccess?: () => void
    }) => {
      const assetUuids =
        messageAssets != null && messageAssets?.length > 0 ?
          messageAssets?.map(({ uuid }) => uuid)
        : undefined
      sendMessageMutation.mutate(
        {
          url: '/api/message/streaming',
          data: {
            content,
            assetUuids,
          },
          params: {
            conversationUuid,
          },

          async onSSEMessage({ data }) {
            onSSEMessage?.({ data })
            await queryClient.setQueryData(
              getGetConversationHistoryQueryKey(conversationUuid),
              (cachedData: ConversationHistoryResponse) =>
                sendAndReceiveMessageOptimisticUpdate({
                  cachedData,
                  newData: data,
                }),
            )
            await queryClient?.setQueryData(
              getGetConversationByUuidQueryKey(conversationUuid),
              (cachedData: ConversationReadResponse) =>
                conversationNameOptimisticUpdate({ cachedData, newData: data }),
            )
          },
          onSSEClose() {
            invalidateConversationQueries(queryClient, conversationUuid)
          },
          onSSEOpen() {
            onSSEOpen?.()
          },
        },
        {
          onSuccess() {
            onSuccess?.()
          },
        },
      )
    },
    [sendMessageMutation, queryClient],
  )

  return {
    handleSendMessageAndReceiveMessage,
    sendMessageMutation,
    onStopSendMessageStream: handleStopStream,
  }
}

function regenerateMessageOptimisticUpdate({
  cachedData,
  newData,
  messageUuid,
}: {
  cachedData: ConversationHistoryResponse | undefined
  newData: MessageReadResponse
  messageUuid: string
}) {
  if (cachedData == null) {
    return cachedData
  }
  const messageToRegenerateIndex = cachedData?.items.findIndex(
    (m) => m.uuid === messageUuid,
  )
  const copyCachedData = [...cachedData.items]
  const newMessages = copyCachedData.slice(0, messageToRegenerateIndex)
  return { ...cachedData, items: [...newMessages, newData] }
}

export function useHandleRegenerateMessage() {
  const { abortController, handleStopStream } = useAbortController()
  const { resetMessageStore } = useMessageStore()
  const queryClient = useQueryClient()
  const regenerateMutation = useRegenerateMessage(abortController)

  const handleRegenerateMessage = ({
    messageUuid,
    conversationUuid,
  }: {
    messageUuid: string
    conversationUuid: string
  }) => {
    regenerateMutation.mutate(
      {
        url: `/api/message/regenerate/streaming`,
        params: {
          conversationUuid,
          messageUuid,
        },
        async onSSEMessage({ data }) {
          // optimistic update
          await queryClient?.setQueryData(
            getGetConversationHistoryQueryKey(conversationUuid),
            (cachedData: ConversationHistoryResponse) =>
              regenerateMessageOptimisticUpdate({
                cachedData,
                newData: data,
                messageUuid,
              }),
          )
          await queryClient?.setQueryData(
            getGetConversationByUuidQueryKey(conversationUuid),
            (cachedData: ConversationReadResponse) =>
              conversationNameOptimisticUpdate({ cachedData, newData: data }),
          )
        },
      },
      {
        onSuccess() {
          resetMessageStore()
          invalidateConversationQueries(queryClient, conversationUuid)
        },
      },
    )
  }

  return {
    handleRegenerateMessage,
    regenerateMutation,
    onStopRegenerateMessageStream: handleStopStream,
  }
}

function patchUserOptimisticUpdate({
  cachedData,
  newData,
  messageUuid,
}: {
  cachedData: ConversationHistoryResponse | undefined
  newData: MessageReadResponse
  messageUuid: MessageReadResponse['uuid']
}) {
  if (cachedData == null) {
    return newData
  }
  const copyCachedData = [...cachedData.items]
  const messageToEditIndex = copyCachedData?.findIndex(
    (m) => m.uuid === messageUuid,
  )
  const oldMessages = copyCachedData?.slice(0, messageToEditIndex + 1)
  return { ...cachedData, items: [...oldMessages, newData] }
}

export function useHandlePatchMessage() {
  const queryClient = useQueryClient()
  const { abortController, handleStopStream } = useAbortController()
  const patchMessageMutation = usePatchUserMessage(abortController)
  const handlePatchMessage = ({
    payload,
    messageUuid,
    conversationUuid,
    onSSEOpen,
  }: {
    payload: PatchUserMessageMutationBody
    messageUuid: MessageReadResponse['uuid']
    conversationUuid: MessageReadResponse['conversationUuid']
    onSSEOpen?: () => void
  }) => {
    if (messageUuid == null || payload == null) {
      return
    }
    patchMessageMutation.mutate(
      {
        url: `/api/message/${messageUuid}/streaming`,
        data: { ...payload },
        params: { conversationUuid },
        onSSEOpen() {
          onSSEOpen?.()
        },
        async onSSEMessage({ data }) {
          // optimistic update
          await queryClient.setQueryData(
            getGetConversationHistoryQueryKey(conversationUuid),
            (cachedData: ConversationHistoryResponse) =>
              patchUserOptimisticUpdate({
                cachedData,
                newData: data,
                messageUuid,
              }),
          )
          await queryClient.setQueryData(
            getGetConversationByUuidQueryKey(conversationUuid),
            (oldData: ConversationReadResponse) =>
              conversationNameOptimisticUpdate({
                cachedData: oldData,
                newData: data,
              }),
          )
        },
      },
      {
        onSuccess() {
          invalidateConversationQueries(queryClient, conversationUuid)
        },
      },
    )
  }

  return {
    handlePatchMessage,
    patchMessageMutation,
    onStopPatchMessageStream: handleStopStream,
  }
}

export function useMessageContext(): MessageContextType {
  const context = useContext(MessageContext)
  if (!context) {
    throw new Error('useMessageContext must be used within a MessageProvider')
  }
  return context
}

export function useResetMessageStore() {
  const { resetMessageStore } = useMessageStore()

  useEffect(() => {
    resetMessageStore()
  }, [resetMessageStore])
}

export function useConversationAutoScroll({
  containerRef,
  messageLength,
}: {
  containerRef?: React.MutableRefObject<HTMLDivElement | null>
  messageLength: number
}) {
  const isScrolledUp = useDetectScrollUpFromBottom({ containerRef })
  useEffect(() => {
    if (containerRef?.current && !isScrolledUp) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight
    }
  }, [containerRef, isScrolledUp, messageLength])

  return null
}

export function useDetectScrollUpFromBottom({
  containerRef,
}: {
  containerRef?: React.MutableRefObject<HTMLDivElement | null>
}) {
  const [isScrolledUp, setIsScrolledUp] = useState(false)
  const handleScroll = useCallback(() => {
    if (containerRef?.current) {
      setIsScrolledUp(
        containerRef.current.scrollTop + containerRef.current.clientHeight <
          containerRef.current.scrollHeight,
      )
    }
  }, [containerRef])

  useEffect(() => {
    const container = containerRef?.current
    if (container) {
      container.addEventListener('scroll', handleScroll)
    }
    return () => {
      if (container) {
        container.removeEventListener('scroll', handleScroll)
      }
    }
  }, [containerRef, handleScroll])
  return isScrolledUp
}

export function useHandleDeleteConversation(uuid: string) {
  const navigate = useNavigate()
  const match = useMatch({ path: '/conversations/:conversationUuid' })
  const queryClient = useQueryClient()
  const { mutate, isPending } = useDeleteConversation()
  const handleDeleteConversation = (event: React.MouseEvent) => {
    event.preventDefault()
    event.stopPropagation()
    mutate(
      { conversationUuid: uuid },
      {
        onSuccess() {
          queryClient.invalidateQueries({
            queryKey: getGetAllConversationsQueryKey(),
          })

          const isLocatedInConversation =
            match?.params.conversationUuid === uuid

          if (isLocatedInConversation) {
            navigate('/')
          }
        },
      },
    )
  }

  return { handleDeleteConversation, isPending }
}


--- Start of frontend/src/features/conversation/utils.ts ---

import {
  isThisMonth,
  isThisQuarter,
  isThisWeek,
  isThisYear,
  isToday,
  isYesterday,
} from 'date-fns'

import type {
  ConversationReadResponse,
  MessageReadResponse,
} from '@/api/models'

/**
 * Remove duplicate messages from the conversation history
 * @param messages - The current messages
 * @param conversationHistory - The conversation history
 * @returns The deduplicated messages
 */
export function removeDuplicateMessages(
  messages: MessageReadResponse[],
  conversationHistory?: MessageReadResponse[],
) {
  // Combine current messages and conversation history, then deduplicate by uuid
  const messageMap = new Map()

  // First, add all historical messages to the map
  conversationHistory?.forEach((message) => {
    messageMap.set(message.uuid, message)
  })

  // Then, add the current messages, which will overwrite any duplicates
  messages.forEach((message) => {
    messageMap.set(message.uuid, message)
  })

  // Convert the set back to an array and sort by createdAt
  return Array.from(messageMap.values()).sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),
  )
}

/**
 * Group conversations by day
 * @param conversations - The conversations to group
 * @returns The conversations grouped by day
 */

export type DateCategory =
  | 'today'
  | 'yesterday'
  | 'thisWeek'
  | 'lastWeek'
  | 'thisMonth'
  | 'thisQuarter'
  | 'thisYear'
  | 'older'
function isLastWeek(date: Date) {
  return date >= new Date(new Date().setDate(new Date().getDate() - 7))
}

export function groupConversationsByDay(
  conversations?: ConversationReadResponse[],
): Record<DateCategory, ConversationReadResponse[]> | undefined {
  if (!conversations) {
    return undefined
  }

  return conversations.reduce(
    (acc, conversation) => {
      const conversationDate = new Date(conversation?.createdAt)

      let category: DateCategory = 'older'

      if (isToday(conversationDate)) {
        category = 'today'
      } else if (isYesterday(conversationDate)) {
        category = 'yesterday'
      } else if (isThisWeek(conversationDate)) {
        category = 'thisWeek'
      } else if (isLastWeek(conversationDate)) {
        category = 'lastWeek'
      } else if (isThisMonth(conversationDate)) {
        category = 'thisMonth'
      } else if (isThisQuarter(conversationDate)) {
        category = 'thisQuarter'
      } else if (isThisYear(conversationDate)) {
        category = 'thisYear'
      }

      if (!acc[category]) {
        acc[category] = []
      }

      acc[category].push(conversation)
      return acc
    },
    {} as Record<DateCategory, ConversationReadResponse[]>,
  )
}

export function updateMessage(
  messages: MessageReadResponse[],
  newMessage: MessageReadResponse,
) {
  const messageIndex = messages.findIndex(
    (message) => message.uuid === newMessage.uuid,
  )
  if (messageIndex === -1) {
    return [...messages, newMessage]
  }
  const newMessages = [...messages]
  newMessages[messageIndex] = newMessage
  return newMessages
}

export function updateMessageAfterRegenerate(
  messages: MessageReadResponse[],
  newMessage: MessageReadResponse,
  targetUuid?: string,
) {
  const messageIndex =
    messages?.findIndex((message) => message.uuid === targetUuid) ?? 0
  const clonedMessages = [...messages]
  const newItems = clonedMessages?.slice(0, messageIndex)
  return updateMessage(newItems, newMessage)
}


--- Start of frontend/src/features/conversation/context.tsx ---

import { createContext, useMemo } from 'react'

import {
  useHandlePatchMessage,
  useHandleRegenerateMessage,
  useHandleSendMessageAndReceiveStreamedResponse,
} from '@/features/conversation/hooks'

export const MessageContext = createContext<MessageContextType | undefined>(
  undefined,
)

/*
 * These mutations are used throughout the home and conversation routes. The `MessageProvider` wraps the routes that use these mutations.
 * We inject the mutations into the context so that they can be used in the components that are children of the `MessageProvider`.
 * This ensures the mutation state is shared between the components.
 */
export function MessageProvider({ children }: { children: React.ReactNode }) {
  const patchMessage = useHandlePatchMessage()
  const sendMessage = useHandleSendMessageAndReceiveStreamedResponse()
  const regenerateMessage = useHandleRegenerateMessage()

  const value = useMemo(() => {
    return {
      patchMessage,
      sendMessage,
      regenerateMessage,
    }
  }, [patchMessage, sendMessage, regenerateMessage])

  return (
    <MessageContext.Provider value={value}>{children}</MessageContext.Provider>
  )
}

export interface MessageContextType {
  patchMessage: ReturnType<typeof useHandlePatchMessage>
  sendMessage: ReturnType<typeof useHandleSendMessageAndReceiveStreamedResponse>
  regenerateMessage: ReturnType<typeof useHandleRegenerateMessage>
}


--- Start of frontend/src/features/conversation/index.ts ---

import {
  useMessageContext,
  useResetMessageStore,
} from '@/features/conversation/hooks'
import { useConversationStore } from '@/features/conversation/store'
import { removeDuplicateMessages } from '@/features/conversation/utils'

export {
  useConversationStore,
  useMessageContext,
  removeDuplicateMessages,
  useResetMessageStore,
}


--- Start of frontend/src/features/conversation/store.ts ---

import { create } from 'zustand'

import type { AssetCreateError, AssetReadResponse } from '@/api/models'

interface MessageState {
  message: string
  setMessage: (message: string) => void
  resetMessageStore: () => void
}
interface MessageAssetsState {
  messageAssets: AssetReadResponse[]
  messageAssetErrors: AssetCreateError[]
  setMessageAssets: (messageAssetIds: AssetReadResponse[]) => void
  removeMessageAsset: (assetUuid: string) => void
  setMessageAssetErrors: (messageAssetErrors: AssetCreateError[]) => void
  removeMessageAssetError: (originalFilename: string) => void
  resetMessageAssetsStore: () => void
}

interface ConversationState {
  conversationSettingModalOpen: boolean
  setConversationSettingModalOpen: ({ open }: { open: boolean }) => void
}

const useMessageStore = create<MessageState>((set) => ({
  message: '',
  setMessage: (message: string) => set({ message }),
  resetMessageStore: () => set({ message: '' }),
}))

const useMessageAssetsStore = create<MessageAssetsState>((set) => ({
  messageAssets: [],
  messageAssetErrors: [],
  setMessageAssetErrors: (messageAssetErrors: AssetCreateError[]) =>
    set({ messageAssetErrors }),
  removeMessageAssetError: (originalFilename: string) =>
    set(
      (state) => ({
        messageAssetErrors: state.messageAssetErrors.filter(
          (asset) => asset.originalFilename !== originalFilename,
        ),
      }), // Removes the asset by uuid
    ),
  setMessageAssets: (messageAssets: AssetReadResponse[]) =>
    set((state) => ({
      messageAssets: [...state.messageAssets, ...messageAssets],
    })),
  removeMessageAsset: (assetUuid: string) =>
    set(
      (state) => ({
        messageAssets: state.messageAssets.filter(
          (asset) => asset.uuid !== assetUuid,
        ),
      }), // Removes the asset by uuid
    ),
  removeMessageAssets: () => set({ messageAssets: [] }),
  resetMessageAssetsStore: () => set({ messageAssets: [] }),
}))

const useConversationStore = create<ConversationState>((set) => ({
  conversationSettingModalOpen: false,
  setConversationSettingModalOpen: ({ open }: { open: boolean }) =>
    set({ conversationSettingModalOpen: open }),
}))

export { useConversationStore, useMessageStore, useMessageAssetsStore }


--- Start of frontend/src/features/conversation/components/ConversationScrollToBottomButton.tsx ---

import Box from '@mui/joy/Box'
import IconButton from '@mui/joy/IconButton'

import { useDetectScrollUpFromBottom } from '@/features/conversation/hooks'
import { Icon } from '@/components/common'

export function ConversationScrollToBottomButton({
  onClick,
  containerRef,
}: {
  onClick: () => void
  containerRef: React.RefObject<HTMLDivElement>
}) {
  const scrollUpFromBottomDetected = useDetectScrollUpFromBottom({
    containerRef,
  })
  return (
    <Box
      sx={{
        position: 'absolute', // Sticky positioning
        top: -40,
        display: 'flex',
        justifyContent: 'center',
        width: '100%',
        right: 0,
        zIndex: 1,
        opacity: scrollUpFromBottomDetected ? 1 : 0,
      }}
    >
      <IconButton
        onClick={onClick}
        variant="soft"
        color="neutral"
        size="sm"
        sx={{
          borderRadius: '50%',
          border: (theme) => `1px solid ${theme.palette.divider}`,
        }}
      >
        <Icon name="arrowDown" />
      </IconButton>
    </Box>
  )
}


--- Start of frontend/src/features/conversation/components/ConversationTopbar.tsx ---

import { memo } from 'react'

import IconButton from '@mui/joy/IconButton'
import Stack from '@mui/joy/Stack'
import Tooltip from '@mui/joy/Tooltip'

import { useResponsiveAppMode } from '@/shared/configuration'
import { AgentSelectionDropdown } from '@/features/agent/components/AgentSelectionDropdown'
import { useAgentStore } from '@/features/agent/store'
import { useConversationStore } from '@/features/conversation/store'
import { GoBackIconButton, Icon } from '@/components/common'
import { TopNavigation } from '@/components/layout'

export const ConversationTopbar = memo(() => {
  const { isSmallScreen } = useResponsiveAppMode()
  const { setAgentConfigurationSidePanelOpen } = useAgentStore()
  const { setConversationSettingModalOpen } = useConversationStore()

  return (
    <TopNavigation>
      <Stack
        direction="row"
        gap={1}
        flexShrink={1}
        alignItems="center"
        overflow="hidden"
      >
        {isSmallScreen && <GoBackIconButton />}
        <AgentSelectionDropdown />
      </Stack>

      <Stack
        direction="row"
        gap={0.5}
        flex={1}
        justifyContent="flex-end"
        flexShrink={0}
      >
        <Tooltip title="Configuration" arrow variant="soft">
          <IconButton
            size="sm"
            onClick={() =>
              setAgentConfigurationSidePanelOpen({
                open: true,
              })
            }
          >
            <Icon name="config" />
          </IconButton>
        </Tooltip>
        <Tooltip title="Assets" arrow variant="soft">
          <IconButton
            size="sm"
            onClick={() =>
              setConversationSettingModalOpen({
                open: true,
              })
            }
          >
            <Icon name="image" />
          </IconButton>
        </Tooltip>
      </Stack>
    </TopNavigation>
  )
})


--- Start of frontend/src/features/conversation/components/ConversationSettingsForm.tsx ---

import { useForm } from 'react-hook-form'
import { useQueryClient } from '@tanstack/react-query'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import FormControl from '@mui/joy/FormControl'
import FormLabel from '@mui/joy/FormLabel'
import Input from '@mui/joy/Input'
import Skeleton from '@mui/joy/Skeleton'

import type { ConversationReadResponse } from '@/api/models'
import {
  getGetConversationByUuidQueryKey,
  usePatchConversation,
} from '@/api/services/api'
import { ErrorMessage } from '@/components/common'
import { Icon } from '@/components/common/Icon'

interface FormFields {
  name?: string
}
export function ConversationSettingsForm({
  conversation,
  conversationIsLoading,
  conversationIsError,
  conversationError,
}: {
  conversation?: ConversationReadResponse
  conversationIsLoading: boolean
  conversationIsError: boolean
  conversationError?: any
}) {
  const queryClient = useQueryClient()
  const {
    mutate: patchConversation,
    isError: patchConversationIsError,
    error: patchConversationError,
    isPending: patchConversationIsPending,
  } = usePatchConversation()
  const {
    register,
    handleSubmit,
    formState: { isDirty },
  } = useForm<FormFields>({
    defaultValues: { name: '' },
    values: {
      name: conversation?.name,
    },
  })

  const handleUpdateConversation = async (data: FormFields) => {
    if (!conversation) {
      return
    }
    await patchConversation(
      {
        conversationUuid: conversation?.uuid,
        data,
      },
      {
        onSuccess() {
          queryClient.invalidateQueries({
            queryKey: getGetConversationByUuidQueryKey(conversation?.uuid),
          })
        },
      },
    )
  }
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
      {patchConversationIsError || conversationIsError ?
        <ErrorMessage error={patchConversationError || conversationError} />
      : null}
      <FormControl
        sx={{
          justifyContent: 'space-between',
          display: 'flex',
          flexDirection: 'row',
        }}
      >
        <FormLabel sx={{ mb: 0, width: 1 }}>Name</FormLabel>
        {conversationIsLoading ?
          <Skeleton variant="text" />
        : <Input {...register('name')} variant="plain" fullWidth />}
      </FormControl>

      <Box
        sx={{
          display: 'flex',
          flexDirection: 'row',
          gap: 2,
          justifyContent: 'flex-end',
        }}
      >
        <Button
          variant={isDirty ? 'solid' : 'soft'}
          size="sm"
          onClick={handleSubmit(handleUpdateConversation)}
          disabled={!isDirty || patchConversationIsPending}
          loading={patchConversationIsPending}
          color={patchConversationIsError ? 'danger' : 'primary'}
          endDecorator={
            patchConversationIsError ? <Icon name="regenerate" /> : null
          }
        >
          {patchConversationIsError ? 'Retry' : 'Save'}
        </Button>
      </Box>
    </Box>
  )
}


--- Start of frontend/src/features/conversation/components/ConversationSettingsModal.tsx ---

import { useTranslation } from 'react-i18next'
import { useParams } from 'react-router-dom'
import { useQueryClient } from '@tanstack/react-query'

import DialogContent from '@mui/joy/DialogContent'
import DialogTitle from '@mui/joy/DialogTitle'

import {
  getGetAllAssetsQueryKey,
  useCreateAssets,
  useGetAllAssets,
  useGetSupportedExtensions,
} from '@/api/services/api'
import { useConversationStore } from '@/features/conversation'
import { AssetList } from '@/components/common/assets/AssetList'
import { DropzoneInput } from '@/components/interactive/DropzoneInput'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

export function ConversationSettingsModal() {
  const { conversationUuid } = useParams() as { conversationUuid: string }
  const queryClient = useQueryClient()
  const { t } = useTranslation()

  const { conversationSettingModalOpen, setConversationSettingModalOpen } =
    useConversationStore()
  const { data: supportedExtensions } = useGetSupportedExtensions(
    { conversationUuid },
    {
      query: {
        enabled: conversationSettingModalOpen,
      },
    },
  )
  const {
    data: conversationAssets,
    isLoading: conversationAssetsIsLoading,
    isError: conversationAssetsIsError,
    error: conversationAssetsError,
  } = useGetAllAssets(
    { conversationUuid },
    {
      query: {
        enabled: conversationSettingModalOpen,
      },
    },
  )
  const {
    mutate: createAssets,
    isError: createAssetsIsError,
    isPending: createAssetsIsPending,
  } = useCreateAssets()

  const handleUploadFiles = async (files: File[]) => {
    await createAssets(
      {
        data: {
          files,
        },
        params: {
          conversationUuid,
        },
      },
      {
        onSuccess(data) {
          if (!data) {
            return
          }
          queryClient.invalidateQueries({
            queryKey: getGetAllAssetsQueryKey({ conversationUuid }),
          })
        },
      },
    )
  }

  return (
    <ModalDialogBase
      onClose={() => setConversationSettingModalOpen({ open: false })}
      open={conversationSettingModalOpen}
      modalDialogProps={{
        sx: {
          width: '100%',
          maxWidth: 'sm',
        },
      }}
    >
      <DialogTitle>{t('conversation.assetsModal.title')}</DialogTitle>

      <DialogContent sx={{ py: 2, height: '100%', overflowY: 'scroll' }}>
        <DropzoneInput
          onDrop={handleUploadFiles}
          isPending={createAssetsIsPending}
          isError={createAssetsIsError}
          accept={supportedExtensions}
        />
        <AssetList
          assetsIsError={conversationAssetsIsError}
          assetsError={conversationAssetsError}
          assets={conversationAssets?.items ?? []}
          assetsIsLoading={conversationAssetsIsLoading}
        />
      </DialogContent>
    </ModalDialogBase>
  )
}


--- Start of frontend/src/features/conversation/components/ConversationStarterCard.tsx ---

import { memo } from 'react'

import Box from '@mui/joy/Box'
import Card from '@mui/joy/Card'
import Typography from '@mui/joy/Typography'

import type { ConversationStarter } from '@/api/models'
import { useSendInitialMessageAndNavigate } from '@/features/conversation/hooks'
import { Icon } from '@/components/common/Icon'

export const ConversationStarterCard = memo(
  ({
    title,
    description,
    conversationUuid,
    messagePrefill,
  }: Partial<ConversationStarter> & {
    title: string
    description: string
    conversationUuid: string
    messagePrefill: string
  }) => {
    const { handleSendMessage } = useSendInitialMessageAndNavigate({
      conversationUuid,
    })
    return (
      <Card
        size="sm"
        onClick={() =>
          handleSendMessage({ conversationUuid, message: messagePrefill })
        }
        sx={{
          width: 1,
          cursor: 'pointer',
          '&:hover': {
            opacity: 0.8,
          },
        }}
        variant="outlined"
      >
        <Box>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
            mb={1}
          >
            <Typography level="title-sm" textColor="text.primary">
              {title}
            </Typography>
            <Icon size={18} name="arrowUp" />
          </Box>
          <Typography level="body-xs" textColor="text.secondary">
            {description}
          </Typography>
        </Box>
      </Card>
    )
  },
)


--- Start of frontend/src/features/conversation/components/ConversationTable.tsx ---

import { useState, type Dispatch, type SetStateAction } from 'react'
import { useForm } from 'react-hook-form'
import { useNavigate } from 'react-router-dom'
import { useQueryClient } from '@tanstack/react-query'
import { formatDistance } from 'date-fns'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Checkbox from '@mui/joy/Checkbox'
import DialogActions from '@mui/joy/DialogActions'
import DialogContent from '@mui/joy/DialogContent'
import DialogTitle from '@mui/joy/DialogTitle'
import IconButton from '@mui/joy/IconButton'
import Input from '@mui/joy/Input'
import Skeleton from '@mui/joy/Skeleton'
import { useTheme } from '@mui/joy/styles'
import Table from '@mui/joy/Table'
import Typography from '@mui/joy/Typography'

import type { ConversationReadResponse } from '@/api/models'
import {
  getGetAllConversationsQueryKey,
  useDeleteConversation,
  useGetAllConversations,
  usePatchConversation,
} from '@/api/services/api'
import { ErrorMessage } from '@/components/common'
import { Icon } from '@/components/common/Icon'
import { ModalDialogBase } from '@/components/interactive/ModalDialog'

const headCells = [
  {
    id: 'name',
    label: 'Name',
  },
  {
    id: 'createdAt',
    label: 'Created',
  },
  {
    id: 'actions',
    label: 'Actions',
  },
]

export function ConversationTable() {
  const navigate = useNavigate()
  const queryClient = useQueryClient()
  const theme = useTheme()

  const [selectedConversations, setSelectedConversations] = useState<string[]>(
    [],
  )
  const [confirmationModalOpen, setConfirmationModalOpen] = useState(false)

  const { mutateAsync, isPending, isError } = useDeleteConversation()
  const {
    data: conversations,
    isError: conversationsIsError,
    isLoading: conversationsIsLoading,
  } = useGetAllConversations()

  const handleCheckRow = (event: React.MouseEvent<unknown>, uuid: string) => {
    event.stopPropagation()
    event.preventDefault()

    if (uuid === 'all') {
      if (selectedConversations.length === conversations?.items.length) {
        setSelectedConversations([])
      } else {
        setSelectedConversations(
          conversations?.items.map((row) => row.uuid) ?? [],
        )
      }

      return
    }

    const selectedIndex = selectedConversations.indexOf(uuid)
    let newSelected: string[] = []

    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selectedConversations, uuid)
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selectedConversations.slice(1))
    } else if (selectedIndex === selectedConversations.length - 1) {
      newSelected = newSelected.concat(selectedConversations.slice(0, -1))
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(
        selectedConversations.slice(0, selectedIndex),
        selectedConversations.slice(selectedIndex + 1),
      )
    }

    setSelectedConversations(newSelected)
  }

  const handleBatchDeleteConversations = async () => {
    await Promise.all(
      selectedConversations.map((uuid) =>
        mutateAsync(
          { conversationUuid: uuid },
          {
            onSuccess() {
              queryClient.invalidateQueries({
                queryKey: getGetAllConversationsQueryKey(),
              })
            },
          },
        ),
      ),
    )
    setSelectedConversations([])
    setConfirmationModalOpen(false)
  }

  return (
    <Box sx={{ width: '100%', borderRadius: 'sm', py: 2 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', gap: 2 }}>
        <Typography level="body-sm" textColor="text.primary" noWrap>
          {selectedConversations.length > 0 ?
            `${selectedConversations.length} selected`
          : 'Conversations'}
        </Typography>

        <Box display="flex" gap={1} alignItems="center" mb={1}>
          {selectedConversations.length > 0 && (
            <Button
              size="sm"
              sx={{ whiteSpace: 'nowrap' }}
              variant="outlined"
              color="danger"
              loading={isPending}
              onClick={() => setConfirmationModalOpen(true)}
              endDecorator={
                <Icon
                  name={isError ? 'regenerate' : 'delete'}
                  size={16}
                  color="danger"
                />
              }
            >
              {isError ?
                'Retry Delete'
              : `Delete (${selectedConversations?.length ?? 0})`}
            </Button>
          )}
          <Button
            size="sm"
            variant="outlined"
            color="neutral"
            endDecorator={<Icon name="add" size={16} />}
            onClick={() => navigate('/')}
          >
            New
          </Button>
        </Box>
      </Box>
      <Table
        aria-labelledby="tableTitle"
        hoverRow
        sx={{
          '--TableCell-headBackground': 'transparent',
          '& tr > *:nth-of-type(n+4)': { textAlign: 'right' },
        }}
      >
        <thead>
          <tr>
            <th
              style={{
                width: '10%',
                backgroundColor: theme?.palette?.background?.surface,
                overflow: 'hidden',
                textOverflow: 'unset',
              }}
            >
              {conversations?.items && conversations?.items?.length > 0 && (
                <Checkbox
                  indeterminate={
                    selectedConversations.length > 0 &&
                    selectedConversations.length < conversations?.items?.length
                  }
                  onClick={(event) => handleCheckRow(event, 'all')}
                  checked={
                    selectedConversations.length === conversations?.items.length
                  }
                  variant="outlined"
                  slotProps={{
                    input: {
                      'aria-label': 'select all conversations',
                    },
                  }}
                />
              )}
            </th>
            {headCells.map((headCell) => (
              <th key={headCell.id} style={{ verticalAlign: 'baseline' }}>
                {headCell.label}
              </th>
            ))}
          </tr>
        </thead>

        <tbody>
          {conversationsIsLoading ?
            Array.from({ length: headCells.length }).map(() => (
              <tr key={crypto.randomUUID()}>
                <td colSpan={headCells.length + 1}>
                  <Skeleton variant="text" />
                </td>
              </tr>
            ))
          : conversationsIsError ?
            <tr>
              <td colSpan={headCells.length + 1}>
                <ErrorMessage error="Error loading conversations" />
              </td>
            </tr>
          : conversations?.items.map((row) => {
              const isItemSelected = selectedConversations.includes(row.uuid)

              return (
                <ConversationTableRow
                  key={row.uuid}
                  row={row}
                  isItemSelected={isItemSelected}
                  handleCheckRow={handleCheckRow}
                  handleNavigate={() => navigate(`/conversations/${row.uuid}`)}
                  setSelectedConversations={setSelectedConversations}
                  selectedConversations={selectedConversations}
                />
              )
            })
          }
        </tbody>

        <ConversationDeleteConfirmationDialog
          open={confirmationModalOpen}
          onClose={() => setConfirmationModalOpen(false)}
          onConfirm={handleBatchDeleteConversations}
          isPending={isPending}
          title={`Delete ${selectedConversations.length} Conversations`}
          confirmText="Delete"
          cancelText="Cancel"
        />
      </Table>
    </Box>
  )
}

function ConversationTableRow({
  row,
  isItemSelected,
  handleCheckRow,
  handleNavigate,
  setSelectedConversations,
  selectedConversations,
}: {
  row: ConversationReadResponse
  isItemSelected: boolean
  handleCheckRow: (event: React.MouseEvent<unknown>, uuid: string) => void
  handleNavigate: () => void
  setSelectedConversations: Dispatch<SetStateAction<string[]>>
  selectedConversations: string[]
}) {
  const queryClient = useQueryClient()
  const [editMode, setEditMode] = useState(false)

  const { mutate: deleteConversation, isPending: deleteConversationIsPending } =
    useDeleteConversation()
  const { mutate: patchConversation, isPending: patchConversationIsPending } =
    usePatchConversation()

  const form = useForm({
    values: { name: row.name },
  })

  const handleDeleteConversation = (e: React.MouseEvent) => {
    e.stopPropagation()
    deleteConversation(
      { conversationUuid: row.uuid },
      {
        onSuccess() {
          queryClient.invalidateQueries({
            queryKey: getGetAllConversationsQueryKey(),
          })
          setSelectedConversations(
            selectedConversations.filter((uuid) => uuid !== row?.uuid),
          )
        },
      },
    )
  }

  const handleEdit = () => {
    patchConversation(
      {
        conversationUuid: row.uuid,
        data: {
          name: form.getValues('name'),
        },
      },
      {
        onSuccess() {
          queryClient.invalidateQueries({
            queryKey: getGetAllConversationsQueryKey(),
          })
          setEditMode(false)
        },
      },
    )
  }

  return (
    <tr
      role="checkbox"
      aria-checked={isItemSelected}
      tabIndex={-1}
      key={row.uuid}
      onClick={handleNavigate}
      style={
        isItemSelected ?
          ({
            '--TableCell-dataBackground': 'var(--TableCell-selectedBackground)',
            '--TableCell-headBackground': 'var(--TableCell-selectedBackground)',
          } as React.CSSProperties)
        : { cursor: 'pointer' }
      }
    >
      <th
        scope="row"
        onClick={(event) => event.stopPropagation()}
        style={{ overflow: 'hidden', textOverflow: 'unset' }}
      >
        <Checkbox
          onClick={(event) => handleCheckRow(event, row.uuid)}
          checked={isItemSelected}
          sx={{ verticalAlign: 'top' }}
          variant="outlined"
        />
      </th>
      <th
        scope="row"
        style={{ cursor: 'pointer' }}
        onClick={(event) => {
          if (editMode) {
            event.stopPropagation()
          }
        }}
      >
        {editMode ?
          <Input
            size="sm"
            variant="plain"
            {...form.register('name', { min: 1 })}
            onBlur={handleEdit}
            error={form.formState.errors.name != null}
          />
        : <Typography noWrap level="inherit" textColor="text.primary">
            {row.name}
          </Typography>
        }
      </th>
      <td>
        <Typography noWrap level="inherit" textColor="text.primary">
          {formatDistance(new Date(row.createdAt), new Date(), {
            addSuffix: true,
          })}
        </Typography>
      </td>
      <td
        style={{
          textAlign: 'right',
          display: 'flex',
          gap: 2,
          justifyContent: 'flex-end',
          alignItems: 'center',
        }}
      >
        <IconButton
          size="sm"
          loading={patchConversationIsPending}
          onClick={(e) => {
            e.stopPropagation()
            setEditMode(!editMode)
          }}
        >
          <Icon name={editMode ? 'editCancel' : 'edit'} size={16} />
        </IconButton>
        <IconButton
          size="sm"
          onClick={(e) => {
            e.stopPropagation()
            handleDeleteConversation(e)
          }}
          loading={deleteConversationIsPending}
        >
          <Icon name="delete" size={16} />
        </IconButton>
        <IconButton size="sm" onClick={handleNavigate}>
          <Icon name="arrowRight" size={16} />
        </IconButton>
      </td>
    </tr>
  )
}

function ConversationDeleteConfirmationDialog({
  open,
  onClose,
  onConfirm,
  isPending,
  title,
  confirmText,
  cancelText,
}: {
  open: boolean
  onClose: () => void
  onConfirm: () => void
  isPending: boolean
  title?: string
  confirmText?: string
  cancelText?: string
}) {
  return (
    <ModalDialogBase
      open={open}
      onClose={onClose}
      modalDialogProps={{ maxWidth: 'sm' }}
    >
      <DialogTitle>{title}</DialogTitle>

      <DialogContent>
        <Typography level="body-sm" textColor="text.secondary">
          This action cannot be undone.
        </Typography>
      </DialogContent>

      <DialogActions>
        <Button
          size="sm"
          color="danger"
          loading={isPending}
          variant="outlined"
          onClick={onConfirm}
        >
          {confirmText}
        </Button>
        <Button onClick={onClose} size="sm" variant="outlined" color="neutral">
          {cancelText}
        </Button>
      </DialogActions>
    </ModalDialogBase>
  )
}


--- Start of frontend/src/features/conversation/components/ConversationTextarea.tsx ---

import { useCallback } from 'react'
import { useParams } from 'react-router-dom'

import { useGetSupportedExtensions } from '@/api/services/api'
import { useMessageContext } from '@/features/conversation/hooks'
import {
  useMessageAssetsStore,
  useMessageStore,
} from '@/features/conversation/store'
import { Textarea } from '@/components/interactive'

export function ConversationTextarea({
  conversationExists,
}: {
  conversationExists: boolean
}) {
  const { conversationUuid } = useParams()
  const { data: supportedExtenions } = useGetSupportedExtensions(
    { conversationUuid },
    {
      query: {
        enabled: conversationExists,
      },
    },
  )
  const { sendMessage } = useMessageContext()
  const { message, resetMessageStore } = useMessageStore()
  const { messageAssets, resetMessageAssetsStore } = useMessageAssetsStore()

  const handleSendMessage = useCallback(
    (message: string) => {
      if (!conversationUuid) {
        return
      }
      sendMessage?.handleSendMessageAndReceiveMessage({
        conversationUuid,
        content: message,
        messageAssets,
        onSSEOpen() {
          resetMessageStore()
          resetMessageAssetsStore()
        },
      })
    },
    [
      conversationUuid,
      messageAssets,
      resetMessageAssetsStore,
      resetMessageStore,
      sendMessage,
    ],
  )

  return (
    <Textarea
      conversationUuid={conversationUuid}
      supportedExtensions={supportedExtenions}
      onSendMessage={() => handleSendMessage(message)}
    />
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageList.tsx ---

import Box from '@mui/joy/Box'
import Stack from '@mui/joy/Stack'

import {
  useGetAvailableLlmInfos,
  useGetConversationHistory,
  useGetUserProfile,
} from '@/api/services/api'
import { ConversationMessage } from '@/features/conversation/components/conversation-message/ConversationMessage'
import { ConversationMessageSkeleton } from '@/features/conversation/components/conversation-message/ConversationMessageSkeleton'
import { ErrorMessage } from '@/components/common/ErrorMessage'

export function ConversationMessagesListWrapper({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        position: 'relative',
        mb: 2,
      }}
    >
      <Stack spacing={2}>{children}</Stack>
    </Box>
  )
}

export function ConversationMessagesList({
  conversationUuid,
  containerRef,
}: {
  conversationUuid: string
  containerRef: React.RefObject<HTMLDivElement>
}) {
  const { data } = useGetUserProfile({
    query: { staleTime: 1000 * 60 * 5 },
  })
  const { data: availableLlms } = useGetAvailableLlmInfos(
    {},
    {
      query: { staleTime: 1000 * 60 * 5 },
    },
  )
  const {
    data: conversationHistory,
    error: conversationHistoryError,
    isError: conversationHistoryIsError,
    isLoading: conversationHistoryIsLoading,
  } = useGetConversationHistory(conversationUuid, {
    query: {
      staleTime: 1000 * 60 * 5,
      refetchOnMount: false,
    },
  })

  return (
    <ConversationMessagesListWrapper>
      {conversationHistoryIsLoading ?
        <ConversationMessageSkeleton />
      : conversationHistory?.items?.map((message, index) => {
          const llmInfo = availableLlms?.items?.find(
            (llm) => llm.llmModelId === message?.generationMetadata?.llmModelId,
          )
          const isLastMessage = index === conversationHistory.items.length - 1
          return (
            <ConversationMessage
              key={`${message?.uuid}-${message?.authorName}-${message?.createdAt}`}
              userImageUrl={data?.imageUrl}
              modelImageUrl={llmInfo?.provider?.imageUrl ?? undefined}
              isLastMessage={isLastMessage}
              toolsEnabled
              message={message}
              containerRef={containerRef}
            />
          )
        })
      }
      {conversationHistoryIsError && (
        <ErrorMessage error={conversationHistoryError} />
      )}
    </ConversationMessagesListWrapper>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageSkeleton.tsx ---

import Skeleton from '@mui/joy/Skeleton'

import { ConversationMessageBubble } from '@/features/conversation/components/conversation-message/ConversationMessageBubble'
import { ConversationMessageHeader } from '@/features/conversation/components/conversation-message/ConversationMessageHeader'

export function ConversationMessageSkeleton() {
  return (
    <ConversationMessageBubble role="user">
      <ConversationMessageHeader
        authorName="You"
        role="user"
        createdAt={new Date().toISOString()}
        uuid={crypto.randomUUID()}
      />
      <Skeleton variant="text" sx={{ width: '100%' }} />
    </ConversationMessageBubble>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageAvatar.tsx ---

import { AssistantAvatar, UserAvatar } from '@/components/common'

export function ConversationMessageAvatar({
  role,
  userImageUrl,
  modelImageUrl,
  authorName,
}: {
  role: 'assistant' | 'user' | 'system'
  userImageUrl?: string | null
  modelImageUrl?: string
  authorName: string
}) {
  return role === 'user' ?
      <UserAvatar
        size="sm"
        src={userImageUrl ?? undefined}
        authorName={authorName}
      />
    : <AssistantAvatar size="sm" src={modelImageUrl} />
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageHeader.tsx ---

import { memo } from 'react'

import Box from '@mui/joy/Box'
import Stack from '@mui/joy/Stack'
import type { Theme } from '@mui/system'
import useMediaQuery from '@mui/system/useMediaQuery'

import type { MessageReadResponseAgentConfigVersion } from '@/api/models'
import { ConversationMessageAvatar } from '@/features/conversation/components/conversation-message/ConversationMessageAvatar'
import { ConversationMessageTitle } from '@/features/conversation/components/conversation-message/ConversationMessageTitle'
import { ConversationMessageToolbar } from '@/features/conversation/components/conversation-message/ConversationMessageToolbar'

export const ConversationMessageHeader = memo(
  ({
    role,
    authorName,
    userImageUrl,
    modelImageUrl,
    uuid,
    isEditing,
    handleActivateEditTextarea,
    shouldShowToolbar,
    toolsEnabled,
    isLastMessage,
  }: {
    agentConfigVersion?: MessageReadResponseAgentConfigVersion
    role: 'user' | 'assistant'
    authorName: string
    agentName?: string
    createdAt: string
    userImageUrl?: string | null
    modelImageUrl?: string
    uuid: string
    isEditing?: boolean
    handleActivateEditTextarea?: () => void
    shouldShowToolbar?: boolean
    toolsEnabled?: boolean
    isLastMessage?: boolean
  }) => {
    const smUp = useMediaQuery((theme: Theme) => theme?.breakpoints.up('sm'))

    return (
      <Stack
        direction="row"
        justifyContent="space-between"
        alignItems="center"
        gap={4}
      >
        <Box
          sx={{
            display: 'flex',
            gap: 1,
            alignItems: 'center',
            width: '100%',
            overflow: 'hidden',
          }}
        >
          <ConversationMessageAvatar
            role={role}
            userImageUrl={userImageUrl}
            modelImageUrl={modelImageUrl}
            authorName={authorName}
          />
          <ConversationMessageTitle authorName={authorName} />
        </Box>

        {shouldShowToolbar && toolsEnabled && (
          <ConversationMessageToolbar
            messageUuid={uuid}
            role={role}
            disableEdit={isEditing}
            onEditMessage={handleActivateEditTextarea}
            shouldShowToolbar={shouldShowToolbar || isLastMessage || !smUp}
          />
        )}
      </Stack>
    )
  },
)


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageToolbar.tsx ---

import { useParams } from 'react-router-dom'

import { Tooltip } from '@mui/joy'
import IconButton from '@mui/joy/IconButton'
import Stack from '@mui/joy/Stack'

import { useMessageContext } from '@/features/conversation'
import { useFeedbackStore } from '@/features/feedback/store'
import { Icon } from '@/components/common/Icon'

export function ConversationMessageToolbar({
  role,
  messageUuid,
  onEditMessage,
  disableEdit,
  shouldShowToolbar,
}: {
  role: string
  messageUuid: string
  onEditMessage?: () => void
  disableEdit?: boolean
  shouldShowToolbar?: boolean
}) {
  const { conversationUuid } = useParams() as { conversationUuid: string }
  const { setFeedbackModalOpen } = useFeedbackStore()
  const { regenerateMessage } = useMessageContext()

  if (role === 'user') {
    return (
      <Stack
        direction="row"
        position="sticky"
        top={0}
        sx={{ opacity: shouldShowToolbar ? 1 : 0, transition: 'opacity 0.3s' }}
      >
        <Tooltip title="Edit message" arrow variant="soft">
          <IconButton
            size="sm"
            variant="plain"
            onClick={onEditMessage}
            disabled={disableEdit}
            sx={{ opacity: shouldShowToolbar ? 1 : 0 }}
          >
            <Icon name="edit" size={16} />
          </IconButton>
        </Tooltip>
      </Stack>
    )
  }
  return (
    <Stack
      direction="row"
      sx={{ opacity: shouldShowToolbar ? 1 : 0, transition: 'opacity 0.3s' }}
    >
      <Tooltip title="Feedback" arrow variant="soft">
        <IconButton
          size="sm"
          variant="plain"
          onClick={() =>
            setFeedbackModalOpen({
              open: true,
              scope: 'message',
              feedbackTargetUuid: messageUuid,
            })
          }
        >
          <Icon name="thumbsUp" size={16} />
        </IconButton>
      </Tooltip>
      <Tooltip title="Feedback" arrow variant="soft">
        <IconButton
          variant="plain"
          size="sm"
          onClick={() =>
            setFeedbackModalOpen({
              open: true,
              scope: 'message',
              feedbackTargetUuid: messageUuid,
            })
          }
        >
          <Icon name="thumbsDown" size={16} />
        </IconButton>
      </Tooltip>

      <Tooltip title="Regenerate message" arrow variant="soft">
        <IconButton
          variant="plain"
          size="sm"
          disabled={regenerateMessage.regenerateMutation.isPending}
          loading={regenerateMessage.regenerateMutation.isPending}
          onClick={() =>
            regenerateMessage?.handleRegenerateMessage({
              messageUuid,
              conversationUuid,
            })
          }
        >
          <Icon name="regenerate" size={16} />
        </IconButton>
      </Tooltip>
    </Stack>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageContent.tsx ---

import { useState } from 'react'

import Box from '@mui/joy/Box'

import { useResponsiveAppMode } from '@/shared/configuration/hooks'
import type { MessageReadResponse } from '@/api/models'
import { ConversationMessageBubble } from '@/features/conversation/components/conversation-message/ConversationMessageBubble'
import { ConversationMessageEditMode } from '@/features/conversation/components/conversation-message/ConversationMessageEditMode'
import { ConversationMessageHeader } from '@/features/conversation/components/conversation-message/ConversationMessageHeader'
import { MemoizedConversationMessageMarkdownRender } from '@/features/conversation/components/conversation-message/ConversationMessageMarkdownRender'
import { ConversationMessageMetadataAccordionGroup } from '@/features/conversation/components/conversation-message/ConversationMessageMetadata'
import { TypographyWithAnimation } from '@/components/common/TypographyWithAnimation'

export function ConversationMessageContent({
  userImageUrl,
  modelImageUrl,
  isLastMessage = false,
  message,
  shouldShowToolbar,
  toolsEnabled,
}: {
  userImageUrl?: string | null
  modelImageUrl?: string
  isLastMessage?: boolean
  message: MessageReadResponse
  shouldShowToolbar: boolean
  toolsEnabled: boolean
}) {
  const [newContent, setNewContent] = useState<null | string>(null)
  const [isEditing, setIsEditing] = useState(false)
  const { isSmallScreen } = useResponsiveAppMode()

  const {
    authorName,
    agentConfigVersion,
    content,
    createdAt,
    role,
    uuid,
    status,
    generationMetadata,
    toolUseResponse,
    reasoning,
  } = message ?? {}

  const handleActivateEditTextarea = () => {
    setIsEditing(true)
  }

  return (
    <ConversationMessageBubble role={role}>
      <ConversationMessageHeader
        role={role}
        authorName={authorName}
        createdAt={createdAt}
        userImageUrl={userImageUrl}
        modelImageUrl={modelImageUrl}
        uuid={uuid}
        isEditing={isEditing}
        handleActivateEditTextarea={handleActivateEditTextarea}
        shouldShowToolbar={shouldShowToolbar || isSmallScreen}
        toolsEnabled={toolsEnabled}
        isLastMessage={isLastMessage}
        agentConfigVersion={agentConfigVersion}
      />

      {role === 'user' && isEditing ?
        <ConversationMessageEditMode
          uuid={uuid}
          content={content}
          setIsEditing={setIsEditing}
          conversationUuid={message.conversationUuid}
          newContent={newContent}
          setNewContent={setNewContent}
        />
      : status === 'starting' || (status === 'in_progress' && content === '') ?
        <TypographyWithAnimation text="Thinking" />
      : <MemoizedConversationMessageMarkdownRender
          content={newContent ?? content}
        />
      }

      {generationMetadata && role === 'assistant' && (
        <Box sx={{ mt: 1 }}>
          <ConversationMessageMetadataAccordionGroup
            generationMetadata={generationMetadata}
            status={status}
            reasoning={reasoning}
            toolUseResponse={toolUseResponse}
          />
        </Box>
      )}
    </ConversationMessageBubble>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageTitle.tsx ---

import Stack from '@mui/joy/Stack'
import Typography from '@mui/joy/Typography'

import { capitaliseFirstLetter } from '@/shared/utils/capitalise-first-letter'

export function ConversationMessageTitle({
  authorName,
}: {
  authorName?: string
}) {
  return (
    <Stack
      overflow="hidden"
      direction="row"
      maxWidth={1}
      alignItems="center"
      gap={1}
    >
      <Typography
        noWrap
        level="title-sm"
        fontWeight="bold"
        textColor="text.primary"
        maxWidth="100%"
        sx={{ className: 'ph-no-capture' }}
      >
        {authorName ? capitaliseFirstLetter(authorName) : 'Unknown'}
      </Typography>
    </Stack>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageMetadata.tsx ---

import { memo, useState } from 'react'
import { formatDuration } from 'date-fns'

import Accordion from '@mui/joy/Accordion'
import AccordionDetails from '@mui/joy/AccordionDetails'
import AccordionGroup from '@mui/joy/AccordionGroup'
import AccordionSummary from '@mui/joy/AccordionSummary'
import Box from '@mui/joy/Box'
import CircularProgress from '@mui/joy/CircularProgress'
import Typography from '@mui/joy/Typography'

import type {
  MessageReadResponse,
  MessageStatus,
  ToolUseInfo,
  ToolUseStatus,
} from '@/api/models'
import { MemoizedConversationMessageMarkdownRender } from '@/features/conversation/components/conversation-message/ConversationMessageMarkdownRender'
import { ConversationMessageStatusChip } from '@/features/conversation/components/conversation-message/ConversationMessageStatusChip'
import { Icon } from '@/components/common'

const ConversationMessageToolUseDetails = memo(
  ({ title, toolUse }: { title: string; toolUse: ToolUseInfo }) => {
    const [expanded, setExpanded] = useState(false)
    return (
      <Accordion onChange={() => setExpanded(!expanded)} expanded={expanded}>
        <AccordionSummary>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
            width={1}
          >
            <Typography
              level="body-xs"
              textColor="text.primary"
              fontWeight="bold"
              noWrap
            >
              {title}
            </Typography>

            <Typography level="body-xs" textColor="text.secondary" noWrap>
              {toolUse?.durationMs ?
                formatDuration({ seconds: toolUse?.durationMs / 1000 })
              : '-'}
            </Typography>
          </Box>
        </AccordionSummary>
        <AccordionDetails>
          {expanded && (
            <>
              {toolUse ?
                <MemoizedConversationMessageMarkdownRender
                  size="sm"
                  content={`\`\`\`json\n${JSON.stringify(toolUse, null, 2)}\n\`\`\``}
                />
              : <Typography level="body-xs">No data available</Typography>}
            </>
          )}
        </AccordionDetails>
      </Accordion>
    )
  },
)

export const ConversationMessageReasoning = memo(
  ({ reasoning }: { reasoning?: MessageReadResponse['reasoning'] }) => {
    const [expanded, setExpanded] = useState(false)
    if (!reasoning) {
      return null
    }
    return (
      <Accordion onChange={() => setExpanded(!expanded)} expanded={expanded}>
        <AccordionSummary>
          <Typography
            level="body-xs"
            textColor="text.primary"
            fontWeight="bold"
          >
            Reasoning
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          {expanded && reasoning && (
            <MemoizedConversationMessageMarkdownRender
              size="sm"
              content={reasoning}
            />
          )}
        </AccordionDetails>
      </Accordion>
    )
  },
)

export const ConversationMessageMetadata = memo(
  ({
    generationMetadata,
  }: {
    generationMetadata: MessageReadResponse['generationMetadata']
  }) => {
    const [expanded, setExpanded] = useState(false)
    return (
      <Accordion onChange={() => setExpanded(!expanded)} expanded={expanded}>
        <AccordionSummary>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
            width={1}
          >
            <Typography
              level="body-xs"
              textColor="text.primary"
              fontWeight="bold"
              noWrap
            >
              Generation Metadata
            </Typography>

            <Typography level="body-xs" textColor="text.secondary" noWrap>
              {generationMetadata?.durationMs ?
                formatDuration({
                  seconds: generationMetadata?.durationMs / 1000,
                })
              : '-'}
            </Typography>
          </Box>
        </AccordionSummary>
        <AccordionDetails>
          {expanded && (
            <MemoizedConversationMessageMarkdownRender
              size="sm"
              content={`\`\`\`json\n${JSON.stringify(generationMetadata, null, 2)}\n\`\`\``}
            />
          )}
        </AccordionDetails>
      </Accordion>
    )
  },
)

export const ConversationMessageMetadataAccordionGroup = memo(
  ({
    generationMetadata,
    status,
    reasoning,
    toolUseResponse,
  }: {
    generationMetadata: MessageReadResponse['generationMetadata']
    reasoning?: MessageReadResponse['reasoning']
    status: MessageReadResponse['status']
    toolUseResponse: MessageReadResponse['toolUseResponse']
  }) => {
    const [expanded, setExpanded] = useState(false)
    return (
      <AccordionGroup size="sm" disableDivider>
        <Accordion
          onChange={() => setExpanded(!expanded)}
          expanded={expanded}
          sx={{ px: 0 }}
          variant="plain"
        >
          <AccordionSummary>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              width={1}
            >
              <ConversationMessageStatusChip
                status={status}
                toolUseResponse={toolUseResponse}
              />
            </Box>
          </AccordionSummary>
          <AccordionDetails>
            <AccordionGroup disableDivider>
              <ConversationMessageMetadata
                generationMetadata={generationMetadata}
              />
              {toolUseResponse &&
                toolUseResponse?.toolUseInfos?.map((toolUse) => {
                  return (
                    <ConversationMessageToolUseDetails
                      key={toolUse.displayName}
                      title={toolUse.displayName}
                      toolUse={toolUse}
                    />
                  )
                })}
              <ConversationMessageReasoning reasoning={reasoning} />
            </AccordionGroup>
          </AccordionDetails>
        </Accordion>
      </AccordionGroup>
    )
  },
)

export function ProgressIndicator({
  status,
}: {
  status?: ToolUseStatus | MessageStatus
}) {
  if (!status) {
    return null
  }
  if (status === 'completed') {
    return <Icon name="checkCircle" color="success" />
  }
  if (status === 'failed') {
    return <Icon name="crossCircle" color="danger" />
  }
  const showProgress =
    status === 'in_progress' || status === 'pending' || status === 'retrying'
  if (showProgress) {
    return (
      <CircularProgress
        color="primary"
        sx={{
          '--CircularProgress-size': '12px',
          '--CircularProgress-thickness': '2px',
        }}
      />
    )
  }

  return null
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageCodeblock.tsx ---

import { memo, useMemo } from 'react'
import SyntaxHighlighter from 'react-syntax-highlighter'

import Box from '@mui/joy/Box'
import Typography from '@mui/joy/Typography'

import { CopyButton } from '@/features/conversation/components/conversation-message/ConversationMessageCopyButton'

const DEFAULT_LANGUAGE = 'plaintext'

const ConversationMessageCodeHeader = memo(
  ({
    language,
    content,
    bgColor,
  }: {
    language: string
    content: string
    bgColor: string
  }) => (
    <Box
      bgcolor={bgColor}
      p={2}
      display="flex"
      justifyContent="space-between"
      alignItems="center"
      sx={{
        borderTopLeftRadius: '8px',
        borderTopRightRadius: '8px',
        borderBottom: (theme) => `1px solid ${theme.palette.divider}`,
      }}
    >
      <Typography level="body-sm" textColor="text.primary">
        {language}
      </Typography>
      <CopyButton text={content} />
    </Box>
  ),
)

ConversationMessageCodeHeader.displayName = 'CodeHeader'
export function ConversationMessageCodeblock({
  bgColor,
  syntaxStyle,
  children,
  className,
  node,
  ref,
  size = 'md',
  ...rest
}: {
  bgColor: string
  syntaxStyle: any
  children: React.ReactNode
  className?: string
  node: any
  ref: any
  size?: 'sm' | 'md'
}) {
  const content = String(children).replace(/\n$/, '')
  const language = className?.match(/language-(\w+)/)?.[1] || DEFAULT_LANGUAGE
  const isInlineCode = content.split('\n').length === 1

  const styles = useMemo(
    () => ({
      inline: {
        padding: '0.15rem 0.5rem',
        borderRadius: '4px',
        display: 'inline',
        backgroundColor: bgColor,
        fontSize: size === 'sm' ? '0.75rem' : '0.875rem',
      },
      block: {
        padding: '1rem',
        borderBottomLeftRadius: '8px',
        borderBottomRightRadius: '8px',
        backgroundColor: bgColor,
        marginTop: 0,
        fontSize: size === 'sm' ? '0.75rem' : '0.875rem',
      },
    }),
    [bgColor, size],
  )

  if (isInlineCode) {
    return (
      <SyntaxHighlighter
        {...rest}
        style={syntaxStyle}
        customStyle={styles.inline}
      >
        {content}
      </SyntaxHighlighter>
    )
  }

  return (
    <span style={{ borderRadius: '8px' }}>
      <ConversationMessageCodeHeader
        content={content}
        language={language}
        bgColor={bgColor}
      />
      <SyntaxHighlighter
        {...rest}
        language={language}
        style={syntaxStyle}
        customStyle={styles.block}
      >
        {content}
      </SyntaxHighlighter>
    </span>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageAssetList.tsx ---

import Stack from '@mui/joy/Stack'

import type { MessageReadResponse } from '@/api/models'
import { Asset } from '@/components/common/assets/Asset'

export function ConversationMessageAssetList({
  assets,
}: {
  assets: MessageReadResponse['assets']
}) {
  if (!assets || assets.length === 0) {
    return null
  }
  return (
    <Stack
      direction={{ xs: 'column', sm: 'row' }}
      gap={0.5}
      display="flex"
      flexWrap="wrap"
    >
      {assets
        ?.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),
        )
        .map((asset) => {
          if (!asset.sourceUrl) {
            return null
          }
          return <Asset key={asset.uuid} asset={asset} />
        })}
    </Stack>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageMarkdownRender.tsx ---

import { memo, useMemo, type ClassAttributes, type HTMLAttributes } from 'react'
import ReactMarkdown, { type ExtraProps } from 'react-markdown'
import {
  a11yDark,
  a11yLight,
} from 'react-syntax-highlighter/dist/esm/styles/hljs'
import remarkGfm from 'remark-gfm'

import Link from '@mui/joy/Link'
import List from '@mui/joy/List'
import ListItem from '@mui/joy/ListItem'
import { useTheme } from '@mui/joy/styles'
import Table from '@mui/joy/Table'
import Typography from '@mui/joy/Typography'

import { ConversationMessageCodeblock } from '@/features/conversation/components/conversation-message/ConversationMessageCodeblock'

type Props = ClassAttributes<HTMLElement> &
  HTMLAttributes<HTMLElement> &
  ExtraProps
type AnchorProps = ClassAttributes<HTMLAnchorElement> &
  React.AnchorHTMLAttributes<HTMLAnchorElement> &
  ExtraProps
export function MessageMarkdownRender({
  content,
  size = 'md',
}: {
  content: string
  size?: 'sm' | 'md'
}) {
  const theme = useTheme()
  const syntaxStyle = useMemo(
    () => (theme.palette.mode === 'dark' ? a11yDark : a11yLight),
    [theme.palette.mode],
  )

  const components = useMemo(
    () => ({
      caption: ({ children }: Props) => (
        <Typography level="body-xs" textColor="text.secondary">
          {children}
        </Typography>
      ),
      b: ({ children }: Props) => (
        <Typography
          component="span"
          level="body-md"
          fontWeight="bold"
          textColor="text.primary"
        >
          {children}
        </Typography>
      ),
      strong: ({ children }: Props) => (
        <Typography
          component="span"
          level="body-md"
          fontWeight="bold"
          textColor="text.primary"
        >
          {children}
        </Typography>
      ),
      p: ({ children }: Props) => (
        <Typography
          component="span"
          level={size === 'sm' ? 'body-xs' : 'body-md'}
          textColor="text.primary"
          sx={{ wordBreak: 'break-word' }}
        >
          {children}
        </Typography>
      ),
      h1: ({ children }: Props) => (
        <Typography component="h1" level="h1" textColor="text.primary">
          {children}
        </Typography>
      ),
      h2: ({ children }: Props) => (
        <Typography component="h2" level="h2" textColor="text.primary">
          {children}
        </Typography>
      ),
      h3: ({ children }: Props) => (
        <Typography component="h3" level="h3" textColor="text.primary">
          {children}
        </Typography>
      ),
      h4: ({ children }: Props) => (
        <Typography component="h4" level="h4" textColor="text.primary">
          {children}
        </Typography>
      ),
      h5: ({ children }: Props) => (
        <Typography component="h5" level="title-lg" textColor="text.primary">
          {children}
        </Typography>
      ),
      h6: ({ children }: Props) => (
        <Typography component="h6" level="title-md" textColor="text.primary">
          {children}
        </Typography>
      ),
      a: ({ children, href }: AnchorProps) => (
        <Link href={href} target="_blank" color="neutral">
          {children}
        </Link>
      ),
      li: ({ children }: Props) => <ListItem>{children}</ListItem>,
      ol: ({ children }: Props) => <List marker="decimal">{children}</List>,
      ul: ({ children }: Props) => <List marker="disc">{children}</List>,
      table: ({ children }: Props) => (
        <Table
          size="sm"
          variant="outlined"
          sx={{
            '& th, & thead, & span': {
              fontSize: (theme) => theme.fontSize.xs,
            },
          }}
        >
          {children}
        </Table>
      ),
      code: ({ node, className, children, ...props }: Props) => (
        <ConversationMessageCodeblock
          bgColor={theme.palette.background.surface}
          syntaxStyle={syntaxStyle}
          className={className}
          node={node}
          ref={props.ref}
          size={size}
        >
          {children}
        </ConversationMessageCodeblock>
      ),
    }),
    [size, syntaxStyle, theme.palette],
  )

  return (
    <ReactMarkdown
      className="ph-no-capture"
      remarkPlugins={[remarkGfm]}
      components={components}
    >
      {content}
    </ReactMarkdown>
  )
}

// Memoized export
export const MemoizedConversationMessageMarkdownRender = memo(
  MessageMarkdownRender,
)


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageCopyButton.tsx ---

import { useState, type FC } from 'react'

import Button from '@mui/joy/Button'
import Typography from '@mui/joy/Typography'

import { Icon } from '@/components/common/Icon'

export const CopyButton: FC<{ text: string }> = ({ text }) => {
  const [copied, setCopied] = useState(false)

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(String(text))
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (err) {
      console.error('Failed to copy:', err)
    }
  }

  return (
    <Button
      size="sm"
      variant="plain"
      color="neutral"
      onClick={handleCopy}
      startDecorator={<Icon name={copied ? 'check' : 'copy'} />}
    >
      <Typography level="body-xs" textColor="text.primary">
        {copied ? 'Copied' : 'Copy'}
      </Typography>
    </Button>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessage.tsx ---

import { memo, useState } from 'react'

import Stack from '@mui/joy/Stack'

import type { MessageReadResponse } from '@/api/models'
import { ConversationMessageAssetList } from '@/features/conversation/components/conversation-message/ConversationMessageAssetList'
import { ConversationMessageContent } from '@/features/conversation/components/conversation-message/ConversationMessageContent'
import { useConversationAutoScroll } from '@/features/conversation/hooks'

export const ConversationMessage = memo(
  ({
    userImageUrl,
    modelImageUrl,
    isLastMessage = false,
    message,
    toolsEnabled,
    containerRef,
  }: {
    userImageUrl?: string | null
    modelImageUrl?: string
    isLastMessage?: boolean
    message: MessageReadResponse
    toolsEnabled: boolean
    containerRef?: React.RefObject<HTMLDivElement>
  }) => {
    const [mouseEnter, setMouseEnter] = useState(false)
    useConversationAutoScroll({
      containerRef,
      messageLength: message?.content?.length,
    })
    return (
      <Stack
        component="article"
        spacing={0.5}
        width={1}
        onMouseEnter={() => setMouseEnter(true)}
        onMouseLeave={() => setMouseEnter(false)}
      >
        <ConversationMessageContent
          userImageUrl={userImageUrl}
          modelImageUrl={modelImageUrl}
          isLastMessage={isLastMessage}
          message={message}
          shouldShowToolbar={mouseEnter}
          toolsEnabled={toolsEnabled}
        />
        <ConversationMessageAssetList assets={message.assets} />
      </Stack>
    )
  },
)


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageBubble.tsx ---

import Box from '@mui/joy/Box'

export function ConversationMessageBubble({
  children,
  role,
}: {
  children: React.ReactNode
  role: 'user' | 'assistant'
}) {
  return (
    <Box
      sx={{
        backgroundColor: (theme) =>
          role === 'user' ?
            theme.palette.background.body
          : theme.palette.background.level1,
        borderRadius: 8,
        display: 'flex',
        flexDirection: 'column',
        width: 1,
        p: 2,
        gap: 2,
      }}
    >
      {children}
    </Box>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageEditMode.tsx ---

import { FormControl, FormHelperText } from '@mui/joy'
import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Textarea from '@mui/joy/Textarea'

import { useListenForKeyAndCallback } from '@/shared/hooks'
import { useMessageContext } from '@/features/conversation/hooks'

export function ConversationMessageEditMode({
  uuid,
  conversationUuid,
  content,
  setIsEditing,
  newContent,
  setNewContent,
}: {
  uuid: string
  conversationUuid: string
  content: string | null
  setIsEditing: (isEditing: boolean) => void
  newContent: string | null
  setNewContent: (newContent: string | null) => void
}) {
  const { patchMessage } = useMessageContext()

  const handleCancelEdit = () => {
    setIsEditing(false)
    setNewContent(null)
  }
  const handleEditMessage = () => {
    const canPatch = !content || !newContent
    if (canPatch) {
      return
    }
    patchMessage.handlePatchMessage?.({
      payload: {
        content: newContent,
      },
      messageUuid: uuid,
      conversationUuid,
      onSSEOpen() {
        setIsEditing(false)
      },
    })
  }

  useListenForKeyAndCallback({
    handkleKeyDown(e) {
      if (e.key === 'Escape') {
        e.preventDefault()
        handleCancelEdit()
      }
    },
  })
  return (
    <FormControl>
      <Textarea
        error={patchMessage?.patchMessageMutation.isError}
        value={newContent ?? content ?? ''}
        onChange={(e) => setNewContent(e.target.value)}
        variant="soft"
        sx={{
          width: '100%',
        }}
        endDecorator={
          <Box
            sx={{
              display: 'flex',
              gap: 1,
              justifyContent: 'flex-end',
              width: 1,
            }}
          >
            <Button
              size="sm"
              variant="soft"
              color="neutral"
              onClick={handleCancelEdit}
            >
              Cancel
            </Button>
            <Button
              size="sm"
              disabled={
                patchMessage?.patchMessageMutation.isPending || !newContent
              }
              variant="outlined"
              color="neutral"
              loading={patchMessage?.patchMessageMutation.isPending}
              onClick={handleEditMessage}
            >
              Confirm
            </Button>
          </Box>
        }
      />
      {patchMessage?.patchMessageMutation.isError && (
        <FormHelperText>
          Something went wrong while editing the message
        </FormHelperText>
      )}
    </FormControl>
  )
}


--- Start of frontend/src/features/conversation/components/conversation-message/ConversationMessageStatusChip.tsx ---

import { useTranslation } from 'react-i18next'

import Chip from '@mui/joy/Chip'

import type { MessageReadResponse } from '@/api/models'
import { ProgressIndicator } from '@/features/conversation/components/conversation-message/ConversationMessageMetadata'
import { Icon } from '@/components/common'

export function ConversationMessageStatusChip({
  status,
  toolUseResponse,
}: {
  status: MessageReadResponse['status']
  toolUseResponse?: MessageReadResponse['toolUseResponse']
}) {
  const { t } = useTranslation()
  const toolUseInProgress =
    toolUseResponse?.toolUseInfos &&
    toolUseResponse?.toolUseInfos?.filter((i) => i.status === 'in_progress')
      ?.length > 0
  return (
    <Chip
      variant="outlined"
      color="neutral"
      size="sm"
      startDecorator={<ProgressIndicator status={status} />}
      endDecorator={toolUseInProgress ? <Icon name="tool" /> : undefined}
    >
      {toolUseInProgress ?
        `Using ${toolUseResponse?.toolUseInfos?.map((toolUse) => toolUse.displayName).join(', ')}`
      : t(`conversation.message.status.${status}`)}
    </Chip>
  )
}


--- Start of frontend/src/features/router/routes.tsx ---

import { lazy, Suspense } from 'react'
import { Outlet, type RouteObject } from 'react-router-dom'

import { MessageProvider } from '@/features/conversation/context'
import { AuthenticatedLayout, PublicLayout } from '@/features/layouts'
import { RouteLoading } from '@/features/router/components/RouteLoading'
import { RouteNotFound } from '@/features/router/components/RouteNotFound'
import { ErrorMessage } from '@/components/common'
import { SplashScreen } from '@/components/layout'
import { ErrorContainer } from '@/components/layout/ErrorContainer'

export const LoginPage = lazy(() =>
  import('@/pages/login').then((module) => ({ default: module.LoginPage })),
)
export const RegisterPage = lazy(() =>
  import('@/pages/register').then((module) => ({
    default: module.RegisterPage,
  })),
)
export const HomePage = lazy(() =>
  import('@/pages/home').then((module) => ({ default: module.HomePage })),
)
export const ConversationsPage = lazy(() =>
  import('@/pages/conversations').then((module) => ({
    default: module.ConversationsPage,
  })),
)
export const ConversationPage = lazy(() =>
  import('@/pages/conversation').then((module) => ({
    default: module.ConversationPage,
  })),
)

const routePath = {
  login: '/login',
  register: '/register',
  root: '/',
  conversations: '/conversations',
  conversation: '/conversations/:conversationUuid',
  catchAll: '*',
}

// eslint-disable-next-line react-refresh/only-export-components
export const routes: RouteObject[] = [
  {
    path: '/',
    element: (
      <Suspense fallback={<SplashScreen />}>
        <PublicLayout />
      </Suspense>
    ),
    children: [
      {
        path: routePath?.login,
        element: <LoginPage />,
      },
      {
        path: routePath?.register,
        element: <RegisterPage />,
      },
      {
        path: routePath.catchAll,
        element: <RouteNotFound />,
      },
    ],
    errorElement: (
      <ErrorContainer>
        <ErrorMessage error="Caught an error while loading a public page" />
      </ErrorContainer>
    ),
  },
  {
    path: routePath?.root,
    element: (
      <Suspense fallback={<SplashScreen />}>
        <AuthenticatedLayout />
      </Suspense>
    ),
    children: [
      {
        path: routePath.root,
        element: (
          <MessageProvider>
            <Outlet />
          </MessageProvider>
        ),
        children: [
          {
            index: true,
            path: '/',
            element: (
              <Suspense fallback={<RouteLoading />}>
                <HomePage />
              </Suspense>
            ),
          },
          {
            path: routePath.conversation,
            element: (
              <Suspense fallback={<RouteLoading />}>
                <ConversationPage />
              </Suspense>
            ),
          },
        ],
      },
      {
        path: routePath.conversations,
        element: (
          <Suspense fallback={<RouteLoading />}>
            <ConversationsPage />
          </Suspense>
        ),
      },
      {
        path: routePath.catchAll,
        element: <RouteNotFound />,
      }, // Catch-all for unknown authenticated routes
    ],
    errorElement: (
      <ErrorContainer>
        <ErrorMessage error="Caught an error while loading an authenticated page. This is likely a developer error. Check the console for more information." />
      </ErrorContainer>
    ),
  },
]


--- Start of frontend/src/features/router/context.tsx ---

import {
  createBrowserRouter,
  createMemoryRouter,
  RouterProvider,
} from 'react-router-dom'

import { useAppConfiguration } from '@/shared/configuration'
import { RouteNotFound } from '@/features/router/components/RouteNotFound'
import { routes } from '@/features/router/routes'

const browserRouter = createBrowserRouter(routes)
const memoryRouter = createMemoryRouter(routes) // used for widget mode (so we don't change the URL)

export function Router() {
  const { appMode } = useAppConfiguration()
  return (
    <RouterProvider
      fallbackElement={<RouteNotFound />}
      router={appMode === 'standalone' ? browserRouter : memoryRouter}
    />
  )
}


--- Start of frontend/src/features/router/index.ts ---

import { Router } from '@/features/router/context'

export { Router }


--- Start of frontend/src/features/router/components/RouteNotFound.tsx ---

import { useNavigate } from 'react-router-dom'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Typography from '@mui/joy/Typography'

export function RouteNotFound() {
  const navigate = useNavigate()
  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      height="100%"
      flexDirection="column"
      gap={2}
    >
      <Typography level="title-lg">404 - Route Not Found</Typography>
      <Button onClick={() => navigate('/')}>Go Home</Button>
    </Box>
  )
}


--- Start of frontend/src/features/router/components/RouteLoading.tsx ---

import Box from '@mui/joy/Box'
import CircularProgress from '@mui/joy/CircularProgress'

export function RouteLoading() {
  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      height="100%"
    >
      <CircularProgress size="sm" />
    </Box>
  )
}


--- Start of frontend/src/shared/i18n.ts ---

import { initReactI18next } from 'react-i18next'
import i18n from 'i18next'
import Fetch from 'i18next-fetch-backend'

import { captureException } from '@/shared/analytics/utils'

/*
 * This function initializes the i18n instance with the Fetch backend.
 * It loads the translations from the translations.json file in /public.
 */
export async function initializeTranslations() {
  await i18n
    .use(Fetch)
    .use(initReactI18next)
    .init(
      {
        backend: {
          loadPath: '/translations.json',
          parse: (data: any) => {
            return JSON.parse(data)
          },
        },
        lng: 'en',
        fallbackLng: 'en',
      },
      (err) => {
        if (err) {
          captureException(`Error initializing i18n: ${err}`)
        }
      },
    )
}


--- Start of frontend/src/shared/hooks.ts ---

import { useEffect, useState } from 'react'

import { captureException } from '@/shared/analytics/utils'
import {
  getLocalStorageItem,
  setLocalStorageItem,
  type ValidStorageKeys,
} from '@/shared/utils/local-storage'

export function useListenForKeyAndCallback({
  handkleKeyDown,
}: {
  handkleKeyDown: (e: KeyboardEvent) => void
}) {
  if (!handkleKeyDown) {
    throw new Error('useListenForKey requires an handkleKeyDown, callback')
  }

  useEffect(() => {
    window.addEventListener('keydown', handkleKeyDown)
    return () => window.removeEventListener('keydown', handkleKeyDown)
  }, [handkleKeyDown])
}

export function useLocalStorage(key: ValidStorageKeys, initialValue: any) {
  const [storedValue, setStoredValue] = useState(() => {
    if (typeof window === 'undefined') {
      return initialValue
    }
    try {
      const item = getLocalStorageItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(error)
      return initialValue
    }
  })

  const setValue = (value: any) => {
    try {
      setStoredValue(value)

      if (typeof window !== 'undefined') {
        setLocalStorageItem(key, JSON.stringify(value))
      }
    } catch (error) {
      console.error(error)
    }
  }
  return [storedValue, setValue]
}

export function useHandleDownloadToBrowser() {
  const [status, setStatus] = useState<
    'success' | 'isError' | 'loading' | 'idle'
  >('idle')
  const [error, setError] = useState<any>(null)
  const handleDownloadToBrowser = async ({
    sourceUrl,
    name,
  }: {
    sourceUrl?: string
    name?: string
  }) => {
    if (sourceUrl == null) {
      return
    }

    try {
      setStatus('loading')
      const response = await fetch(sourceUrl, {
        credentials: 'include',
        method: 'GET',
        headers: {
          'Content-Type': 'application/octet-stream',
        },
      })
      setStatus('success')

      const blob = await response.blob()
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = name ?? 'asset'
      document.body.appendChild(a)
      a.click()
      window.URL.revokeObjectURL(url)
    } catch (err) {
      setStatus('isError')
      setError(err)
      captureException(`Failed to download asset: ${err}`)
    }
  }
  return { handleDownloadToBrowser, status, error }
}


--- Start of frontend/src/shared/store.ts ---

import { create } from 'zustand'

interface GlobalStore {
  isWidgetOpen: boolean
  setIsWidgetOpen: (isOpen: boolean) => void
  sidebarCollapsed: boolean
  setSidebarCollapsed: (collapsed: boolean) => void
}
const useGlobalStore = create<GlobalStore>((set) => ({
  isWidgetOpen: false,
  setIsWidgetOpen: (isOpen) => set({ isWidgetOpen: isOpen }),
  sidebarCollapsed: false,
  setSidebarCollapsed: (collapsed) => set({ sidebarCollapsed: collapsed }),
}))

export { useGlobalStore }


--- Start of frontend/src/shared/configuration/constants.ts ---

export interface AppConfiguration {
  authRedirect: string
  enableSSOAuthentication: boolean
  appMode: 'widget' | 'standalone'
  language: 'en'
  enableReactQueryDevtools: boolean
  widgetContainerId: string
  standaloneContainerId: string
  /**
   * Used to find icons in the and make the theme aware.
   * @see https://mui.com/joy-ui/integrations/icon-libraries/#third-party-icons
   */
  iconCssSelector: string
  defaultMode: 'dark' | 'light' | 'system'
  cssVarPrefix: string
  topBarHeight?: number
  bottomBarHeight?: number
  widgetWidth?: number
  widgetHeight?: number // could validate with zod
  widgetPlacement: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
  widgetButtonWidth?: number
  widgetButtonHeight?: number
  /**
   * Adds an introductory alert to the chat widget.
   * @default true
   */
  enableIntroductoryNotification?: boolean
  primaryColor: string
  darkBodyColor: string
  darkSurfaceColor: string
  darkLevel1Color: string
  darkLevel2Color: string
  darkLevel3Color: string
  darkPopupColor: string
  darkTooltipColor: string
  darkBackdropColor: string
  darkTextPrimary: string
  darkTextSecondary: string
  darkTextIcon: string
  darkTextTertiary: string
  lightBodyColor: string
  lightSurfaceColor: string
  lightLevel1Color: string
  lightLevel2Color: string
  lightLevel3Color: string
  lightPopupColor: string
  lightTooltipColor: string
  lightBackdropColor: string
  lightTextPrimary: string
  lightTextSecondary: string
  lightTextIcon: string
  lightTextTertiary: string
}

export const defaultAppConfiguration: AppConfiguration = {
  authRedirect: '/login',
  enableSSOAuthentication: true,
  appMode: 'standalone',
  language: 'en',
  enableReactQueryDevtools: true,
  widgetContainerId: 'chat-widget-container',
  standaloneContainerId: 'chat-standalone-container',
  iconCssSelector: '.lucide',
  defaultMode: 'dark',
  cssVarPrefix: 'tribe-chat',

  // dimensions
  topBarHeight: 65,
  bottomBarHeight: 65,
  widgetWidth: 400,
  widgetHeight: 700,
  widgetPlacement: 'bottom-right',
  widgetButtonWidth: 56,
  widgetButtonHeight: 56,

  // features
  enableIntroductoryNotification: true,

  // colors
  primaryColor: '#774CAF',
  darkBodyColor: '#191A1A',
  darkSurfaceColor: '#202222',
  darkLevel1Color: '#2B2C2C',
  darkLevel2Color: '#313333',
  darkLevel3Color: '#3B3C3C',
  darkPopupColor: '#2B2C2C',
  darkTooltipColor: '#2B2C2C',
  darkBackdropColor: 'rgba(0, 0, 0, 0.5)',
  darkTextPrimary: '#FFFFFF',
  darkTextSecondary: '#8C9191',
  darkTextIcon: '#FFFFFF',
  darkTextTertiary: '#8C9191',
  lightBodyColor: '#FFFFFF',
  lightSurfaceColor: '#F6F6F6',
  lightLevel1Color: '#F0F0F0',
  lightLevel2Color: '#EAEAEA',
  lightLevel3Color: '#E0E0E0',
  lightPopupColor: '#FFFFFF',
  lightTooltipColor: '#FFFFFF',
  lightBackdropColor: 'rgba(0, 0, 0, 0.5)',
  lightTextPrimary: '#000000',
  lightTextSecondary: '#8C9191',
  lightTextIcon: '#000000',
  lightTextTertiary: '#8C9191',
}

export const buttonPlacement: Record<
  (typeof defaultAppConfiguration)['widgetPlacement'],
  Record<string, number>
> = {
  'top-left': { top: 16, left: 16 },
  'top-right': { top: 16, right: 16 },
  'bottom-left': { bottom: 16, left: 16 },
  'bottom-right': { bottom: 16, right: 16 },
}
// places the widget container relative to the button (plus 32 pixels for padding)
export const placement: Record<
  (typeof defaultAppConfiguration)['widgetPlacement'],
  Record<string, number>
> = {
  'top-left': {
    top: (defaultAppConfiguration?.widgetButtonHeight ?? 56) + 32,
    left: 16,
  },
  'top-right': {
    top: (defaultAppConfiguration?.widgetButtonHeight ?? 56) + 32,
    right: 16,
  },
  'bottom-left': {
    bottom: (defaultAppConfiguration?.widgetButtonHeight ?? 56) + 32,
    left: 16,
  },
  'bottom-right': {
    bottom: (defaultAppConfiguration?.widgetButtonHeight ?? 56) + 32,
    right: 16,
  },
}


--- Start of frontend/src/shared/configuration/context.tsx ---

import { createContext, useMemo, type ReactNode } from 'react'

import {
  defaultAppConfiguration,
  type AppConfiguration,
} from '@/shared/configuration/constants'

export const AppConfigurationContext = createContext<AppConfiguration | null>(
  null,
)

export function AppConfigurationProvider({
  appConfiguration,
  children,
}: {
  appConfiguration?: AppConfiguration
  children: ReactNode
}) {
  const mergedAppConfiguration = useMemo(
    () => ({
      ...defaultAppConfiguration,
      ...appConfiguration,
    }),
    [appConfiguration],
  )

  return (
    <AppConfigurationContext.Provider
      value={mergedAppConfiguration ?? defaultAppConfiguration}
    >
      {children}
    </AppConfigurationContext.Provider>
  )
}


--- Start of frontend/src/shared/configuration/index.ts ---

import { defaultAppConfiguration, type AppConfiguration } from './constants'
import { AppConfigurationProvider } from './context'
import { useAppConfiguration, useResponsiveAppMode } from './hooks'

export {
  useAppConfiguration,
  useResponsiveAppMode,
  AppConfigurationProvider,
  defaultAppConfiguration,
}
export type { AppConfiguration }


--- Start of frontend/src/shared/configuration/hooks.ts ---

import { useContext } from 'react'
import { captureException } from '@sentry/react'
import axios from 'axios'

import { useMediaQuery, type Theme } from '@mui/system'

import {
  defaultAppConfiguration,
  type AppConfiguration,
} from '@/shared/configuration/constants'
import { AppConfigurationContext } from '@/shared/configuration/context'

/**
 * Fetches the app configuration from the `configuration.json` file.
 * @returns The app configuration object.
 *
 * @example const appConfiguration = useGetAppConfiguration()
 */
export async function initializeAppConfiguration() {
  // Fetch configuration
  try {
    const { data } = await axios<AppConfiguration>('/configuration.json')
    return data || defaultAppConfiguration
  } catch (error) {
    captureException(error)
    return defaultAppConfiguration
  }
}

export function useAppConfiguration() {
  const context = useContext(AppConfigurationContext)
  if (!context) {
    throw new Error(
      'useAppConfiguration must be used within an AppConfigurationProvider',
    )
  }
  return context
}

export function getResponsiveAppMode(
  appMode: 'standalone' | 'widget',
  smUp: boolean,
) {
  if (appMode === 'widget') {
    return 'widget'
  }
  if (appMode === 'standalone' && smUp) {
    return 'desktop'
  }
  if (appMode === 'standalone' && !smUp) {
    return 'mobile'
  }
  return 'standalone'
}

/**
 * Checks which app mode to use based on the current screen size and the app mode.
 * @returns The responsive app mode. Either 'standalone', 'widget', 'desktop', or 'mobile'.
 * and a boolean indicating if the screen is small (i.e. mobile or widget).
 *
 * @example const { responsiveAppMode, isSmallScreen } = useResponsiveAppMode()
 *
 * @see {@link useAppConfiguration}
 * @see {@link getResponsiveAppMode}
 */
export function useResponsiveAppMode(): {
  responsiveAppMode: 'standalone' | 'widget' | 'desktop' | 'mobile'
  isSmallScreen: boolean
} {
  const { appMode } = useAppConfiguration()
  const smUp = useMediaQuery((theme: Theme) => theme.breakpoints.up('sm'))

  return {
    responsiveAppMode: getResponsiveAppMode(appMode, smUp),
    isSmallScreen: !smUp || appMode === 'widget',
  }
}


--- Start of frontend/src/shared/utils/currency-formatter.ts ---

export const currencyFormat = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  minimumFractionDigits: 5,
})


--- Start of frontend/src/shared/utils/case-transformers.ts ---

export function transformKeysToCamelCase<T extends Record<string, any>>(
  data: T,
): T {
  if (Array.isArray(data)) {
    return data.map((item) => transformKeysToCamelCase(item)) as any
  }

  if (data !== null && typeof data === 'object') {
    return Object.keys(data).reduce((acc, key) => {
      const camelCaseKey = key.replace(/([-_][a-z])/gi, ($1) => {
        return $1.toUpperCase().replace('-', '').replace('_', '')
      })
      return { ...acc, [camelCaseKey]: transformKeysToCamelCase(data[key]) }
    }, {} as T)
  }

  return data
}

export function transformKeysToSnakeCase<T extends Record<string, any>>(
  data: T,
): T {
  if (Array.isArray(data)) {
    return data.map((item) => transformKeysToSnakeCase(item)) as any
  }

  if (data !== null && typeof data === 'object') {
    return Object.keys(data).reduce((acc, key) => {
      const snakeCaseKey = key.replace(
        /([A-Z])/g,
        ($1) => `_${$1.toLowerCase()}`,
      )
      return { ...acc, [snakeCaseKey]: transformKeysToSnakeCase(data[key]) }
    }, {} as T)
  }

  return data
}

// Function to transform a camelCase value (not keys) to snake_case
export function transformStringValueToSnakeCase(value: string): string {
  return value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`)
}

export function transformStringValueToCamelCase(value?: string): string {
  if (!value) {
    return ''
  }
  return value?.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace('-', '').replace('_', '')
  })
}


--- Start of frontend/src/shared/utils/capitalise-first-letter.ts ---

export function capitaliseFirstLetter(str?: string): string {
  if (!str) {
    return '-'
  }
  return str.charAt(0).toUpperCase() + str.slice(1)
}


--- Start of frontend/src/shared/utils/local-storage.ts ---

export type ValidStorageKeys = 'enableIntroductoryNotification' | 'theme'
export function getLocalStorageItem(key: ValidStorageKeys) {
  return localStorage.getItem(key)
}

export function setLocalStorageItem(
  key: ValidStorageKeys,
  value?: string | null,
) {
  if (value == null) {
    return localStorage?.removeItem(key)
  }

  return localStorage?.setItem(key, value)
}

export function clearLocalStorage() {
  localStorage?.clear()
}


--- Start of frontend/src/shared/utils/redirect-to-login.ts ---

export function redirectToLogin() {
  window.location.href = '/login'
}


--- Start of frontend/src/shared/utils/has-token-expired.ts ---

export function hasTokenExpired(expiresAt: string): boolean {
  return new Date(expiresAt) < new Date()
}


--- Start of frontend/src/shared/theme/icons.ts ---

import {
  AngryIcon,
  AnnoyedIcon,
  ArrowDownIcon,
  ArrowLeftIcon,
  ArrowRightIcon,
  ArrowUpIcon,
  AudioLinesIcon,
  BadgeCheckIcon,
  BugIcon,
  ChartLine,
  CheckCircle2Icon,
  CheckIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  ChevronsDownUp,
  ChevronUpIcon,
  CircleHelpIcon,
  CircleStopIcon,
  CircleXIcon,
  ClockIcon,
  CogIcon,
  CopyIcon,
  CopyPlusIcon,
  DownloadIcon,
  EllipsisIcon,
  EyeIcon,
  EyeOffIcon,
  FileAudio,
  FileCode,
  FileIcon,
  FileImage,
  FileText,
  FileVideo,
  FullscreenIcon,
  GlobeIcon,
  HomeIcon,
  ImageIcon,
  ImageOffIcon,
  InfoIcon,
  LaughIcon,
  ListFilterIcon,
  ListIcon,
  LockIcon,
  LogInIcon,
  LogOutIcon,
  LogsIcon,
  MessageCircleIcon,
  MessagesSquareIcon,
  MicOffIcon,
  Paperclip,
  PencilIcon,
  PencilOffIcon,
  PenSquareIcon,
  PlusIcon,
  RefreshCwIcon,
  SearchIcon,
  SendIcon,
  Settings2Icon,
  SettingsIcon,
  SidebarCloseIcon,
  SidebarOpenIcon,
  SmileIcon,
  StickerIcon,
  ThumbsDownIcon,
  ThumbsUpIcon,
  Trash2Icon,
  UserCog2Icon,
  UserRoundCheckIcon,
  WrenchIcon,
  XIcon,
  type LucideIcon,
  type LucideProps,
} from 'lucide-react'

import type { FeedbackRating, FeedbackType } from '@/api/models'

const feedbackIcons: Record<FeedbackRating, LucideIcon> = {
  bad: AnnoyedIcon,
  good: SmileIcon,
  great: LaughIcon,
  terrible: AngryIcon,
}
const feedbackTypeIcons: Record<FeedbackType, LucideIcon> = {
  bug: BugIcon,
  feature_request: ThumbsUpIcon,
  improvement: WrenchIcon,
  other: StickerIcon,
  performance: ChartLine,
  quality: BadgeCheckIcon,
  question: CircleHelpIcon,
  usability: UserRoundCheckIcon,
}

export type ExternalIconProps = LucideProps
// Icon mapping for dynamic icon usage.
export const iconMap = {
  add: PlusIcon,
  arrowUp: ArrowUpIcon,
  arrowDown: ArrowDownIcon,
  arrowRight: ArrowRightIcon,
  assetUpload: Paperclip,
  applicationSettings: CogIcon,
  audio: AudioLinesIcon,
  back: ArrowLeftIcon,
  copy: CopyIcon,
  check: CheckIcon,
  checkCircle: CheckCircle2Icon,
  crossCircle: CircleXIcon,
  conversation: MessagesSquareIcon,
  message: MessageCircleIcon,
  close: XIcon,
  config: Settings2Icon,
  downChevron: ChevronDownIcon,
  download: DownloadIcon,
  draft: PenSquareIcon,
  duplicate: CopyPlusIcon,
  eye: EyeIcon,
  eyeOff: EyeOffIcon,
  edit: PencilIcon,
  editCancel: PencilOffIcon,
  filter: ListFilterIcon,
  file: FileIcon,
  forward: ArrowRightIcon,
  fileAudio: FileAudio,
  fileCode: FileCode,
  fileImage: FileImage,
  fileText: FileText,
  fileOther: FileIcon,
  fileVideo: FileVideo,
  fullscreen: FullscreenIcon,
  global: GlobeIcon,
  home: HomeIcon,
  history: ClockIcon,
  image: ImageIcon,
  noImageSupport: ImageOffIcon,
  noAudioSupport: MicOffIcon,
  info: InfoIcon,
  leftChevron: ChevronRightIcon,
  login: LogInIcon,
  logout: LogOutIcon,
  logs: LogsIcon,
  list: ListIcon,
  more: EllipsisIcon,
  private: LockIcon,
  public: GlobeIcon,
  regenerate: RefreshCwIcon,
  rightChevron: ChevronRightIcon,
  search: SearchIcon,
  send: SendIcon,
  settings: SettingsIcon,
  sidebarClose: SidebarCloseIcon,
  sidebarOpen: SidebarOpenIcon,
  stop: CircleStopIcon,
  thumbsDown: ThumbsDownIcon,
  thumbsUp: ThumbsUpIcon,
  tool: WrenchIcon,
  upChevron: ChevronUpIcon,
  userSettings: UserCog2Icon,
  unfold: ChevronsDownUp,
  delete: Trash2Icon,
  ...feedbackIcons,
  ...feedbackTypeIcons,
}


--- Start of frontend/src/shared/theme/context.tsx ---

import type { ReactNode } from 'react'

import { CssBaseline, ScopedCssBaseline, type Theme } from '@mui/joy'
import { CssVarsProvider } from '@mui/joy/styles'

import { useAppConfiguration } from '@/shared/configuration/hooks'
import { GlobalStyles } from '@/shared/theme/components/GlobalStyles'

export function ThemeProvider({
  children,
  theme,
}: {
  children: ReactNode
  theme: Theme
}) {
  const { appMode, defaultMode } = useAppConfiguration()
  return (
    <CssVarsProvider defaultMode={defaultMode} theme={theme}>
      <GlobalStyles />
      {appMode === 'standalone' ?
        <>
          <CssBaseline />
          {children}
        </>
      : <ScopedCssBaseline>{children}</ScopedCssBaseline>}
    </CssVarsProvider>
  )
}


--- Start of frontend/src/shared/theme/index.ts ---

import { GlobalStyles } from './components/GlobalStyles'
import { ThemeProvider } from './context'
import { iconMap, type ExternalIconProps } from './icons'
import { getTheme } from './theme'

export { getTheme, iconMap, ThemeProvider, GlobalStyles }
export type { ExternalIconProps }


--- Start of frontend/src/shared/theme/theme.ts ---

import type { CssVarsThemeOptions } from '@mui/joy'

import type { AppConfiguration } from '@/shared/configuration/constants'
import { generateShades } from '@/shared/theme/utils/generate-shades'

export function getTheme(
  appConfiguration: AppConfiguration,
): Partial<CssVarsThemeOptions> {
  return {
    cssVarPrefix: appConfiguration.cssVarPrefix,
    colorSchemes: {
      dark: {
        palette: {
          text: {
            primary: appConfiguration.darkTextPrimary,
            secondary: appConfiguration.darkTextSecondary,
            icon: appConfiguration.darkTextIcon,
            tertiary: appConfiguration.darkTextTertiary,
          },
          background: {
            body: appConfiguration.darkBodyColor,
            surface: appConfiguration.darkSurfaceColor,
            level1: appConfiguration.darkLevel1Color,
            level2: appConfiguration.darkLevel2Color,
            level3: appConfiguration.darkLevel3Color,
            popup: appConfiguration.darkPopupColor,
            tooltip: appConfiguration.darkTooltipColor,
            backdrop: appConfiguration.darkBackdropColor,
          },
          primary: {
            50: generateShades(appConfiguration.primaryColor, 40),
            100: generateShades(appConfiguration.primaryColor, 35),
            200: generateShades(appConfiguration.primaryColor, 30),
            300: generateShades(appConfiguration.primaryColor, 20),
            400: generateShades(appConfiguration.primaryColor, 10),
            500: appConfiguration.primaryColor,
            600: generateShades(appConfiguration.primaryColor, -10),
            700: generateShades(appConfiguration.primaryColor, -20),
            800: generateShades(appConfiguration.primaryColor, -30),
            900: generateShades(appConfiguration.primaryColor, -40),
          },
        },
      },
      light: {
        palette: {
          text: {
            primary: appConfiguration.lightTextPrimary,
            secondary: appConfiguration.lightTextSecondary,
            icon: appConfiguration.lightTextIcon,
            tertiary: appConfiguration.lightTextTertiary,
          },
          background: {
            body: appConfiguration.lightBodyColor,
            surface: appConfiguration.lightSurfaceColor,
            level1: appConfiguration.lightLevel1Color,
            level2: appConfiguration.lightLevel2Color,
            level3: appConfiguration.lightLevel3Color,
            popup: appConfiguration.lightPopupColor,
            tooltip: appConfiguration.lightTooltipColor,
            backdrop: appConfiguration.lightBackdropColor,
          },
          primary: {
            50: generateShades(appConfiguration.primaryColor, 40),
            100: generateShades(appConfiguration.primaryColor, 35),
            200: generateShades(appConfiguration.primaryColor, 30),
            300: generateShades(appConfiguration.primaryColor, 20),
            400: generateShades(appConfiguration.primaryColor, 10),
            500: appConfiguration.primaryColor,
            600: generateShades(appConfiguration.primaryColor, -10),
            700: generateShades(appConfiguration.primaryColor, -20),
            800: generateShades(appConfiguration.primaryColor, -30),
            900: generateShades(appConfiguration.primaryColor, -40),
          },
        },
      },
    },
  }
}


--- Start of frontend/src/shared/theme/utils/generate-shades.ts ---

export function generateShades(color: string, percent: number) {
  let R = Number.parseInt(color.substring(1, 3), 16)
  let G = Number.parseInt(color.substring(3, 5), 16)
  let B = Number.parseInt(color.substring(5, 7), 16)

  R = Math.round((R * (100 + percent)) / 100)
  G = Math.round((G * (100 + percent)) / 100)
  B = Math.round((B * (100 + percent)) / 100)

  R = R < 255 ? R : 255
  G = G < 255 ? G : 255
  B = B < 255 ? B : 255

  R = Math.round(R)
  G = Math.round(G)
  B = Math.round(B)

  const RR = R.toString(16).length === 1 ? `0${R.toString(16)}` : R.toString(16)
  const GG = G.toString(16).length === 1 ? `0${G.toString(16)}` : G.toString(16)
  const BB = B.toString(16).length === 1 ? `0${B.toString(16)}` : B.toString(16)

  return `#${RR}${GG}${BB}`
}


--- Start of frontend/src/shared/theme/components/GlobalStyles.tsx ---

import { GlobalStyles as Globals } from '@mui/joy'

import { useAppConfiguration } from '@/shared/configuration'

export function GlobalStyles() {
  const { iconCssSelector } = useAppConfiguration()
  return (
    <Globals
      styles={{
        [`& ${iconCssSelector}`]: {
          color: 'var(--Icon-color)',
          margin: 'var(--Icon-margin)',
          fontSize: 'var(--Icon-fontSize, 20px)',
          width: '1em',
          height: '1em',
        },
      }}
    />
  )
}


--- Start of frontend/src/shared/analytics/product.tsx ---

import type { PostHogConfig } from 'posthog-js'
import { PostHogProvider, usePostHog } from 'posthog-js/react'

import { env } from '@/env'
import { captureException } from '@/shared/analytics/utils'

const options: Partial<PostHogConfig> = {
  api_host: env?.VITE__PRODUCT_ANALYTICS_HOST,
  loaded: (posthog) => {
    if (env?.VITE__ENVIRONMENT === 'local') {
      posthog.opt_out_capturing()
    }
  },
}

export function ProductAnalyticsProvider({
  children,
}: {
  children: React.ReactNode
}) {
  if (env?.VITE__ENVIRONMENT === 'local') {
    return <>{children}</>
  }

  const apiKey = env?.VITE__PRODUCT_ANALYTICS_API_KEY?.trim()
  if (!apiKey) {
    console.warn('Product analytics API key is missing')
    return <>{children}</>
  }

  return (
    <PostHogProvider apiKey={apiKey} options={options}>
      {children}
    </PostHogProvider>
  )
}

export function useAnalytics() {
  const posthog = usePostHog()

  const capture = (eventName: string, properties?: Record<string, any>) => {
    try {
      if (posthog && eventName) {
        posthog.capture(eventName, properties)
      }
    } catch (error) {
      captureException(error)
    }
  }

  return { capture }
}


--- Start of frontend/src/shared/analytics/utils.ts ---

import { captureException as capture } from '@sentry/react'
import type { CaptureContext, EventHint, ScopeContext } from '@sentry/types'

export type ExclusiveEventHintOrCaptureContext =
  | (CaptureContext &
      Partial<{
        [key in keyof EventHint]: never
      }>)
  | (EventHint &
      Partial<{
        [key in keyof ScopeContext]: never
      }>)

/**
 * Wrapper around sentry capture exception. Captures an exception event and sends it to Sentry.
 *
 * @param exception The exception to capture.
 * @param hint Optional additional data to attach to the Sentry event.
 * @returns the id of the captured Sentry event.
 */
export function captureException(
  exception: any,
  hint?: ExclusiveEventHintOrCaptureContext,
) {
  return capture(exception, hint)
}


--- Start of frontend/src/shared/analytics/error.ts ---

import * as Sentry from '@sentry/browser'
import posthog from 'posthog-js'

import { env } from '@/env'

const integrations = [
  Sentry.browserTracingIntegration(),
  Sentry.replayIntegration(),
  posthog.sentryIntegration({
    organization: env?.VITE__ERROR_ANALYTICS_ORGANIZATION,
    projectId: env?.VITE__ERROR_ANALYTICS_PROJECT_ID,
    severityAllowList: ['error', 'info'], // optional: here is set to handle captureMessage (info) and captureException (error)
  }),
]
export function initializeErrorAnalytics() {
  if (!env?.VITE__ERROR_ANALYTICS_DSN) {
    console.warn('Error analytics DSN not set, skipping initialization')
    return
  }

  if (env?.VITE__ENVIRONMENT === 'local') {
    return
  }

  Sentry.init({
    dsn: env?.VITE__ERROR_ANALYTICS_DSN,
    integrations,
    sampleRate: env?.VITE__ERROR_ANALYTICS_ERROR_SAMPLE_RATE ?? 1, // Defaults to capture 100% of errors
    tracesSampleRate: 0.001, // Capture 0.1% of transactions
    replaysSessionSampleRate: 0.0001, // Capture 0.01% of sessions
    replaysOnErrorSampleRate: 0.001, // Capture 0.1% of errors
  })
}


--- Start of frontend/src/shared/analytics/hooks.ts ---

import { useEffect } from 'react'
import { captureException } from '@sentry/react'
import { usePostHog } from 'posthog-js/react'

import type { UserProfile } from '@/api/models'

export function useAnalytics() {
  const posthog = usePostHog()

  const capture = (eventName: string, properties?: Record<string, any>) => {
    try {
      if (posthog && eventName) {
        posthog.capture(eventName, properties)
      }
    } catch (error) {
      captureException(error)
    }
  }

  return { capture }
}

export function useProductAnalyticsTrackPageView(pathname?: string) {
  const { capture } = useAnalytics()

  useEffect(() => {
    if (pathname) {
      capture('Page Viewed', { pathname })
    }
  }, [pathname, capture])
}

// Identifies the user in PostHog if the profile is loaded successfully
export function useProductAnalyticsIdentifyUser({
  identifier,
  shouldIdentify,
}: {
  identifier?: UserProfile['username'] | UserProfile['email']
  shouldIdentify: boolean
}) {
  const { capture } = useAnalytics()

  useEffect(() => {
    if (shouldIdentify && identifier) {
      capture('Identify User', { identifier })
    }
  }, [shouldIdentify, identifier, capture])
}


--- Start of frontend/src/components/layout/Modals.tsx ---

import { lazy } from 'react'

const FeedbackModal = lazy(() =>
  import('@/features/feedback').then((module) => ({
    default: module.FeedbackModal,
  })),
)
const SettingsModal = lazy(() =>
  import('@/features/settings').then((module) => ({
    default: module.SettingsModal,
  })),
)
const SearchModal = lazy(() =>
  import('@/features/search/components/SearchModal').then((module) => ({
    default: module.SearchModal,
  })),
)
const ConversationSettingsModal = lazy(() =>
  import('@/features/conversation/components/ConversationSettingsModal').then(
    (module) => ({ default: module.ConversationSettingsModal }),
  ),
)

const AgentCreateModal = lazy(() =>
  import('@/features/agent/components/AgentCreateModal').then((module) => ({
    default: module.AgentCreateModal,
  })),
)
export function Modals() {
  return (
    <>
      <FeedbackModal />
      <SettingsModal />
      <SearchModal />
      <ConversationSettingsModal />
      <AgentCreateModal />
    </>
  )
}


--- Start of frontend/src/components/layout/Main.tsx ---

import Box, { type BoxProps } from '@mui/joy/Box'

import { useResponsiveAppMode } from '@/shared/configuration'

export function Main({
  children,
  ...props
}: { children: React.ReactNode } & BoxProps) {
  const { responsiveAppMode } = useResponsiveAppMode()

  if (responsiveAppMode === 'widget') {
    return (
      <Box
        {...props}
        sx={{
          overflow: 'hidden',
          height: '100%',
          bgcolor: 'background.body',
          display: 'flex',
          flexDirection: 'column',
          ...props?.sx,
        }}
        component="main"
      >
        {children}
      </Box>
    )
  }
  return (
    <Box
      component="main"
      {...props}
      sx={{
        overflow: 'hidden',
        height: '100%',
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        ...props?.sx,
        backgroundColor: 'background.surface',
      }}
    >
      {children}
    </Box>
  )
}


--- Start of frontend/src/components/layout/PublicMain.tsx ---

import Box from '@mui/joy/Box'

import { useResponsiveAppMode } from '@/shared/configuration/hooks'

export function PublicMain({ children }: { children: React.ReactNode }) {
  const { responsiveAppMode } = useResponsiveAppMode()
  return (
    <Box
      component="main"
      display="flex"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      height={responsiveAppMode === 'widget' ? '100%' : '100vh'}
      bgcolor={(theme) => theme.palette.background.body}
    >
      {children}
    </Box>
  )
}


--- Start of frontend/src/components/layout/WidgetModeContainer.tsx ---

import Box from '@mui/joy/Box'
import IconButton from '@mui/joy/IconButton'

import { useAppConfiguration } from '@/shared/configuration'
import { buttonPlacement, placement } from '@/shared/configuration/constants'
import { useGlobalStore } from '@/shared/store'
import CompanyLogo from '@/assets/svgs/company-logo.svg?react'
import { Icon } from '@/components/common/Icon'

export function WidgetModeContainer({
  children,
}: {
  children: React.ReactNode
}) {
  const { isWidgetOpen, setIsWidgetOpen } = useGlobalStore()
  const {
    widgetContainerId,
    widgetHeight,
    widgetWidth,
    widgetPlacement,
    widgetButtonWidth,
    widgetButtonHeight,
  } = useAppConfiguration()

  return (
    <>
      {isWidgetOpen && (
        <Box
          border={(theme) => `1px solid ${theme.palette.divider}`}
          height={widgetHeight}
          width={widgetWidth}
          position="fixed"
          {...placement[widgetPlacement]}
          zIndex={1000}
          borderRadius={8}
          overflow="scroll"
          id={widgetContainerId}
          bgcolor={(theme) => theme.palette.background.surface}
        >
          <Box height={1} width={1} position="relative">
            {children}
          </Box>
        </Box>
      )}
      <IconButton
        variant="solid"
        color="primary"
        aria-label="Open Chat"
        onClick={() => setIsWidgetOpen(!isWidgetOpen)}
        style={{
          position: 'fixed',
          borderRadius: '50%',
          width: widgetButtonWidth,
          height: widgetButtonHeight,
          ...buttonPlacement[widgetPlacement],
        }}
      >
        {isWidgetOpen ?
          <Icon name="downChevron" size={24} color="white" />
        : <CompanyLogo />}
      </IconButton>
    </>
  )
}


--- Start of frontend/src/components/layout/SplashScreen.tsx ---

import Box from '@mui/joy/Box'
import CircularProgress from '@mui/joy/CircularProgress'

export function SplashScreen() {
  return (
    <Box
      sx={{
        height: '100vh',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
      }}
    >
      <CircularProgress />
    </Box>
  )
}


--- Start of frontend/src/components/layout/AppModeWrapper.tsx ---

import { useAppConfiguration } from '../../shared/configuration/hooks'
import { StandaloneContainer } from './StandaloneContainer'
import { WidgetModeContainer } from './WidgetModeContainer'

export function AppModeWrapper({ children }: { children: React.ReactNode }) {
  const { appMode } = useAppConfiguration()

  if (appMode === 'standalone') {
    return <StandaloneContainer>{children}</StandaloneContainer>
  }

  return <WidgetModeContainer>{children}</WidgetModeContainer>
}


--- Start of frontend/src/components/layout/Container.tsx ---

import JoyContainer, { type ContainerProps } from '@mui/joy/Container'

export function Container({
  children,
  ...props
}: {
  children: React.ReactNode
} & ContainerProps) {
  return (
    <JoyContainer
      maxWidth={props.maxWidth ?? 'md'}
      {...props}
      sx={{
        px: 1,
        display: 'flex',
        flexDirection: 'column',
        gap: 1,
        flexGrow: 1,
        ...props.sx,
      }}
    >
      {children}
    </JoyContainer>
  )
}


--- Start of frontend/src/components/layout/StandaloneContainer.tsx ---

export function StandaloneContainer({
  children,
}: {
  children: React.ReactNode
}) {
  return <>{children}</>
}


--- Start of frontend/src/components/layout/MobileBottomNavigation.tsx ---

import { useMemo, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { Link, useLocation, type LinkProps } from 'react-router-dom'

import Box, { type BoxProps } from '@mui/joy/Box'
import ListItemDecorator from '@mui/joy/ListItemDecorator'
import Tab, { tabClasses } from '@mui/joy/Tab'
import TabList from '@mui/joy/TabList'
import Tabs from '@mui/joy/Tabs'
import Typography from '@mui/joy/Typography'

import { useResponsiveAppMode } from '@/shared/configuration'
import { useGetUserProfile } from '@/api/services/api'
import { useSearchStore } from '@/features/search/store'
import { UserAvatarDropdown } from '@/components/common/avatars/UserAvatar'
import { Icon, type IconName } from '@/components/common/Icon'

interface BottomNavItem {
  icon?: IconName
  label?: string
  to?: LinkProps['to'] | string
  disabled?: boolean
  onClick?: () => void
  active?: boolean
  component?: React.ReactNode
}

export function MobileBottomNavigation({
  containerProps,
}: {
  containerProps?: BoxProps
}) {
  const { data } = useGetUserProfile()
  const { setSearchModalOpen, searchModalOpen } = useSearchStore()
  const { t } = useTranslation()
  const { responsiveAppMode } = useResponsiveAppMode()
  const location = useLocation()
  const [index, setIndex] = useState(0)

  const bottomNav: BottomNavItem[] = useMemo(
    () => [
      {
        icon: 'draft',
        label: 'home.title',
        to: '/',
        disabled: false,
        active: location?.pathname === '/',
      },
      {
        icon: 'list',
        label: 'conversations.title',
        to: '/conversations',
        disabled: false,
        active: location?.pathname === '/conversations',
      },
      {
        icon: 'search',
        label: 'search.title',
        onClick: () => setSearchModalOpen({ open: true }),
        disabled: false,
        active: searchModalOpen,
      },
      {
        disabled: false,
        component: (
          <UserAvatarDropdown data={data} withMeta={false} size="md" />
        ),
      },
    ],
    [data, location?.pathname, searchModalOpen, setSearchModalOpen],
  )

  const handleNavigation = (index: number) => {
    if (bottomNav[index].onClick) {
      bottomNav[index].onClick()
    } else {
      setIndex(index)
    }
  }

  if (responsiveAppMode === 'desktop') {
    return null
  }

  return (
    <Box
      component="nav"
      width="100%"
      bgcolor="background.body"
      zIndex={(theme) => theme.zIndex.popup - 10}
      {...containerProps}
    >
      <Tabs
        aria-label="Bottom Navigation"
        value={index}
        onChange={(_event, value) => {
          handleNavigation(value as number)
        }}
      >
        <TabList
          size="sm"
          disableUnderline
          variant="plain"
          tabFlex={1}
          sx={{
            // override the default styles
            [`& .${tabClasses.root}`]: {
              bgcolor: 'background.body',
            },

            [`& .${tabClasses.root}[aria-selected="true"]`]: {
              boxShadow: 'none',
              bgcolor: 'background.body',
              '&:hover': {
                bgcolor: 'background.body',
              },
            },
          }}
        >
          {bottomNav.map((navItem) => (
            <Tab
              component={navItem?.to ? Link : 'button'}
              key={`nav-item-${navItem.label}`}
              to={navItem?.to ? navItem.to : undefined}
              orientation="vertical"
              variant="plain"
              disableIndicator
              sx={{
                bgcolor: 'background.body',
                boxShadow: 'none',
                cursor: 'pointer',
              }}
              disabled={navItem.disabled}
            >
              {navItem?.icon && (
                <ListItemDecorator>
                  <Icon
                    name={navItem.icon}
                    color={navItem?.active ? 'primary' : 'secondary'}
                  />
                </ListItemDecorator>
              )}

              {navItem?.component}

              {navItem?.label && (
                <Typography
                  level="body-xs"
                  sx={{
                    color: (theme) =>
                      navItem?.active ?
                        theme.palette.text.primary
                      : theme.palette.text.secondary,
                  }}
                  fontWeight="bold"
                >
                  {t(navItem.label)}
                </Typography>
              )}
            </Tab>
          ))}
        </TabList>
      </Tabs>
    </Box>
  )
}


--- Start of frontend/src/components/layout/ScrollContainer.tsx ---

import Box, { type BoxProps } from '@mui/joy/Box'

export function ScrollContainer({
  children,
  containerRef,
  ...props
}: {
  children: React.ReactNode
  containerRef?: React.RefObject<HTMLDivElement>
} & BoxProps) {
  return (
    <Box
      ref={containerRef}
      {...props}
      sx={{
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        overflowY: 'scroll',
        overflowX: 'hidden',
        ...props.sx,
        position: 'relative',
      }}
    >
      {children}
    </Box>
  )
}


--- Start of frontend/src/components/layout/Sidebar.tsx ---

import { memo, useMemo, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useLocation, useNavigate } from 'react-router-dom'

import Box from '@mui/joy/Box'
import CircularProgress from '@mui/joy/CircularProgress'
import Dropdown from '@mui/joy/Dropdown'
import IconButton from '@mui/joy/IconButton'
import List from '@mui/joy/List'
import ListItem from '@mui/joy/ListItem'
import ListItemButton from '@mui/joy/ListItemButton'
import ListItemDecorator from '@mui/joy/ListItemDecorator'
import Menu from '@mui/joy/Menu'
import MenuButton from '@mui/joy/MenuButton'
import MenuItem from '@mui/joy/MenuItem'
import Sheet from '@mui/joy/Sheet'
import Skeleton from '@mui/joy/Skeleton'
import Stack from '@mui/joy/Stack'
import { useTheme } from '@mui/joy/styles'
import Tooltip from '@mui/joy/Tooltip'
import Typography from '@mui/joy/Typography'

import { useGlobalStore } from '@/shared/store'
import type {
  ConversationListResponse,
  ConversationReadResponse,
} from '@/api/models'
import { useGetAllConversations, useGetUserProfile } from '@/api/services/api'
import { useHandleDeleteConversation } from '@/features/conversation/hooks'
import {
  groupConversationsByDay,
  type DateCategory,
} from '@/features/conversation/utils'
import { useSearchStore } from '@/features/search/store'
import {
  CompanyAvatar,
  Icon,
  LinkListItem,
  UserAvatarDropdown,
} from '@/components/common'

const SidebarHeader = memo(
  ({ hasConversations }: { hasConversations: boolean }) => {
    const { setSearchModalOpen, searchModalOpen } = useSearchStore()
    const { sidebarCollapsed } = useGlobalStore()
    const navigate = useNavigate()
    const location = useLocation()

    const handleOpenSearchModal = () => {
      setSearchModalOpen({ open: true })
    }

    return (
      <Box
        display="flex"
        justifyContent="space-between"
        alignItems="center"
        flexDirection={sidebarCollapsed ? 'column' : 'row'}
        gap={2}
        px={1}
      >
        <CompanyAvatar />
        <Stack direction={sidebarCollapsed ? 'column-reverse' : 'row'} gap={1}>
          <Tooltip
            arrow
            title="Search"
            variant="soft"
            placement={sidebarCollapsed ? 'right' : 'bottom'}
          >
            <IconButton
              size="sm"
              variant="plain"
              onClick={handleOpenSearchModal}
            >
              <Icon
                name="search"
                color={searchModalOpen ? 'primary' : 'secondary'}
              />
            </IconButton>
          </Tooltip>

          {hasConversations && (
            <Tooltip
              arrow
              title="Conversations"
              variant="soft"
              placement={sidebarCollapsed ? 'right' : 'bottom'}
            >
              <IconButton
                size="sm"
                variant="plain"
                onClick={() => navigate('/conversations')}
              >
                <Icon
                  name="list"
                  color={
                    location.pathname === '/conversations' ?
                      'primary'
                    : 'secondary'
                  }
                />
              </IconButton>
            </Tooltip>
          )}

          <Tooltip
            arrow
            title="Create"
            variant="soft"
            placement={sidebarCollapsed ? 'right' : 'bottom'}
          >
            <IconButton size="sm" variant="soft" onClick={() => navigate('/')}>
              <Icon
                name="draft"
                color={location.pathname === '/' ? 'primary' : 'secondary'}
              />
            </IconButton>
          </Tooltip>
        </Stack>
      </Box>
    )
  },
)

export const ConversationListItemActions = memo(
  ({ uuid }: { uuid: string }) => {
    const { handleDeleteConversation, isPending } =
      useHandleDeleteConversation(uuid)
    return (
      <Dropdown>
        <MenuButton
          size="sm"
          slots={{ root: IconButton }}
          slotProps={{
            root: {
              size: 'sm',
              variant: 'plain',
              loading: isPending,
            },
          }}
          onClick={(e) => {
            e.preventDefault()
            e.stopPropagation()
          }}
        >
          <Icon name="more" size={16} />
        </MenuButton>
        <Menu>
          <MenuItem onClick={handleDeleteConversation} disabled={isPending}>
            Delete Conversation
            <ListItemDecorator>
              {isPending ?
                <CircularProgress size="sm" />
              : <Icon name="delete" size={16} />}
            </ListItemDecorator>
          </MenuItem>
        </Menu>
      </Dropdown>
    )
  },
)

const SidebarQuickLinkNavItemActions = memo(
  ({
    uuid,
    showMoreMenu,
    selected,
  }: {
    uuid: string
    showMoreMenu: boolean
    selected: boolean
  }) => {
    return (
      <ListItemDecorator
        sx={{
          p: 0,
          opacity: showMoreMenu || selected ? 1 : 0,
          width: showMoreMenu || selected ? 'auto' : 0,
          transition: 'width 0.3s ease',
          display: showMoreMenu || selected ? 'flex' : 'none',
          gap: 1,
          alignItems: 'center',
          maxHeight: 30,
        }}
      >
        <ConversationListItemActions uuid={uuid} />
      </ListItemDecorator>
    )
  },
)

function SidebarQuickLinkNavItem({
  selected,
  uuid,
  name,
}: {
  selected: boolean
  uuid: string
  name: string
}) {
  const [showMoreMenu, setShowMoreMenu] = useState(false)
  return (
    <LinkListItem
      onMouseOver={() => setShowMoreMenu(true)}
      onMouseOut={() => setShowMoreMenu(false)}
      key={uuid}
      to={`/conversations/${uuid}`}
    >
      <ListItemButton
        selected={selected}
        variant="plain"
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          py: 0,
          width: '100%',
        }}
      >
        <Typography
          level="body-xs"
          noWrap
          textColor="text.primary"
          className="ph-no-capture"
        >
          {name}
        </Typography>
        <SidebarQuickLinkNavItemActions
          uuid={uuid}
          showMoreMenu={showMoreMenu}
          selected={selected}
        />
      </ListItemButton>
    </LinkListItem>
  )
}

function SidebarFooter() {
  const { data, isLoading } = useGetUserProfile()
  const { sidebarCollapsed, setSidebarCollapsed } = useGlobalStore()
  return (
    <Box
      display="flex"
      justifyContent={sidebarCollapsed ? 'center' : 'space-between'}
      alignItems="center"
      gap={1}
      flexDirection={sidebarCollapsed ? 'column-reverse' : 'row'}
    >
      {isLoading ?
        <Skeleton variant="circular" width={40} height={40} />
      : <UserAvatarDropdown data={data} />}
      <IconButton
        size="sm"
        variant="plain"
        onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
      >
        <Icon name={sidebarCollapsed ? 'sidebarOpen' : 'sidebarClose'} />
      </IconButton>
    </Box>
  )
}

export const SidebarNavigationConversationsListGroupHeader = memo(
  ({ value }: { value: string }) => {
    return (
      <ListItem
        sticky
        sx={{
          py: 0,
          my: 0,
        }}
      >
        <Typography level="body-xs" textColor="text.secondary">
          {value}
        </Typography>
      </ListItem>
    )
  },
)
export const SidebarList = memo(
  ({ children }: { children: React.ReactNode }) => {
    const { sidebarCollapsed } = useGlobalStore()
    const theme = useTheme()

    return (
      <List
        size="sm"
        sx={{
          '--ListItem-radius': theme.vars.radius.sm,
          display: 'flex',
          flexDirection: 'column',
          overflowY: 'auto',
          scrollbarWidth: 'none',
          position: 'relative',
          paddingBlock: 0,
          width: sidebarCollapsed ? 0 : '100%',
          py: 0,
          opacity: sidebarCollapsed ? 0 : 1,
          transition: 'opacity 0.3s ease',
          gap: 2,
        }}
      >
        {children}
      </List>
    )
  },
)

const SidebarNavigationConversationsList = memo(
  ({
    conversations,
    conversationsGroupedByDay,
    conversationsIsLoading,
    conversationsIsSuccess,
  }: {
    conversations?: ConversationListResponse
    conversationsGroupedByDay:
      | Record<DateCategory, ConversationReadResponse[]>
      | undefined
    conversationsIsLoading: any
    conversationsIsSuccess: any
  }) => {
    const location = useLocation()
    const { t } = useTranslation()
    if (conversationsIsSuccess && conversations?.items?.length === 0) {
      return null
    }
    return (
      <SidebarList>
        {conversationsIsLoading ?
          <Skeleton variant="text" sx={{ px: 1, my: 1 }} />
        : Object.entries(conversationsGroupedByDay ?? {}).map(
            ([date, conversations]) => (
              <span key={date}>
                <SidebarNavigationConversationsListGroupHeader
                  value={t(`general.date.${date}`)}
                />
                {conversations?.map(({ uuid, name }) => {
                  return (
                    <SidebarQuickLinkNavItem
                      key={uuid}
                      uuid={uuid}
                      name={name}
                      selected={location.pathname === `/conversations/${uuid}`}
                    />
                  )
                })}
              </span>
            ),
          )
        }
      </SidebarList>
    )
  },
)

export function Sidebar() {
  const { sidebarCollapsed } = useGlobalStore()
  const {
    data: conversations,
    isSuccess: conversationsIsSuccess,
    isLoading: conversationsIsLoading,
  } = useGetAllConversations({
    query: {
      staleTime: 1000 * 60 * 60,
    },
  })
  const conversationsGroupedByDay = useMemo(
    () => groupConversationsByDay(conversations?.items),
    [conversations?.items],
  )

  return (
    <Sheet
      className="Sidebar"
      sx={{
        zIndex: (theme) => theme.vars.zIndex.table,
        width: sidebarCollapsed ? 'fit-content' : 300,
        px: '0.75rem',
        py: 2,
        display: 'flex',
        flexDirection: 'column',
        height: '100dvh',
        overflow: 'hidden',
        transition: 'all 0.3s ease',
        gap: 2,
        justifyContent: 'space-between',
        backgroundColor: (theme) => theme.palette.background.body,
      }}
    >
      <Box
        height={1}
        display="flex"
        flexDirection="column"
        gap={2}
        overflow="hidden"
      >
        <SidebarHeader
          hasConversations={
            conversationsIsSuccess && conversations?.items?.length > 0
          }
        />
        <Box
          gap={2}
          display="flex"
          flexDirection="column"
          sx={{ overflowY: 'hidden' }}
          height={1}
        >
          <SidebarNavigationConversationsList
            conversations={conversations}
            conversationsGroupedByDay={conversationsGroupedByDay}
            conversationsIsLoading={conversationsIsLoading}
            conversationsIsSuccess={conversationsIsSuccess}
          />
        </Box>
      </Box>
      <SidebarFooter />
    </Sheet>
  )
}


--- Start of frontend/src/components/layout/index.ts ---

import { Container } from '@/components/layout/Container'
import { Main } from '@/components/layout/Main'
import { MobileBottomNavigation } from '@/components/layout/MobileBottomNavigation'
import { Modals } from '@/components/layout/Modals'
import { PublicMain } from '@/components/layout/PublicMain'
import { ScrollContainer } from '@/components/layout/ScrollContainer'
import { Sidebar } from '@/components/layout/Sidebar'
import { SplashScreen } from '@/components/layout/SplashScreen'
import {
  TopNavigation,
  TopNavigationTitle,
} from '@/components/layout/TopNavigation'

export {
  MobileBottomNavigation,
  Container,
  ScrollContainer,
  Modals,
  Sidebar,
  SplashScreen,
  Main,
  TopNavigation,
  TopNavigationTitle,
  PublicMain,
}


--- Start of frontend/src/components/layout/ErrorContainer.tsx ---

import { Main } from '@/components/layout'

export function ErrorContainer({ children }: { children: React.ReactNode }) {
  return (
    <Main
      sx={{
        maxWidth: 'sm',
        margin: 'auto',
        minHeight: '100vh',
        display: 'flex',
        p: 4,
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: (theme) => theme.palette.background.surface,
      }}
    >
      {children}
    </Main>
  )
}


--- Start of frontend/src/components/layout/TopNavigation.tsx ---

import { Typography } from '@mui/joy'
import Box from '@mui/joy/Box'

import { useAppConfiguration } from '@/shared/configuration'

export function TopNavigation({
  children,
  justifyContent = 'space-between',
}: {
  children?: React.ReactNode
  justifyContent?: 'space-between' | 'center' | 'flex-end'
}) {
  const { topBarHeight } = useAppConfiguration()
  return (
    <Box
      component="nav"
      display="flex"
      justifyContent={justifyContent}
      alignItems="center"
      p={{ xs: 1, sm: 2 }}
      gap={2}
      width={1}
      bgcolor={(theme) => theme.palette.background.surface}
      height={topBarHeight}
    >
      {children}
    </Box>
  )
}

export function TopNavigationTitle({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <Typography
      level="title-sm"
      noWrap
      sx={{ maxWidth: '100%' }}
      width={1}
      textAlign="center"
      flex={1}
    >
      {children}
    </Typography>
  )
}


--- Start of frontend/src/components/common/Icon.tsx ---

import { useTheme } from '@mui/joy'

import { iconMap, type ExternalIconProps } from '@/shared/theme/icons'

// Icon component to render icons dynamically
export const Icon: React.FC<IconProps> = ({
  name,
  color = 'secondary',
  size,
  ...iconProps
}) => {
  const {
    palette: {
      text: { primary, secondary },
      danger,
      success,
      warning,
      neutral,
      common: { white },
    },
  } = useTheme()

  const IconComponent = iconMap[name]
  const iconColor = {
    primary,
    secondary,
    danger: danger['500'],
    success: success['500'],
    warning: warning['500'],
    neutral: neutral['500'],
    white,
  }[color]

  return (
    <IconComponent
      {...iconProps}
      style={{ color: iconColor, fontSize: size }}
    />
  )
}

export type IconName = keyof typeof iconMap

interface IconProps extends ExternalIconProps {
  name: IconName
  color?:
    | 'primary'
    | 'secondary'
    | 'danger'
    | 'success'
    | 'warning'
    | 'neutral'
    | 'white'
  size?: number
}


--- Start of frontend/src/components/common/ErrorMessage.tsx ---

import type { AxiosError } from 'axios'

import Box from '@mui/joy/Box'
import Typography from '@mui/joy/Typography'

import type { HTTPValidationError } from '@/api/models'

export function ErrorContent({
  title = 'Something went wrong',
  message = 'Error',
}: {
  title?: string
  message?: string
}) {
  return (
    <Box
      border={(theme) => `1px solid ${theme.palette.danger[500]}`}
      p={2}
      width={1}
      borderRadius="sm"
    >
      <Typography level="title-sm" textColor="text.error">
        {title}
      </Typography>
      <Typography level="body-xs" textColor="text.error">
        {message}
      </Typography>
    </Box>
  )
}

export function ErrorMessage({
  error,
}: {
  error: AxiosError<HTTPValidationError> | Error | unknown | null
}) {
  // AxiosError handling
  if ((error as AxiosError<HTTPValidationError>)?.isAxiosError) {
    const axiosError = error as AxiosError<HTTPValidationError>
    const detail = axiosError?.response?.data?.detail
    const status = axiosError?.response?.status

    return (
      <ErrorContent
        title="Request failed"
        message={
          typeof detail === 'string' ? detail : (
            `Request failed with status code: ${status}`
          )
        }
      />
    )
  }

  // Generic JavaScript Error handling
  if (error instanceof Error) {
    return <ErrorContent title={error.name} message={error.message} />
  }

  if (typeof error === 'string') {
    return <ErrorContent message={error} title="Error" />
  }

  // Fallback for unknown or null errors
  return (
    <ErrorContent title="Unknown error" message="An unknown error occurred" />
  )
}


--- Start of frontend/src/components/common/LinkListItem.tsx ---

import { memo } from 'react'
import { Link } from 'react-router-dom'

import ListItem, { type ListItemProps } from '@mui/joy/ListItem'

export const LinkListItem = memo((props: ListItemProps & { to: string }) => {
  return (
    <ListItem
      component={Link}
      {...props}
      sx={{
        textDecoration: 'none',
      }}
    />
  )
})


--- Start of frontend/src/components/common/FormWrapper.tsx ---

import Box from '@mui/joy/Box'

export function FormWrapper({
  children,
  onSubmit,
  height = 'auto',
  maxWidth = 400,
}: {
  children: React.ReactNode
  onSubmit: () => void
  height?: string | number
  maxWidth?: number | string
}) {
  return (
    <Box
      component="form"
      onSubmit={onSubmit}
      display="flex"
      flexDirection="column"
      height={{
        xs: '100%',
        sm: height,
      }}
      gap={4}
      p={4}
      width={1}
      maxWidth={{
        xs: '100%',
        sm: maxWidth,
      }}
      justifyContent="center"
      margin="auto"
      alignItems="center"
      bgcolor={(theme) => theme.palette.background.surface}
      borderRadius={{
        xs: 0,
        sm: 'md',
      }}
    >
      {children}
    </Box>
  )
}


--- Start of frontend/src/components/common/index.ts ---

import { AssistantAvatar } from '@/components/common/avatars/AssistantAvatar'
import { CompanyAvatar } from '@/components/common/avatars/CompanyAvatar'
import {
  UserAvatar,
  UserAvatarDropdown,
} from '@/components/common/avatars/UserAvatar'
import { ErrorBoundary } from '@/components/common/ErrorBoundary'
import { ErrorMessage } from '@/components/common/ErrorMessage'
import { FormWrapper } from '@/components/common/FormWrapper'
import { GoBackIconButton } from '@/components/common/GoBackIconButton'
import { Icon } from '@/components/common/Icon'
import { LinkListItem } from '@/components/common/LinkListItem'
import { TypographyWithGradient } from '@/components/common/TypographyWithGradient'

export {
  AssistantAvatar,
  ErrorBoundary,
  ErrorMessage,
  FormWrapper,
  GoBackIconButton,
  Icon,
  LinkListItem,
  CompanyAvatar,
  TypographyWithGradient,
  UserAvatar,
  UserAvatarDropdown,
}


--- Start of frontend/src/components/common/TypographyWithAnimation.tsx ---

import { useCallback, useEffect, useRef, useState } from 'react'

import Box from '@mui/joy/Box'
import Typography from '@mui/joy/Typography'

export function TypographyWithAnimation({
  text,
  speed = 100,
  minOpacity = 0.3,
  maxOpacity = 1,
  rippleWidth = 3,
  color = 'text.secondary',
}: {
  text: string
  speed?: number
  minOpacity?: number
  maxOpacity?: number
  rippleWidth?: number
  color?: string
}) {
  const positionRef = useRef(-rippleWidth)

  const [charOpacities, setCharOpacities] = useState<number[]>([])

  const timerRef = useRef<number | null>(null)

  const calculateOpacity = useCallback(
    (charIndex: number, ripplePos: number) => {
      const distance = Math.abs(charIndex - ripplePos)

      if (distance < rippleWidth) {
        const intensity = 1 - distance / rippleWidth
        return minOpacity + (maxOpacity - minOpacity) * intensity
      }

      return minOpacity
    },
    [minOpacity, maxOpacity, rippleWidth],
  )

  const updateOpacities = useCallback(() => {
    const newOpacities = Array.from({ length: text.length }, (_, i) =>
      calculateOpacity(i, positionRef.current),    )

    setCharOpacities(newOpacities)

    positionRef.current += 1

    if (positionRef.current > text.length + rippleWidth) {
      positionRef.current = -rippleWidth
    }
  }, [text, rippleWidth, calculateOpacity])

  useEffect(() => {
    const initialOpacities = Array.from(
      { length: text.length },
      () => minOpacity,
    )
    setCharOpacities(initialOpacities)

    positionRef.current = -rippleWidth

    if (timerRef.current) {
      window.clearInterval(timerRef.current)
    }

    timerRef.current = window.setInterval(updateOpacities, speed)

    return () => {
      if (timerRef.current) {
        window.clearInterval(timerRef.current)
        timerRef.current = null
      }
    }
  }, [text, speed, minOpacity, maxOpacity, rippleWidth, updateOpacities])

  return (
    <Box sx={{ display: 'inline-flex' }}>
      {text.split('').map((char, index) => (
        <Typography
          key={crypto.randomUUID()}
          level="body-md"
          component="span"
          sx={{
            display: 'inline-block',
            opacity: charOpacities[index] || minOpacity,
            color,
            transition: `opacity ${speed * 0.8}ms ease-in-out`,
          }}
        >
          {char === ' ' ? '\u00A0' : char}
        </Typography>
      ))}
    </Box>
  )
}


--- Start of frontend/src/components/common/GoBackIconButton.tsx ---

import { useNavigate } from 'react-router-dom'

import IconButton from '@mui/joy/IconButton'

import { Icon } from '@/components/common/Icon'

export function GoBackIconButton() {
  const navigate = useNavigate()
  const handleBack = () => {
    navigate('/', { replace: true })
  }

  return (
    <IconButton size="sm" onClick={handleBack}>
      <Icon name="back" />
    </IconButton>
  )
}


--- Start of frontend/src/components/common/TypographyWithGradient.tsx ---

import Typography from '@mui/joy/Typography'

export function TypographyWithGradient({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <Typography
      level="h1"
      sx={{
        background: (theme) =>
          `linear-gradient(45deg, ${theme.palette.primary[200]} 10%, ${theme.palette.primary[400]} 90%)`,
        backgroundClip: 'text',
        WebkitBackgroundClip: 'text',
        WebkitTextFillColor: 'transparent',
      }}
    >
      {children}
    </Typography>
  )
}


--- Start of frontend/src/components/common/ErrorBoundary.tsx ---

import {
  ErrorBoundary as ReactErrorBoundary,
  type ErrorBoundaryProps,
} from 'react-error-boundary'

import { captureException } from '@/shared/analytics/utils'
import { ErrorMessage } from '@/components/common/ErrorMessage'

export function ErrorBoundary({
  children,
}: {
  children?: ErrorBoundaryProps['children']
}) {
  const handleError = (error: Error) => {
    captureException(error)
  }

  return (
    <ReactErrorBoundary
      FallbackComponent={({ error }) => <ErrorMessage error={error} />}
      onError={handleError}
    >
      {children}
    </ReactErrorBoundary>
  )
}


--- Start of frontend/src/components/common/avatars/CompanyAvatar.tsx ---

import { useNavigate } from 'react-router-dom'

import Avatar from '@mui/joy/Avatar'

import CompanyLogo from '@/assets/svgs/company-logo.svg?react'

export function CompanyAvatar() {
  const navigate = useNavigate()

  return (
    <Avatar
      onClick={() => navigate('/')}
      variant="plain"
      size="sm"
      sx={{
        cursor: 'pointer',
        borderRadius: 'sm',
        background: (theme) => theme.palette.primary[500],
      }}
    >
      <CompanyLogo />
    </Avatar>
  )
}


--- Start of frontend/src/components/common/avatars/AssistantAvatar.tsx ---

import type { AvatarProps } from '@mui/joy'
import Avatar from '@mui/joy/Avatar'

export function AssistantAvatar(props: AvatarProps) {
  return (
    <Avatar
      variant="soft"
      sx={{
        border: (theme) => `1px solid ${theme.palette.divider}`,
        backgroundColor: (theme) => theme.palette.background.popup,
      }}
      {...props}
    ></Avatar>
  )
}


--- Start of frontend/src/components/common/avatars/UserAvatar.tsx ---

import { useEffect, useRef, useState } from 'react'
import { useNavigate } from 'react-router-dom'

import Avatar, { type AvatarProps } from '@mui/joy/Avatar'
import Box from '@mui/joy/Box'
import Divider from '@mui/joy/Divider'
import ListItemDecorator from '@mui/joy/ListItemDecorator'
import Menu from '@mui/joy/Menu'
import MenuItem from '@mui/joy/MenuItem'
import Typography from '@mui/joy/Typography'

import { useResponsiveAppMode } from '@/shared/configuration/hooks'
import { useGlobalStore } from '@/shared/store'
import { capitaliseFirstLetter } from '@/shared/utils/capitalise-first-letter'
import type { UserProfile } from '@/api/models'
import { useLogout } from '@/api/services/api'
import { useFeedbackStore } from '@/features/feedback/store'
import { useSettingsStore } from '@/features/settings/store'
import { Icon } from '@/components/common/Icon'

export function UserAvatar({
  authorName,
  ...props
}: {
  authorName?: string
} & AvatarProps) {
  return (
    <Avatar
      {...props}
      variant="solid"
      alt={authorName}
      sx={{
        border: (theme) => `2px solid ${theme.palette.primary[500]}`,
        ...props.sx,
      }}
    />
  )
}

export function UserAvatarDropdown({
  data,
  withMeta = true,
  size = 'sm',
}: {
  data?: UserProfile
  withMeta?: boolean
  size?: 'sm' | 'md'
}) {
  const navigate = useNavigate()
  const { setFeedbackModalOpen } = useFeedbackStore()
  const { setSettingsModalOpen } = useSettingsStore()
  const { sidebarCollapsed } = useGlobalStore()
  const { responsiveAppMode } = useResponsiveAppMode()
  const [open, setOpen] = useState(false)
  const anchorRef = useRef<HTMLDivElement>(null)

  const { mutate } = useLogout({
    mutation: {
      onSuccess() {
        navigate('/login')
      },
    },
  })
  const handleLogout = () => {
    mutate()
    setOpen(false)
  }

  useEffect(() => {
    // listen for clicks outside the dropdown and close it
    const handleClick = (e: MouseEvent) => {
      if (anchorRef.current && !anchorRef.current.contains(e.target as Node)) {
        setOpen(false)
      }
    }
    document.addEventListener('click', handleClick)
    return () => {
      document.removeEventListener('click', handleClick)
    }
  }, [])

  return (
    <>
      <Box
        ref={anchorRef}
        sx={{
          display: 'flex',
          gap: 1,
          alignItems: 'center',
          className: 'ph-no-capture',
        }}
        onClick={() => setOpen(!open)}
      >
        <UserAvatar
          src={data?.imageUrl ?? undefined}
          size={size}
          authorName={capitaliseFirstLetter(data?.username)}
          sx={{ cursor: 'pointer' }}
        />
        {withMeta && !sidebarCollapsed && <UserMetaData data={data} />}
      </Box>
      <Menu
        sx={{ zIndex: 1000, minWidth: '200px' }}
        open={open}
        anchorEl={anchorRef.current}
        placement="top-end"
        disablePortal={responsiveAppMode === 'widget'}
      >
        <Box
          p={1}
          sx={{ display: 'flex', gap: 1, alignItems: 'center', mb: 1 }}
        >
          <UserAvatar
            src={data?.imageUrl ?? undefined}
            size={size}
            authorName={capitaliseFirstLetter(data?.username)}
            sx={{ cursor: 'pointer' }}
          />
          <Box sx={{ display: 'flex', flexDirection: 'column' }}>
            {data?.username && (
              <Typography level="body-xs" textColor="text.primary" noWrap>
                {capitaliseFirstLetter(data?.username)}
              </Typography>
            )}
            <Typography level="body-xs" textColor="text.secondary" noWrap>
              {data?.email}
            </Typography>
          </Box>
        </Box>
        <MenuItem
          onClick={() =>
            setFeedbackModalOpen({ open: true, scope: 'application' })
          }
          sx={{
            display: 'flex',
            gap: 1,
            justifyContent: 'space-between',
          }}
        >
          <Typography level="body-sm" textColor="text.primary">
            Feedback
          </Typography>
          <ListItemDecorator>
            <Icon name="thumbsUp" />
          </ListItemDecorator>
        </MenuItem>
        <MenuItem
          onClick={() => setSettingsModalOpen({ open: true })}
          sx={{
            display: 'flex',
            gap: 1,
            justifyContent: 'space-between',
          }}
        >
          <Typography level="body-sm" textColor="text.primary">
            Settings
          </Typography>
          <ListItemDecorator>
            <Icon name="settings" />
          </ListItemDecorator>
        </MenuItem>
        <Divider sx={{ my: 1 }} />
        <MenuItem
          onClick={handleLogout}
          sx={{
            display: 'flex',
            gap: 1,
            justifyContent: 'space-between',
          }}
        >
          <Typography level="body-sm" textColor="text.primary">
            Logout
          </Typography>
          <ListItemDecorator>
            <Icon name="logout" />
          </ListItemDecorator>
        </MenuItem>
      </Menu>
    </>
  )
}

function UserMetaData({ data }: { data?: UserProfile }) {
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column' }}>
      {data?.username && (
        <Typography level="body-xs" textColor="text.primary" noWrap>
          {capitaliseFirstLetter(data?.username)}
        </Typography>
      )}
      <Typography level="body-xs" textColor="text.secondary" noWrap>
        {data?.email}
      </Typography>
    </Box>
  )
}


--- Start of frontend/src/components/interactive/LoginWithGoogleButton.tsx ---

import { useTranslation } from 'react-i18next'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'

import { useSsoGoogleLogin } from '@/api/services/api'
import GoogleLogo from '@/assets/svgs/google.svg?react'

export function LoginWithGoogleButton() {
  const { t } = useTranslation()

  const {
    isError,
    refetch,
    isLoading,
    data: redirectUrl,
  } = useSsoGoogleLogin({
    query: {
      enabled: false,
    },

    request: {},
  })

  if (redirectUrl != null) {
    window.location.replace(redirectUrl)
  }

  const handleGoogleLogin = () => {
    refetch()
  }

  return (
    <Button
      loading={isLoading}
      onClick={handleGoogleLogin}
      variant="outlined"
      size="lg"
      color={isError ? 'danger' : 'neutral'}
      startDecorator={
        <Box
          display="flex"
          alignItems="center"
          justifyContent="center"
          width={24}
          height={24}
          borderRadius="full"
          bgcolor="background.paper"
        >
          <GoogleLogo />
        </Box>
      }
    >
      {t('login.form.google.submit')}
    </Button>
  )
}


--- Start of frontend/src/components/interactive/UserInput.tsx ---

import { useFormContext, type FieldValues, type Path } from 'react-hook-form'
import { useTranslation } from 'react-i18next'

import Box from '@mui/joy/Box'
import FormControl from '@mui/joy/FormControl'
import FormHelperText from '@mui/joy/FormHelperText'
import FormLabel from '@mui/joy/FormLabel'
import Input, { type InputProps } from '@mui/joy/Input'
import Tooltip from '@mui/joy/Tooltip'
import Typography from '@mui/joy/Typography'

import { Icon } from '@/components/common/Icon'

export function UserInput<FormValues extends FieldValues>({
  type,
  inputId,
  customProps,
  i18nId,
  withTooltip,
}: {
  type: string
  inputId: Path<FormValues>
  customProps?: InputProps
  withTooltip?: boolean
  i18nId: {
    label: string
    helperText?: string
  }
}) {
  const { t } = useTranslation()
  const {
    register,
    formState: { errors },
  } = useFormContext<FormValues>()
  const error = errors[inputId] as FieldValues[string]

  return (
    <FormControl error={!!error}>
      <Box display="flex" gap={1} alignItems="start">
        <FormLabel htmlFor={`input-${inputId}`}>{t(i18nId?.label)}</FormLabel>
        {withTooltip && i18nId?.helperText && (
          <Tooltip
            variant="soft"
            placement="bottom"
            arrow
            title={
              <Box
                sx={{ maxWidth: 250 }}
                display="flex"
                flexDirection="column"
                gap={0.5}
              >
                <Typography
                  level="body-xs"
                  fontWeight="bold"
                  textColor="text.primary"
                >
                  {t(i18nId?.label)}
                </Typography>
                <Typography level="body-xs">{t(i18nId?.helperText)}</Typography>
              </Box>
            }
          >
            <Box
              sx={{
                cursor: 'pointer',
                display: {
                  xs: 'none',
                  sm: 'block',
                },
              }}
            >
              <Icon size={16} name="info" />
            </Box>
          </Tooltip>
        )}
      </Box>

      <Input
        {...register(inputId)}
        type={type}
        variant="soft"
        slotProps={{
          input: {
            id: `input-${inputId}`,
          },
        }}
        {...customProps}
      />
      {error && (
        <FormHelperText
          sx={{
            fontSize: (theme) => theme.typography['body-xs'].fontSize,
          }}
        >
          {error?.message as string}
        </FormHelperText>
      )}
    </FormControl>
  )
}


--- Start of frontend/src/components/interactive/TextareaAssetList.tsx ---

import Box from '@mui/joy/Box'
import IconButton from '@mui/joy/IconButton'
import Stack from '@mui/joy/Stack'

import type { AssetCreateError } from '@/api/models'
import { useMessageAssetsStore } from '@/features/conversation/store'
import { Asset, AssetError } from '@/components/common/assets/Asset'
import { Icon } from '@/components/common/Icon'

export function TextareaAssetList() {
  const { messageAssets, messageAssetErrors } = useMessageAssetsStore()

  // sort by createdAt and file type
  const sortedAssets = messageAssets?.sort((a, b) => {
    return a.type.localeCompare(b.type)
  })

  if (!sortedAssets?.length && !messageAssetErrors?.length) {
    return null
  }

  return (
    <Stack
      gap={1}
      direction="row"
      display="flex"
      flexWrap="wrap"
      overflow="auto"
      my={sortedAssets?.length || messageAssetErrors?.length ? 1 : 0}
    >
      {sortedAssets?.map((asset) => <Asset key={asset.uuid} asset={asset} />)}
      {messageAssetErrors?.map((error) => (
        <TextareaAssetUploadError key={error.originalFilename} error={error} />
      ))}
    </Stack>
  )
}

export function TextareaAssetUploadError({
  error,
}: {
  error: AssetCreateError
}) {
  const { messageAssetErrors, removeMessageAssetError } =
    useMessageAssetsStore()

  if (!messageAssetErrors?.length) {
    return null
  }

  return (
    <Box key={`${error?.originalFilename}`} position="relative">
      <AssetError name={error?.originalFilename} error={error.error} />
      <IconButton
        onClick={() => removeMessageAssetError(error?.originalFilename)}
        size="sm"
        variant="soft"
        sx={{
          position: 'absolute',
          top: -8,
          right: -8,
          borderRadius: '50%',
          minWidth: 0,
          minHeight: 0,
          width: 16,
          height: 16,
        }}
      >
        <Icon name="close" size={16} />
      </IconButton>
    </Box>
  )
}


--- Start of frontend/src/components/interactive/DropzoneInput.tsx ---

import { useDropzone } from 'react-dropzone'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Typography from '@mui/joy/Typography'

import type { SupportedFileExtensionsResponse } from '@/api/models'
import { Icon } from '@/components/common/Icon'

export function DropzoneInput({
  onDrop,
  isPending,
  isError,
  accept,
  disabled,
}: {
  onDrop: (files: File[]) => void
  isPending?: boolean
  isError?: boolean
  accept?: SupportedFileExtensionsResponse
  disabled?: boolean
}) {
  const { getRootProps, getInputProps, isDragActive, inputRef } = useDropzone({
    onDrop,
    multiple: true,
  })

  return (
    <Box
      sx={{
        border: '1px dashed',
        p: 2,
        borderRadius: 'sm',
        alignItems: 'center',
        justifyContent: 'center',
        flexDirection: 'column',
        height: 150,
        width: '100%',
        display: 'flex',
        gap: 1,
        cursor: 'pointer',
        borderColor: isDragActive ? 'primary.400' : 'divider',
        backgroundColor: (theme) =>
          isDragActive ? theme.palette.background.level2 : 'transparent',
      }}
      {...getRootProps()}
    >
      <input
        disabled={disabled}
        {...getInputProps()}
        ref={inputRef}
        accept={accept?.all?.join(',')}
      />
      <Typography level="body-sm" textColor="text.secondary">
        Drag and drop files here, or:
      </Typography>
      <Button
        size="sm"
        disabled={disabled}
        variant="outlined"
        color={isError ? 'danger' : 'neutral'}
        loading={isPending}
        endDecorator={
          isError ?
            <Icon name="regenerate" color="danger" />
          : <Icon name="assetUpload" />
        }
      >
        {isPending ?
          'Uploading...'
        : isError ?
          'Retry Upload'
        : 'Select Files'}
      </Button>
    </Box>
  )
}


--- Start of frontend/src/components/interactive/index.ts ---

import { AgentModelSelectionDropdown } from '@/features/agent/components/AgentModelSelectionDropdown'
import { UserAvatarDropdown } from '@/components/common/avatars/UserAvatar'
import { TypographyWithGradient } from '@/components/common/TypographyWithGradient'
import { LoginWithGoogleButton } from '@/components/interactive/LoginWithGoogleButton'
import { Textarea } from '@/components/interactive/Textarea'
import { UserInput } from '@/components/interactive/UserInput'

export {
  AgentModelSelectionDropdown,
  LoginWithGoogleButton,
  Textarea,
  TypographyWithGradient,
  UserAvatarDropdown,
  UserInput,
}


--- Start of frontend/src/components/interactive/ModalDialog.tsx ---

import Modal from '@mui/joy/Modal'
import ModalClose from '@mui/joy/ModalClose'
import ModalDialog, { type ModalDialogProps } from '@mui/joy/ModalDialog'

import {
  useAppConfiguration,
  useResponsiveAppMode,
} from '@/shared/configuration'

const widgetStyleModalDialog = {
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  maxHeight: '100%',
}

export function ModalDialogBase({
  onClose,
  open,
  children,
  modalDialogProps,
  withCloseButton = true,
  disablePortal = false,
}: {
  onClose: () => void
  open: boolean
  children: React.ReactNode
  modalDialogProps?: Partial<ModalDialogProps>
  withCloseButton?: boolean
  disablePortal?: boolean
}) {
  const { widgetContainerId, standaloneContainerId } = useAppConfiguration()
  const { responsiveAppMode, isSmallScreen } = useResponsiveAppMode()
  const container = document.getElementById(
    responsiveAppMode === 'widget' ? widgetContainerId : standaloneContainerId,
  )

  return (
    <Modal
      onClose={onClose}
      open={open}
      container={container}
      disablePortal={disablePortal}
      sx={{
        position: responsiveAppMode === 'widget' ? 'absolute' : 'fixed',
      }}
      slotProps={{
        backdrop: {
          sx: {
            filter: 'none',
            backdropFilter: 'none',
            position: responsiveAppMode === 'widget' ? 'absolute' : 'fixed',
          },
        },
      }}
    >
      <ModalDialog
        variant="outlined"
        maxWidth={responsiveAppMode === 'desktop' ? 'md' : undefined}
        minWidth={responsiveAppMode === 'desktop' ? 'sm' : undefined}
        layout={isSmallScreen ? 'fullscreen' : 'center'}
        sx={{
          width: '100%',
          overflowY: 'scroll',
          overflowX: 'hidden',
          backgroundColor: (theme) => theme.palette.background.body,
          ...(responsiveAppMode === 'widget' ?
            widgetStyleModalDialog
          : undefined),
        }}
        {...modalDialogProps}
      >
        {withCloseButton && <ModalClose />}
        {children}
      </ModalDialog>
    </Modal>
  )
}


--- Start of frontend/src/components/interactive/TextareaAssetInput.tsx ---

import FormControl from '@mui/joy/FormControl'
import IconButton from '@mui/joy/IconButton'
import Input from '@mui/joy/Input'
import Stack from '@mui/joy/Stack'

import type { SupportedFileExtensionsResponse } from '@/api/models'
import { Icon } from '@/components/common/Icon'

export function TextareaAssetInput({
  uploadIsPending,
  uploadIsError,
  getInputProps,
  supportedExtensions,
}: {
  uploadIsPending: boolean
  uploadIsError: boolean
  getInputProps: () => React.InputHTMLAttributes<HTMLInputElement>
  supportedExtensions?: SupportedFileExtensionsResponse
}) {
  return (
    <Stack gap={0.5} direction="row">
      <IconButton
        component="label"
        role={undefined}
        tabIndex={-1}
        variant={uploadIsError ? 'outlined' : 'plain'}
        color="neutral"
        loading={uploadIsPending}
      >
        <Icon
          name={uploadIsError ? 'regenerate' : 'assetUpload'}
          color={uploadIsError ? 'danger' : 'primary'}
        />
        <FormControl>
          <Input
            type="file"
            slotProps={{
              input: {
                ...getInputProps(),
                multiple: true,
                accept: supportedExtensions?.all.join(','),
              },
            }}
            sx={{
              clip: 'rect(0 0 0 0)',
              clipPath: 'inset(50%)',
              height: '1px',
              overflow: 'hidden',
              position: 'absolute',
              bottom: '0',
              left: '0',
              whiteSpace: 'nowrap',
              width: '1px',
            }}
          />
        </FormControl>
      </IconButton>
    </Stack>
  )
}


--- Start of frontend/src/components/interactive/TextareaToolbar.tsx ---

import { memo } from 'react'
import type { DropzoneInputProps } from 'react-dropzone'

import Box from '@mui/joy/Box'
import IconButton from '@mui/joy/IconButton'

import { useListenForKeyAndCallback } from '@/shared/hooks'
import type { SupportedFileExtensionsResponse } from '@/api/models'
import {
  useHandleResetSteamingError,
  useHandleStopSteaming,
  useMessageStreamingState,
} from '@/features/conversation/hooks'
import { Icon } from '@/components/common/Icon'
import { TextareaAssetInput } from '@/components/interactive/TextareaAssetInput'

export const TextareaToolbar = memo(
  ({
    conversationUuid,
    getInputProps,
    inputActive,
    onSendMessage,
    supportedExtensions,
    uploadIsError,
    uploadIsPending,
  }: {
    conversationUuid?: string
    getInputProps: <T extends DropzoneInputProps>(props?: T) => T
    inputActive: boolean
    onSendMessage: () => void
    supportedExtensions?: SupportedFileExtensionsResponse
    uploadIsError: boolean
    uploadIsPending: boolean
  }) => {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          width: '100%',
        }}
      >
        <TextareaAssetInput
          getInputProps={getInputProps}
          uploadIsError={uploadIsError}
          uploadIsPending={uploadIsPending}
          supportedExtensions={supportedExtensions}
        />
        <TextAreaSendOrStopButton
          conversationUuid={conversationUuid}
          onSendMessage={onSendMessage}
          inputActive={inputActive}
        />
      </Box>
    )
  },
)

function TextAreaSendOrStopButton({
  conversationUuid,
  onSendMessage,
  inputActive,
}: {
  conversationUuid?: string
  onSendMessage: () => void
  inputActive: boolean
}) {
  const { messageStreamIsPending } = useMessageStreamingState({
    conversationUuid,
  })
  const { handleResetError } = useHandleResetSteamingError()
  const { handleStopStream } = useHandleStopSteaming()

  useListenForKeyAndCallback({
    handkleKeyDown(e) {
      if (e.key === 'Enter' && e.shiftKey) {
        return
      }
      if (e.key === 'Enter') {
        const disableKeypress = messageStreamIsPending || !inputActive
        if (disableKeypress) {
          return
        }
        e.preventDefault()
        onSendMessage()
      }
    },
  })
  if (messageStreamIsPending) {
    return (
      <IconButton
        variant="solid"
        color="primary"
        size="md"
        onClick={handleStopStream}
      >
        <Icon name="stop" color="white" />
      </IconButton>
    )
  }
  return (
    <IconButton
      disabled={!inputActive}
      variant={inputActive ? 'solid' : 'soft'}
      color={inputActive ? 'primary' : 'neutral'}
      size="md"
      onClick={
        inputActive ?
          () => {
            onSendMessage()
            handleResetError()
          }
        : undefined
      }
    >
      <Icon name="send" color={inputActive ? 'white' : 'neutral'} />
    </IconButton>
  )
}


--- Start of frontend/src/components/interactive/Textarea.tsx ---

import { memo, useCallback, useEffect } from 'react'
import { useDropzone } from 'react-dropzone'
import { useTranslation } from 'react-i18next'
import { useLocation } from 'react-router-dom'
import { t } from 'i18next'

import FormControl from '@mui/joy/FormControl'
import FormHelperText from '@mui/joy/FormHelperText'
import BaseTextarea from '@mui/joy/Textarea'

import { useResponsiveAppMode } from '@/shared/configuration'
import type { SupportedFileExtensionsResponse } from '@/api/models'
import { useCreateAssets } from '@/api/services/api'
import {
  useHandleResetSteamingError,
  useMessageStreamingState,
} from '@/features/conversation/hooks'
import {
  useMessageAssetsStore,
  useMessageStore,
} from '@/features/conversation/store'
import { TextareaAssetList } from '@/components/interactive/TextareaAssetList'
import { TextareaToolbar } from '@/components/interactive/TextareaToolbar'

const TextareaFormHelper = memo(
  ({ conversationUuid }: { conversationUuid?: string }) => {
    const { messageStreamIsError, messageStreamError } =
      useMessageStreamingState({ conversationUuid })
    return (
      <FormHelperText
        sx={{
          fontSize: (theme) => theme.typography['body-xs'].fontSize,
          color: messageStreamIsError ? 'danger.500' : 'text.secondary',
          textAlign: 'center',
          justifyContent: 'center',
          display: 'flex',
        }}
      >
        {messageStreamIsError ?
          `Something went wrong: ${messageStreamError}. Try with another llm model`
        : t('general.textarea.helperText')}
      </FormHelperText>
    )
  },
)

export function Textarea({
  conversationUuid,
  supportedExtensions,
  onSendMessage,
}: {
  conversationUuid?: string
  supportedExtensions?: SupportedFileExtensionsResponse
  onSendMessage: () => void
}) {
  const location = useLocation()
  const { t } = useTranslation()
  const { isSmallScreen } = useResponsiveAppMode()
  const { message, setMessage } = useMessageStore()
  const { handleResetError } = useHandleResetSteamingError()
  const { setMessageAssets, setMessageAssetErrors } = useMessageAssetsStore()
  const {
    mutate: uploadAsset,
    isError: uploadAssetIsError,
    isPending: uploadAssetIsPending,
  } = useCreateAssets()

  const handleUploadAssets = useCallback(
    async (acceptedFiles: File[]) => {
      await uploadAsset(
        { data: { files: acceptedFiles }, params: { conversationUuid } },
        {
          onSuccess(data) {
            if (!data) {
              return
            }
            setMessageAssets(data?.items)
            setMessageAssetErrors(data?.errors)
          },
        },
      )
    },
    [conversationUuid, setMessageAssetErrors, setMessageAssets, uploadAsset],
  )

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    multiple: true,
    onDrop: (acceptedFiles) => {
      handleUploadAssets(acceptedFiles)
    },
  })

  useEffect(() => {
    setMessage('')
    handleResetError()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [location.pathname])

  return (
    <FormControl
      sx={{
        mb: 1,
      }}
      slotProps={{
        root: {
          ...getRootProps(),
          onClick: (e) => {
            e.stopPropagation()
          },
        },
      }}
    >
      <BaseTextarea
        name="message"
        className="textarea"
        placeholder={t('general.textarea.inputPlaceholder')}
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        minRows={isSmallScreen ? 1 : 2}
        variant="soft"
        maxRows={20}
        startDecorator={<TextareaAssetList />}
        sx={{
          ...(isDragActive && {
            backgroundColor: (theme) => theme.palette.background.level3,
            borderColor: (theme) => theme.palette.primary,
          }),
        }}
        slotProps={{
          startDecorator: {
            style: {
              display: 'flex',
              overflow: 'hidden',
              flexWrap: 'wrap',
            },
          },
        }}
        endDecorator={
          <TextareaToolbar
            getInputProps={getInputProps}
            uploadIsError={uploadAssetIsError}
            uploadIsPending={uploadAssetIsPending}
            supportedExtensions={supportedExtensions}
            onSendMessage={onSendMessage}
            conversationUuid={conversationUuid}
            inputActive={message?.trim().length > 0}
          />
        }
      />
      <TextareaFormHelper conversationUuid={conversationUuid} />
    </FormControl>
  )
}


--- Start of frontend/src/api/api-base.tsx ---

import { handle401Error } from './utils/handle-401-error'
import Axios, { type AxiosHeaders } from 'axios'

import { env } from '@/env'
import {
  transformKeysToCamelCase,
  transformKeysToSnakeCase,
} from '@/shared/utils/case-transformers'

export const baseHeaders: Partial<AxiosHeaders> = {
  'Content-Type': 'application/json',
  Accept: 'application/json',
  'access-control-allow-credentials': 'true',
}

export const apiBase = Axios.create({
  baseURL: env?.VITE__API_BASE_URL,
  withCredentials: true,
  headers: {
    ...baseHeaders,
  },
})

/**
 * Request interceptors
 * Intercept requests before they are sent to the server
 */

// Request interceptor to transform all outgoing data keys to snake_case
apiBase.interceptors.request.use((config) => {
  if (config?.headers['Content-Type'] === 'application/x-www-form-urlencoded') {
    return config
  }

  const snakeCaseData = transformKeysToSnakeCase(config.data)
  const snakeCaseParams = transformKeysToSnakeCase(config.params)
  return { ...config, data: snakeCaseData, params: snakeCaseParams }
})

/**
 * Response interceptors
 * Intercept responses before they are handled by the calling function
 */

// Response interceptor to change all incoming data keys to camelCase
apiBase.interceptors.response.use((response) => {
  if (response.data) {
    const camelCaseData = transformKeysToCamelCase(response.data)
    return { ...response, data: camelCaseData }
  }
  return response
})

/**
 * Auth interceptor
 * Intercept responses to check for 401 errors and handle them accordingly
 * Will redirect the user to the login page if they are unauthorized and
 * acts as the main authentication handler for the application.
 */

// It's important to ignore these, otherwise we'll get into an infinite loop.
const ignoreEndpoints = [
  '/api/user/register',
  '/api/auth/login',
  '/api/auth/check',
  '/api/user/profile',
]
apiBase.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.config?.url && ignoreEndpoints.includes(error.config?.url)) {
      return Promise.reject(error)
    }

    if (error.response?.status === 401) {
      return handle401Error({ error })
    }

    // If the error is not a 401 or it's already a retry, just reject it
    return Promise.reject(error)
  },
)


--- Start of frontend/src/api/api-sse-base.tsx ---

import {
  fetchEventSource,
  type EventSourceMessage,
} from '@microsoft/fetch-event-source'

import { env } from '@/env'
import { captureException } from '@/shared/analytics/utils'
import {
  transformKeysToCamelCase,
  transformKeysToSnakeCase,
} from '@/shared/utils/case-transformers'
import { baseHeaders } from '@/api/api-base'

// Custom SSE fetch function.
const EVENT_STREAM_RESPONSE_TYPE = 'text/event-stream; charset=utf-8'

export async function fetchWithSSE<DataType, Params>({
  url,
  method,
  headers = {},
  params,
  body,
  onSSEMessage,
  onSSEError,
  onSSEOpen,
  onSSEClose,
  signal,
}: {
  url: string
  method: string
  headers?: Record<string, string>
  body?: any
  params?: Params
  onSSEMessage: (
    message: { data: DataType } & Omit<EventSourceMessage, 'data'>,
  ) => void
  onSSEError?: (error: Error) => void
  onSSEOpen?: () => void
  onSSEClose?: () => void
  signal?: AbortSignal
}) {
  const fullURL = `${env?.VITE__API_BASE_URL}${url}?${new URLSearchParams(transformKeysToSnakeCase(params ?? {})).toString()}`

  return fetchEventSource(fullURL, {
    method,
    credentials: 'include',
    headers: { ...baseHeaders, ...headers },
    signal,
    openWhenHidden: true,
    body: body ? JSON.stringify(transformKeysToSnakeCase(body)) : undefined,
    onmessage(ev) {
      if (!ev.data || ev.data === 'ping')
return

      try {
        const data = JSON.parse(ev.data)
        onSSEMessage({ ...ev, data: transformKeysToCamelCase(data) })
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err))
        onSSEError?.(error)
        throw error
      }
    },

    async onopen(response) {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      const contentType = response.headers.get('content-type')
      if (contentType !== EVENT_STREAM_RESPONSE_TYPE) {
        throw new Error(`Invalid content type: ${contentType}`)
      }

      await onSSEOpen?.()
    },

    onerror(err) {
      const error = err instanceof Error ? err : new Error(String(err))
      captureException(error)
      onSSEError?.(error)
      throw error
    },

    onclose() {
      onSSEClose?.()
    },
  })
}


--- Start of frontend/src/api/utils/handle-401-error.ts ---

import { redirectToLogin } from '@/shared/utils/redirect-to-login'

/**
 * Handle 401 error
 * @returns Axios request
 */
export async function handle401Error({ error }: { error: any }) {
  redirectToLogin()
  return Promise.reject(error)
}


--- Start of frontend/src/api/models/toolReadResponseOptionsSchemaAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolReadResponseOptionsSchemaAnyOf = { [key: string]: unknown }


--- Start of frontend/src/api/models/assetSearchResultSummary.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultSummary = string | null


--- Start of frontend/src/api/models/userRegistrationRequestCountry.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestCountry = string | null


--- Start of frontend/src/api/models/patchUserRequestCountry.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestCountry = string | null


--- Start of frontend/src/api/models/feedbackCreate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { FeedbackCreateRating } from './feedbackCreateRating'
import type { FeedbackCreateTargetUuid } from './feedbackCreateTargetUuid'
import type { FeedbackCreateUrl } from './feedbackCreateUrl'
import type { FeedbackTarget } from './feedbackTarget'
import type { FeedbackType } from './feedbackType'

export interface FeedbackCreate {
  /** @minLength 1 */
  feedback: string
  rating?: FeedbackCreateRating
  target: FeedbackTarget
  /** Optional for application feedback, required for all others */
  targetUuid?: FeedbackCreateTargetUuid
  type: FeedbackType
  /** Required for application feedback, optional for all others */
  url?: FeedbackCreateUrl
  userUuid: string
}


--- Start of frontend/src/api/models/messageUpdate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageUpdateAssetUuids } from './messageUpdateAssetUuids'
import type { MessageUpdateContent } from './messageUpdateContent'

export interface MessageUpdate {
  /** UUIDs for assets attached to message. Set to [] to remove all assets. */
  assetUuids?: MessageUpdateAssetUuids
  /** New message content */
  content?: MessageUpdateContent
}


--- Start of frontend/src/api/models/assetSearchResultContent.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultContent = string | null


--- Start of frontend/src/api/models/searchResultsResponseConversation.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationIndexResults } from './conversationIndexResults'

export type SearchResultsResponseConversation = ConversationIndexResults | null


--- Start of frontend/src/api/models/generationSettings.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { GenerationSettingsExtra } from './generationSettingsExtra'
import type { GenerationSettingsMaxOutputTokens } from './generationSettingsMaxOutputTokens'
import type { GenerationSettingsReasoningEffort } from './generationSettingsReasoningEffort'

export interface GenerationSettings {
  cachingEnabled?: boolean
  extra?: GenerationSettingsExtra
  maxOutputTokens?: GenerationSettingsMaxOutputTokens
  reasoningEffort?: GenerationSettingsReasoningEffort
  stopSequences?: string[]
  temperature?: number
}


--- Start of frontend/src/api/models/defaultConversationSettings.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface DefaultConversationSettings {
  agentUuid?: string
}


--- Start of frontend/src/api/models/agentCreate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentCreateBaselineConfigUuid } from './agentCreateBaselineConfigUuid'
import type { AgentCreateDescription } from './agentCreateDescription'

export interface AgentCreate {
  baselineConfigUuid?: AgentCreateBaselineConfigUuid
  description?: AgentCreateDescription
  llmModelId: string
  name: string
}


--- Start of frontend/src/api/models/textMessageSectionTemplateTitle.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type TextMessageSectionTemplateTitle = string | null


--- Start of frontend/src/api/models/feedbackResponseConversationUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackResponseConversationUuid = string | null


--- Start of frontend/src/api/models/toolReadResponseOptionsSchema.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolReadResponseOptionsSchemaAnyOf } from './toolReadResponseOptionsSchemaAnyOf'

export type ToolReadResponseOptionsSchema =
  ToolReadResponseOptionsSchemaAnyOf | null


--- Start of frontend/src/api/models/auditLogReadResponseMessageUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseMessageUuid = string | null


--- Start of frontend/src/api/models/agentConfigCreate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentConfigCreateNotes } from './agentConfigCreateNotes'
import type { AgentConfigCreateToolUseSectionTemplates } from './agentConfigCreateToolUseSectionTemplates'
import type { AgentStockResponses } from './agentStockResponses'
import type { PromptTemplateInput } from './promptTemplateInput'
import type { Tool } from './tool'

export interface AgentConfigCreate {
  isActive: boolean
  name: string
  notes?: AgentConfigCreateNotes
  promptTemplate: PromptTemplateInput
  stockResponses: AgentStockResponses
  toolUseSectionTemplates?: AgentConfigCreateToolUseSectionTemplates
  tools?: Tool[]
}


--- Start of frontend/src/api/models/feedbackResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { FeedbackResponseAgentUuid } from './feedbackResponseAgentUuid'
import type { FeedbackResponseAssetUuid } from './feedbackResponseAssetUuid'
import type { FeedbackResponseConversationUuid } from './feedbackResponseConversationUuid'
import type { FeedbackResponseMessageUuid } from './feedbackResponseMessageUuid'
import type { FeedbackResponseRating } from './feedbackResponseRating'
import type { FeedbackResponseUpdatedAt } from './feedbackResponseUpdatedAt'
import type { FeedbackResponseUrl } from './feedbackResponseUrl'
import type { FeedbackTarget } from './feedbackTarget'
import type { FeedbackType } from './feedbackType'

export interface FeedbackResponse {
  agentUuid?: FeedbackResponseAgentUuid
  assetUuid?: FeedbackResponseAssetUuid
  conversationUuid?: FeedbackResponseConversationUuid
  createdAt: string
  feedback: string
  messageUuid?: FeedbackResponseMessageUuid
  rating?: FeedbackResponseRating
  target: FeedbackTarget
  type: FeedbackType
  updatedAt?: FeedbackResponseUpdatedAt
  url?: FeedbackResponseUrl
  userUuid: string
  uuid: string
  [key: string]: unknown
}


--- Start of frontend/src/api/models/toolOutputFile.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolOutputFileDescription } from './toolOutputFileDescription'
import type { ToolOutputFileLocalPath } from './toolOutputFileLocalPath'
import type { ToolOutputFileRemotePath } from './toolOutputFileRemotePath'

export interface ToolOutputFile {
  description?: ToolOutputFileDescription
  localPath?: ToolOutputFileLocalPath
  name: string
  remotePath?: ToolOutputFileRemotePath
}


--- Start of frontend/src/api/models/toolUseInfo.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolOutputFile } from './toolOutputFile'
import type { ToolUseInfoCompletedAt } from './toolUseInfoCompletedAt'
import type { ToolUseInfoGenerationContext } from './toolUseInfoGenerationContext'
import type { ToolUseInfoInputs } from './toolUseInfoInputs'
import type { ToolUseInfoOutputs } from './toolUseInfoOutputs'
import type { ToolUseStatus } from './toolUseStatus'

/**
 * ID is defaulted for backwards compatibility with existing tool use info objects.
For new objects, the ID should be set to the tool_use_id from the tool call.
 */
export interface ToolUseInfo {
  completedAt?: ToolUseInfoCompletedAt
  costUsd?: number
  description: string
  displayName: string
  readonly durationMs: number
  generationContext?: ToolUseInfoGenerationContext
  id?: string
  inProgressText?: string
  inputText?: string
  inputs?: ToolUseInfoInputs
  instructions: string
  name: string
  outputFiles?: ToolOutputFile[]
  outputText?: string
  outputs?: ToolUseInfoOutputs
  startedAt?: string
  status?: ToolUseStatus
}


--- Start of frontend/src/api/models/searchHistoryResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface SearchHistoryResponse {
  queries: string[]
}


--- Start of frontend/src/api/models/feedbackResponseRating.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { FeedbackRating } from './feedbackRating'

export type FeedbackResponseRating = FeedbackRating | null


--- Start of frontend/src/api/models/availableResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface AvailableResponse {
  available: boolean
}


--- Start of frontend/src/api/models/agentConfigCreateFromExistingIsActive.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigCreateFromExistingIsActive = boolean | null


--- Start of frontend/src/api/models/toolOutputFileRemotePath.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolOutputFileRemotePath = string | null


--- Start of frontend/src/api/models/messageCreateAgentConfigUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

/**
 * If not passed, the currently active config will be used
 */
export type MessageCreateAgentConfigUuid = string | null


--- Start of frontend/src/api/models/generationSettingsMaxOutputTokens.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationSettingsMaxOutputTokens = number | null


--- Start of frontend/src/api/models/messageReadResponseAssets.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetReadResponse } from './assetReadResponse'

export type MessageReadResponseAssets = AssetReadResponse[] | null


--- Start of frontend/src/api/models/ingestionErrorType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionErrorType =
  (typeof IngestionErrorType)[keyof typeof IngestionErrorType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IngestionErrorType = {
  parsingError: 'parsing_error',
  fileExtensionNotSupported: 'file_extension_not_supported',
  fileNotFound: 'file_not_found',
  fileExtensionInvalid: 'file_extension_invalid',
  fileOpenError: 'file_open_error',
  fileEncodingError: 'file_encoding_error',
  fileValidationError: 'file_validation_error',
  noContentFound: 'no_content_found',
  processingError: 'processing_error',
  processingTimeout: 'processing_timeout',
  indexingError: 'indexing_error',
} as const


--- Start of frontend/src/api/models/generationSettingsExtra.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationSettingsExtra = { [key: string]: string }


--- Start of frontend/src/api/models/assetSearchResultConversationName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultConversationName = string | null


--- Start of frontend/src/api/models/reasoningEffort.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ReasoningEffort =
  (typeof ReasoningEffort)[keyof typeof ReasoningEffort]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningEffort = {
  low: 'low',
  medium: 'medium',
  high: 'high',
} as const


--- Start of frontend/src/api/models/tool.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolOptions } from './toolOptions'

export interface Tool {
  options?: ToolOptions
  registryId: string
}


--- Start of frontend/src/api/models/textMessageSectionTemplateId.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { TextMessageSectionID } from './textMessageSectionID'

export type TextMessageSectionTemplateId = TextMessageSectionID | null


--- Start of frontend/src/api/models/ingestionMetadataFailedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionMetadataFailedAt = string | null


--- Start of frontend/src/api/models/messageReadResponseConversationNameUpdatedStreaming.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

/**
 * When streaming messages, this field is used to update the conversation name at the end of the stream
 */
export type MessageReadResponseConversationNameUpdatedStreaming = string | null


--- Start of frontend/src/api/models/conversationListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationReadResponse } from './conversationReadResponse'

export interface ConversationListResponse {
  items: ConversationReadResponse[]
}


--- Start of frontend/src/api/models/assetIndexResults.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetIndexResultsFilters } from './assetIndexResultsFilters'
import type { AssetSearchResult } from './assetSearchResult'

export interface AssetIndexResults {
  filters: AssetIndexResultsFilters
  hits: AssetSearchResult[]
  indexName?: string
  limit: number
  offset: number
  processingTimeMs: number
  query: string
  totalHits: number
}


--- Start of frontend/src/api/models/userAppSettings.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { UserAppSettingsTheme } from './userAppSettingsTheme'

export interface UserAppSettings {
  theme?: UserAppSettingsTheme
}


--- Start of frontend/src/api/models/patchUserRequest.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { PatchUserRequestAppSettings } from './patchUserRequestAppSettings'
import type { PatchUserRequestCountry } from './patchUserRequestCountry'
import type { PatchUserRequestDefaultConversationSettings } from './patchUserRequestDefaultConversationSettings'
import type { PatchUserRequestDescription } from './patchUserRequestDescription'
import type { PatchUserRequestFamilyName } from './patchUserRequestFamilyName'
import type { PatchUserRequestGivenName } from './patchUserRequestGivenName'
import type { PatchUserRequestImageUrl } from './patchUserRequestImageUrl'
import type { PatchUserRequestLanguageCode } from './patchUserRequestLanguageCode'
import type { PatchUserRequestLocale } from './patchUserRequestLocale'
import type { PatchUserRequestTimezone } from './patchUserRequestTimezone'

export interface PatchUserRequest {
  appSettings?: PatchUserRequestAppSettings
  country?: PatchUserRequestCountry
  defaultConversationSettings?: PatchUserRequestDefaultConversationSettings
  description?: PatchUserRequestDescription
  familyName?: PatchUserRequestFamilyName
  givenName?: PatchUserRequestGivenName
  imageUrl?: PatchUserRequestImageUrl
  languageCode?: PatchUserRequestLanguageCode
  locale?: PatchUserRequestLocale
  timezone?: PatchUserRequestTimezone
}


--- Start of frontend/src/api/models/conversationStarter.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface ConversationStarter {
  description: string
  messagePrefill: string
  title: string
}


--- Start of frontend/src/api/models/conversationStarterListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationStarter } from './conversationStarter'

export interface ConversationStarterListResponse {
  items: ConversationStarter[]
}


--- Start of frontend/src/api/models/lLMProviderInfo.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMProviderInfoDescription } from './lLMProviderInfoDescription'
import type { LLMProviderInfoImageUrl } from './lLMProviderInfoImageUrl'

export interface LLMProviderInfo {
  description?: LLMProviderInfoDescription
  imageUrl?: LLMProviderInfoImageUrl
  name: string
}


--- Start of frontend/src/api/models/userRegistrationRequest.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { UserRegistrationRequestCountry } from './userRegistrationRequestCountry'
import type { UserRegistrationRequestDescription } from './userRegistrationRequestDescription'
import type { UserRegistrationRequestFamilyName } from './userRegistrationRequestFamilyName'
import type { UserRegistrationRequestGivenName } from './userRegistrationRequestGivenName'
import type { UserRegistrationRequestImageUrl } from './userRegistrationRequestImageUrl'
import type { UserRegistrationRequestLanguageCode } from './userRegistrationRequestLanguageCode'
import type { UserRegistrationRequestLocale } from './userRegistrationRequestLocale'
import type { UserRegistrationRequestTimezone } from './userRegistrationRequestTimezone'

export interface UserRegistrationRequest {
  country?: UserRegistrationRequestCountry
  description?: UserRegistrationRequestDescription
  email: string
  familyName?: UserRegistrationRequestFamilyName
  givenName?: UserRegistrationRequestGivenName
  imageUrl?: UserRegistrationRequestImageUrl
  languageCode?: UserRegistrationRequestLanguageCode
  locale?: UserRegistrationRequestLocale
  /** @minLength 8 */
  password: string
  timezone?: UserRegistrationRequestTimezone
  /**
   * @minLength 3
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_-]{3,50}$
   */
  username: string
}


--- Start of frontend/src/api/models/patchUserRequestLocale.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestLocale = string | null


--- Start of frontend/src/api/models/conversationSearchResultUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ConversationSearchResultUpdatedAt = string | null


--- Start of frontend/src/api/models/getAllAssetsParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GetAllAssetsParams = {
  conversationUuid?: string | null
}


--- Start of frontend/src/api/models/ingestionStepLogExecutionDetails.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionStepLogExecutionDetails = { [key: string]: string }


--- Start of frontend/src/api/models/generationMetadataCostUsd.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationMetadataCostUsd = number | null


--- Start of frontend/src/api/models/ingestionMetadataParsingCompletedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionMetadataParsingCompletedAt = string | null


--- Start of frontend/src/api/models/toolUseInfoOutputs.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolUseInfoOutputsAnyOf } from './toolUseInfoOutputsAnyOf'

export type ToolUseInfoOutputs = ToolUseInfoOutputsAnyOf | null


--- Start of frontend/src/api/models/userRegistrationRequestLocale.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestLocale = string | null


--- Start of frontend/src/api/models/regenerateAgentMessageParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type RegenerateAgentMessageParams = {
  conversationUuid: string
  messageUuid?: string | null
}


--- Start of frontend/src/api/models/lLMInfo.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMProviderInfo } from './lLMProviderInfo'

export interface LLMInfo {
  llmModelDisplayName: string
  llmModelId: string
  maxOutputTokens: number
  provider: LLMProviderInfo
  supportsAudio: boolean
  supportsImages: boolean
}


--- Start of frontend/src/api/models/agentUpdateAssetUuids.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentUpdateAssetUuids = string[] | null


--- Start of frontend/src/api/models/getAvailableLlmInfosParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GetAvailableLlmInfosParams = {
  conversationUuid?: string | null
  agentUuid?: string | null
  supportsAudio?: boolean | null
  supportsImages?: boolean | null
}


--- Start of frontend/src/api/models/patchUserRequestDefaultConversationSettings.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { DefaultConversationSettings } from './defaultConversationSettings'

export type PatchUserRequestDefaultConversationSettings =
  DefaultConversationSettings | null


--- Start of frontend/src/api/models/userProfileCountry.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileCountry = string | null


--- Start of frontend/src/api/models/messageSearchResultUserUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageSearchResultUserUuid = string | null


--- Start of frontend/src/api/models/userRegistrationRequestDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestDescription = string | null


--- Start of frontend/src/api/models/toolOutputFileLocalPath.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolOutputFileLocalPath = string | null


--- Start of frontend/src/api/models/feedbackResponseMessageUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackResponseMessageUuid = string | null


--- Start of frontend/src/api/models/toolUseConfig.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolOutputFormatting } from './toolOutputFormatting'

export interface ToolUseConfig {
  maxRetries?: number
  maxSubsequentToolUses?: number
  outputFormatting?: ToolOutputFormatting
  outputMaxTokens?: number
}


--- Start of frontend/src/api/models/conversationHistoryResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageReadResponse } from './messageReadResponse'

export interface ConversationHistoryResponse {
  items: MessageReadResponse[]
}


--- Start of frontend/src/api/models/assetReadResponseAgentUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetReadResponseAgentUuid = string | null


--- Start of frontend/src/api/models/agentUpdate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentUpdateAssetUuids } from './agentUpdateAssetUuids'
import type { AgentUpdateDescription } from './agentUpdateDescription'
import type { AgentUpdateIsPublic } from './agentUpdateIsPublic'
import type { AgentUpdateLlmModelId } from './agentUpdateLlmModelId'
import type { AgentUpdateName } from './agentUpdateName'

export interface AgentUpdate {
  assetUuids?: AgentUpdateAssetUuids
  description?: AgentUpdateDescription
  isPublic?: AgentUpdateIsPublic
  llmModelId?: AgentUpdateLlmModelId
  name?: AgentUpdateName
}


--- Start of frontend/src/api/models/messageCreate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageCreateAgentConfigUuid } from './messageCreateAgentConfigUuid'
import type { MessageCreateAssetUuids } from './messageCreateAssetUuids'

export interface MessageCreate {
  /** If not passed, the currently active config will be used */
  agentConfigUuid?: MessageCreateAgentConfigUuid
  assetUuids?: MessageCreateAssetUuids
  /** @minLength 1 */
  content: string
}


--- Start of frontend/src/api/models/patchUserMessageStreamingParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserMessageStreamingParams = {
  conversationUuid: string
}


--- Start of frontend/src/api/models/patchUserRequestLanguageCode.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestLanguageCode = string | null


--- Start of frontend/src/api/models/agentConfigsListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentConfigReadResponse } from './agentConfigReadResponse'

export interface AgentConfigsListResponse {
  items: AgentConfigReadResponse[]
}


--- Start of frontend/src/api/models/auditLogReadResponseContext.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AuditLogReadResponseContextAnyOf } from './auditLogReadResponseContextAnyOf'

export type AuditLogReadResponseContext =
  AuditLogReadResponseContextAnyOf | null


--- Start of frontend/src/api/models/ingestionMetadata.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionMetadataFailedAt } from './ingestionMetadataFailedAt'
import type { IngestionMetadataIndexingCompletedAt } from './ingestionMetadataIndexingCompletedAt'
import type { IngestionMetadataIngestedAt } from './ingestionMetadataIngestedAt'
import type { IngestionMetadataParsingCompletedAt } from './ingestionMetadataParsingCompletedAt'
import type { IngestionMetadataProcessingCompletedAt } from './ingestionMetadataProcessingCompletedAt'

/**
 * Metadata for an Ingestion Request.

Attributes:
    code_version (str): Version of the code that performed the ingestion.
    filename (str): Name of the file being ingested.
    total_cost_usd (float): Total cost of ingestion in USD. Defaults to 0.0.
    requested_at (AwareDatetime): Timestamp when ingestion was requested.
    ingestion_started_at (AwareDatetime): Timestamp when ingestion process began.
    parsing_completed_at (AwareDatetime | None): Timestamp when parsing completed, if applicable.
    processing_completed_at (AwareDatetime | None): Timestamp when processing completed, if applicable.
    indexing_completed_at (AwareDatetime | None): Timestamp when indexing completed, if applicable.
    failed_at (AwareDatetime | None): Timestamp when ingestion failed, if applicable.
    ingested_at (AwareDatetime | None): Timestamp when ingestion fully completed, if applicable.
    parsed (bool): Whether parsing stage is complete.
    processed (bool): Whether processing stage is complete.
    indexed (bool): Whether indexing stage is complete.
    ingested (bool): Whether entire ingestion is complete (same as indexed).
    parsing_duration (timedelta | None): Duration of parsing stage.
    processing_duration (timedelta | None): Duration of processing stage.
    indexing_duration (timedelta | None): Duration of indexing stage.
    ingestion_duration (timedelta | None): Total duration of successful ingestion.
    failed_duration (timedelta | None): Duration until failure, if failed.
    total_duration (timedelta | None): Total duration (success or failure).
 */
export interface IngestionMetadata {
  codeVersion?: string
  failedAt?: IngestionMetadataFailedAt
  filename: string
  indexingCompletedAt?: IngestionMetadataIndexingCompletedAt
  ingestedAt?: IngestionMetadataIngestedAt
  ingestionStartedAt?: string
  parsingCompletedAt?: IngestionMetadataParsingCompletedAt
  processingCompletedAt?: IngestionMetadataProcessingCompletedAt
  requestedAt: string
  totalCostUsd?: number
}


--- Start of frontend/src/api/models/userProfileLanguageCode.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileLanguageCode = string | null


--- Start of frontend/src/api/models/ingestionStepLog.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionStepLogCompletedAt } from './ingestionStepLogCompletedAt'
import type { IngestionStepLogExecutionDetails } from './ingestionStepLogExecutionDetails'

export interface IngestionStepLog {
  completedAt?: IngestionStepLogCompletedAt
  costUsd?: number
  executionDetails?: IngestionStepLogExecutionDetails
  startedAt?: string
  stepName: string
}


--- Start of frontend/src/api/models/toolUseOptions.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolOutputFormatting } from './toolOutputFormatting'

export interface ToolUseOptions {
  maxRetries?: number
  outputFormatting?: ToolOutputFormatting
  outputMaxTokens?: number
}


--- Start of frontend/src/api/models/assetSearchResult.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetSearchResultAgentUuid } from './assetSearchResultAgentUuid'
import type { AssetSearchResultContent } from './assetSearchResultContent'
import type { AssetSearchResultContentHash } from './assetSearchResultContentHash'
import type { AssetSearchResultConversationName } from './assetSearchResultConversationName'
import type { AssetSearchResultDescription } from './assetSearchResultDescription'
import type { AssetSearchResultIngestionStatus } from './assetSearchResultIngestionStatus'
import type { AssetSearchResultMessageUuid } from './assetSearchResultMessageUuid'
import type { AssetSearchResultSummary } from './assetSearchResultSummary'
import type { AssetSearchResultText } from './assetSearchResultText'
import type { AssetSearchResultUpdatedAt } from './assetSearchResultUpdatedAt'

export interface AssetSearchResult {
  agentUuid?: AssetSearchResultAgentUuid
  content?: AssetSearchResultContent
  contentHash?: AssetSearchResultContentHash
  conversationName?: AssetSearchResultConversationName
  conversationUuid: string
  createdAt?: string
  description?: AssetSearchResultDescription
  ingestionStatus?: AssetSearchResultIngestionStatus
  messageUuid?: AssetSearchResultMessageUuid
  name: string
  originalFilename: string
  rankingScore: number
  sizeBytes: number
  summary?: AssetSearchResultSummary
  text?: AssetSearchResultText
  type: string
  updatedAt?: AssetSearchResultUpdatedAt
  userUuid: string
  uuid?: string
  [key: string]: unknown
}


--- Start of frontend/src/api/models/checkUsernameAvailableParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type CheckUsernameAvailableParams = {
  username: string
}


--- Start of frontend/src/api/models/lLMProviderInfoImageUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type LLMProviderInfoImageUrl = string | null


--- Start of frontend/src/api/models/agentConfigCreateToolUseSectionTemplates.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolUsePromptTemplateSections } from './toolUsePromptTemplateSections'

export type AgentConfigCreateToolUseSectionTemplates =
  ToolUsePromptTemplateSections | null


--- Start of frontend/src/api/models/assetReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetReadResponseAgentUuid } from './assetReadResponseAgentUuid'
import type { AssetReadResponseConversationUuid } from './assetReadResponseConversationUuid'
import type { AssetReadResponseDescription } from './assetReadResponseDescription'
import type { AssetReadResponseIngestionErrorLog } from './assetReadResponseIngestionErrorLog'
import type { AssetReadResponseIngestionMetadata } from './assetReadResponseIngestionMetadata'
import type { AssetReadResponseIngestionStatus } from './assetReadResponseIngestionStatus'
import type { AssetReadResponseIngestionStepLogs } from './assetReadResponseIngestionStepLogs'
import type { AssetReadResponseMessageUuid } from './assetReadResponseMessageUuid'
import type { AssetReadResponseSourceUrl } from './assetReadResponseSourceUrl'
import type { AssetType } from './assetType'

export interface AssetReadResponse {
  agentUuid?: AssetReadResponseAgentUuid
  conversationUuid?: AssetReadResponseConversationUuid
  createdAt: string
  description?: AssetReadResponseDescription
  ingestionErrorLog?: AssetReadResponseIngestionErrorLog
  ingestionMetadata?: AssetReadResponseIngestionMetadata
  ingestionStatus?: AssetReadResponseIngestionStatus
  ingestionStepLogs?: AssetReadResponseIngestionStepLogs
  messageUuid?: AssetReadResponseMessageUuid
  name: string
  originalFilename: string
  sourceUrl?: AssetReadResponseSourceUrl
  type: AssetType
  userUuid: string
  uuid: string
}


--- Start of frontend/src/api/models/bodyRunToolApiToolToolRegistryIdPost.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { BodyRunToolApiToolToolRegistryIdPostToolInputs } from './bodyRunToolApiToolToolRegistryIdPostToolInputs'
import type { BodyRunToolApiToolToolRegistryIdPostToolOptions } from './bodyRunToolApiToolToolRegistryIdPostToolOptions'

export interface BodyRunToolApiToolToolRegistryIdPost {
  toolInputs: BodyRunToolApiToolToolRegistryIdPostToolInputs
  toolOptions?: BodyRunToolApiToolToolRegistryIdPostToolOptions
}


--- Start of frontend/src/api/models/assetCreateErrorErrorLog.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetCreateErrorErrorLog = string | null


--- Start of frontend/src/api/models/generationMetadataFinishReason.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { FinishReason } from './finishReason'

export type GenerationMetadataFinishReason = FinishReason | null


--- Start of frontend/src/api/models/promptTemplateOutputCompletionTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PromptTemplateOutputCompletionTemplate = string | null


--- Start of frontend/src/api/models/agentUpdateLlmModelId.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentUpdateLlmModelId = string | null


--- Start of frontend/src/api/models/auditLogReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AuditActionType } from './auditActionType'
import type { AuditLogReadResponseAssetUuid } from './auditLogReadResponseAssetUuid'
import type { AuditLogReadResponseChanges } from './auditLogReadResponseChanges'
import type { AuditLogReadResponseContext } from './auditLogReadResponseContext'
import type { AuditLogReadResponseConversationUuid } from './auditLogReadResponseConversationUuid'
import type { AuditLogReadResponseEntity } from './auditLogReadResponseEntity'
import type { AuditLogReadResponseEntityUuid } from './auditLogReadResponseEntityUuid'
import type { AuditLogReadResponseMessageUuid } from './auditLogReadResponseMessageUuid'

export interface AuditLogReadResponse {
  actionType: AuditActionType
  assetUuid?: AuditLogReadResponseAssetUuid
  changes?: AuditLogReadResponseChanges
  context?: AuditLogReadResponseContext
  conversationUuid?: AuditLogReadResponseConversationUuid
  createdAt: string
  entity?: AuditLogReadResponseEntity
  entityUuid?: AuditLogReadResponseEntityUuid
  messageUuid?: AuditLogReadResponseMessageUuid
  userUuid: string
  uuid: string
}


--- Start of frontend/src/api/models/messageReadResponseAgentConfigVersion.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageReadResponseAgentConfigVersion = number | null


--- Start of frontend/src/api/models/userAppSettingsTheme.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserAppSettingsTheme =
  (typeof UserAppSettingsTheme)[keyof typeof UserAppSettingsTheme]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserAppSettingsTheme = {
  light: 'light',
  dark: 'dark',
  system: 'system',
} as const


--- Start of frontend/src/api/models/conversationPatchRequestName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ConversationPatchRequestName = string | null


--- Start of frontend/src/api/models/searchRequestMessageRoleFilter.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageRole } from './messageRole'

export type SearchRequestMessageRoleFilter = MessageRole | null


--- Start of frontend/src/api/models/lLMProviderInfoDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type LLMProviderInfoDescription = string | null


--- Start of frontend/src/api/models/agentConfigReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentConfigReadResponseNotes } from './agentConfigReadResponseNotes'
import type { AgentConfigReadResponseUpdatedAt } from './agentConfigReadResponseUpdatedAt'
import type { AgentConfigStatus } from './agentConfigStatus'
import type { AgentStockResponses } from './agentStockResponses'
import type { PromptTemplateOutput } from './promptTemplateOutput'
import type { ReasoningDetection } from './reasoningDetection'
import type { Tool } from './tool'
import type { ToolReadResponse } from './toolReadResponse'
import type { ToolUseConfig } from './toolUseConfig'

export interface AgentConfigReadResponse {
  agentClass: string
  agentUuid: string
  createdAt?: string
  isEditable?: boolean
  name: string
  notes?: AgentConfigReadResponseNotes
  promptTemplate: PromptTemplateOutput
  reasoningDetection?: ReasoningDetection
  status: AgentConfigStatus
  stockResponses?: AgentStockResponses
  toolDefinitions?: ToolReadResponse[]
  toolUseConfig?: ToolUseConfig
  tools: Tool[]
  updatedAt?: AgentConfigReadResponseUpdatedAt
  uuid?: string
  version?: number
}


--- Start of frontend/src/api/models/ingestionMetadataProcessingCompletedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionMetadataProcessingCompletedAt = string | null


--- Start of frontend/src/api/models/assetReadResponseIngestionStepLogs.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionStepLog } from './ingestionStepLog'

export type AssetReadResponseIngestionStepLogs = IngestionStepLog[] | null


--- Start of frontend/src/api/models/promptTemplateOutput.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { GenerationSettings } from './generationSettings'
import type { PromptTemplateOutputCompletionTemplate } from './promptTemplateOutputCompletionTemplate'
import type { PromptTemplateOutputMessagesTemplate } from './promptTemplateOutputMessagesTemplate'
import type { PromptTemplateOutputSectionsTemplate } from './promptTemplateOutputSectionsTemplate'

export interface PromptTemplateOutput {
  completionTemplate?: PromptTemplateOutputCompletionTemplate
  generationSettings?: GenerationSettings
  messagesTemplate?: PromptTemplateOutputMessagesTemplate
  name: string
  sectionsTemplate?: PromptTemplateOutputSectionsTemplate
}


--- Start of frontend/src/api/models/userProfileDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileDescription = string | null


--- Start of frontend/src/api/models/agentConfigCreateFromExistingPromptTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { PromptTemplateInput } from './promptTemplateInput'

export type AgentConfigCreateFromExistingPromptTemplate =
  PromptTemplateInput | null


--- Start of frontend/src/api/models/hTTPValidationError.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ValidationError } from './validationError'

export interface HTTPValidationError {
  detail?: ValidationError[]
}


--- Start of frontend/src/api/models/generationMetadataTimeToFirstTokenMs.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationMetadataTimeToFirstTokenMs = number | null


--- Start of frontend/src/api/models/assetsListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetReadResponse } from './assetReadResponse'

export interface AssetsListResponse {
  items: AssetReadResponse[]
}


--- Start of frontend/src/api/models/getSupportedExtensionsParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GetSupportedExtensionsParams = {
  agentUuid?: string | null
  conversationUuid?: string | null
  llmModelId?: string | null
}


--- Start of frontend/src/api/models/agentConfigCreateFromExistingNotes.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigCreateFromExistingNotes = string | null


--- Start of frontend/src/api/models/agentConfigCreateFromExistingName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigCreateFromExistingName = string | null


--- Start of frontend/src/api/models/generationMetadataSettings.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { GenerationSettings } from './generationSettings'

export type GenerationMetadataSettings = GenerationSettings | null


--- Start of frontend/src/api/models/agentConfigCreateNotes.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigCreateNotes = string | null


--- Start of frontend/src/api/models/bodyRunToolApiToolToolRegistryIdPostToolInputs.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type BodyRunToolApiToolToolRegistryIdPostToolInputs = {
  [key: string]: unknown
}


--- Start of frontend/src/api/models/lLMInfoResponseNotSelectableReason.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMNotSelectableReason } from './lLMNotSelectableReason'

export type LLMInfoResponseNotSelectableReason = LLMNotSelectableReason | null


--- Start of frontend/src/api/models/assetSearchResultText.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultText = string | null


--- Start of frontend/src/api/models/getConversationStartersParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GetConversationStartersParams = {
  dynamic?: boolean
  numStarters?: number
}


--- Start of frontend/src/api/models/toolUseInfoInputs.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolUseInfoInputsAnyOf } from './toolUseInfoInputsAnyOf'

export type ToolUseInfoInputs = ToolUseInfoInputsAnyOf | null


--- Start of frontend/src/api/models/agentConfigReadResponseNotes.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigReadResponseNotes = string | null


--- Start of frontend/src/api/models/toolUseInfoCompletedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolUseInfoCompletedAt = string | null


--- Start of frontend/src/api/models/ingestionMetadataIngestedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionMetadataIngestedAt = string | null


--- Start of frontend/src/api/models/assetReadResponseDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetReadResponseDescription = string | null


--- Start of frontend/src/api/models/bodyLoginApiAuthLoginPostClientId.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type BodyLoginApiAuthLoginPostClientId = string | null


--- Start of frontend/src/api/models/auditLogsListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AuditLogReadResponse } from './auditLogReadResponse'

export interface AuditLogsListResponse {
  items: AuditLogReadResponse[]
}


--- Start of frontend/src/api/models/textMessageSectionTemplateUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type TextMessageSectionTemplateUuid = string | null


--- Start of frontend/src/api/models/rebuildSearchIndicesParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type RebuildSearchIndicesParams = {
  indexName?: string | null
}


--- Start of frontend/src/api/models/agentReadResponseOwnerUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentReadResponseOwnerUuid = string | null


--- Start of frontend/src/api/models/agentType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentType = (typeof AgentType)[keyof typeof AgentType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AgentType = {
  ai: 'ai',
  human: 'human',
} as const


--- Start of frontend/src/api/models/messageReadResponseUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageReadResponseUpdatedAt = string | null


--- Start of frontend/src/api/models/createAssetsParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type CreateAssetsParams = {
  conversationUuid?: string | null
}


--- Start of frontend/src/api/models/toolUseInfoGenerationContext.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolUseInfoGenerationContext = { [key: string]: string }


--- Start of frontend/src/api/models/agentReadResponseDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentReadResponseDescription = string | null


--- Start of frontend/src/api/models/supportedFileExtensionsResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface SupportedFileExtensionsResponse {
  all: string[]
  audio: string[]
  document: string[]
  image: string[]
  text: string[]
}


--- Start of frontend/src/api/models/messageUpdateContent.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

/**
 * New message content
 */
export type MessageUpdateContent = string | null


--- Start of frontend/src/api/models/assetSearchResultContentHash.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultContentHash = string | null


--- Start of frontend/src/api/models/assetSearchResultMessageUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultMessageUuid = string | null


--- Start of frontend/src/api/models/ingestionErrorLog.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionErrorType } from './ingestionErrorType'

export interface IngestionErrorLog {
  createdAt?: string
  message: string
  requestUuid: string
  stepName: string
  type: IngestionErrorType
}


--- Start of frontend/src/api/models/feedbackCreateTargetUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

/**
 * Optional for application feedback, required for all others
 */
export type FeedbackCreateTargetUuid = string | null


--- Start of frontend/src/api/models/messageSearchResultAuthorImageUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageSearchResultAuthorImageUrl = string | null


--- Start of frontend/src/api/models/patchUserRequestAppSettings.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { UserAppSettings } from './userAppSettings'

export type PatchUserRequestAppSettings = UserAppSettings | null


--- Start of frontend/src/api/models/ingestionStepLogCompletedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionStepLogCompletedAt = string | null


--- Start of frontend/src/api/models/searchResultsResponseAsset.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetIndexResults } from './assetIndexResults'

export type SearchResultsResponseAsset = AssetIndexResults | null


--- Start of frontend/src/api/models/messageIndexResultsFilters.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageIndexResultsFilters = { [key: string]: unknown }


--- Start of frontend/src/api/models/agentUpdateDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentUpdateDescription = string | null


--- Start of frontend/src/api/models/feedbackResponseAssetUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackResponseAssetUuid = string | null


--- Start of frontend/src/api/models/patchUserRequestGivenName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestGivenName = string | null


--- Start of frontend/src/api/models/feedbackRating.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackRating =
  (typeof FeedbackRating)[keyof typeof FeedbackRating]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackRating = {
  great: 'great',
  good: 'good',
  bad: 'bad',
  terrible: 'terrible',
} as const


--- Start of frontend/src/api/models/feedbackResponseUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackResponseUrl = string | null


--- Start of frontend/src/api/models/assetSearchResultIngestionStatus.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionStatus } from './ingestionStatus'

export type AssetSearchResultIngestionStatus = IngestionStatus | null


--- Start of frontend/src/api/models/getSearchHistoryParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GetSearchHistoryParams = {
  prefix?: string | null
  page?: number
  pageSize?: number
}


--- Start of frontend/src/api/models/messageUpdateAssetUuids.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

/**
 * UUIDs for assets attached to message. Set to [] to remove all assets.
 */
export type MessageUpdateAssetUuids = string[] | null


--- Start of frontend/src/api/models/lLMNotSelectableReason.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type LLMNotSelectableReason =
  (typeof LLMNotSelectableReason)[keyof typeof LLMNotSelectableReason]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LLMNotSelectableReason = {
  audioNotSupported: 'audio_not_supported',
  imagesNotSupported: 'images_not_supported',
  bothAudioAndImagesNotSupported: 'both_audio_and_images_not_supported',
} as const


--- Start of frontend/src/api/models/messageSearchResult.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageRole } from './messageRole'
import type { MessageSearchResultAgentUuid } from './messageSearchResultAgentUuid'
import type { MessageSearchResultAuthorImageUrl } from './messageSearchResultAuthorImageUrl'
import type { MessageSearchResultLlmModelId } from './messageSearchResultLlmModelId'
import type { MessageSearchResultText } from './messageSearchResultText'
import type { MessageSearchResultUpdatedAt } from './messageSearchResultUpdatedAt'
import type { MessageSearchResultUserUuid } from './messageSearchResultUserUuid'
import type { MessageStatus } from './messageStatus'
import type { MessageType } from './messageType'

export interface MessageSearchResult {
  agentUuid?: MessageSearchResultAgentUuid
  authorImageUrl?: MessageSearchResultAuthorImageUrl
  authorName: string
  content: string
  conversationName: string
  conversationUuid: string
  createdAt?: string
  llmModelId?: MessageSearchResultLlmModelId
  rankingScore: number
  role: MessageRole
  status: MessageStatus
  text?: MessageSearchResultText
  type: MessageType
  updatedAt?: MessageSearchResultUpdatedAt
  userUuid?: MessageSearchResultUserUuid
  uuid?: string
  [key: string]: unknown
}


--- Start of frontend/src/api/models/patchUserRequestDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestDescription = string | null


--- Start of frontend/src/api/models/validationError.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ValidationErrorLocItem } from './validationErrorLocItem'

export interface ValidationError {
  loc: ValidationErrorLocItem[]
  msg: string
  type: string
}


--- Start of frontend/src/api/models/textMessageTemplateUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type TextMessageTemplateUuid = string | null


--- Start of frontend/src/api/models/assetReadResponseIngestionErrorLog.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionErrorLog } from './ingestionErrorLog'

export type AssetReadResponseIngestionErrorLog = IngestionErrorLog | null


--- Start of frontend/src/api/models/reasoningDetection.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { Tags } from './tags'

export interface ReasoningDetection {
  enabled?: boolean
  tags?: Tags
}


--- Start of frontend/src/api/models/runTool200.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type RunTool200 = { [key: string]: unknown }


--- Start of frontend/src/api/models/toolOutputFormatting.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolOutputFormatting =
  (typeof ToolOutputFormatting)[keyof typeof ToolOutputFormatting]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolOutputFormatting = {
  custom: 'custom',
  json: 'json',
  xml: 'xml',
  yaml: 'yaml',
} as const


--- Start of frontend/src/api/models/userProfileLocale.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileLocale = string | null


--- Start of frontend/src/api/models/assetIndexResultsFilters.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetIndexResultsFilters = { [key: string]: unknown }


--- Start of frontend/src/api/models/generationSettingsReasoningEffort.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ReasoningEffort } from './reasoningEffort'

export type GenerationSettingsReasoningEffort = ReasoningEffort | null


--- Start of frontend/src/api/models/conversationIndexResultsFilters.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ConversationIndexResultsFilters = { [key: string]: unknown }


--- Start of frontend/src/api/models/feedbackTarget.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackTarget =
  (typeof FeedbackTarget)[keyof typeof FeedbackTarget]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackTarget = {
  agent: 'agent',
  application: 'application',
  conversation: 'conversation',
  message: 'message',
  output: 'output',
} as const


--- Start of frontend/src/api/models/userRegistrationRequestLanguageCode.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestLanguageCode = string | null


--- Start of frontend/src/api/models/deleteQueryFromSearchHistoryParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type DeleteQueryFromSearchHistoryParams = {
  query: string
}


--- Start of frontend/src/api/models/userProfileFamilyName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileFamilyName = string | null


--- Start of frontend/src/api/models/patchUserRequestFamilyName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestFamilyName = string | null


--- Start of frontend/src/api/models/searchRequestMessageTypeFilter.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageType } from './messageType'

export type SearchRequestMessageTypeFilter = MessageType | null


--- Start of frontend/src/api/models/agentReadResponseOwnerUsername.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentReadResponseOwnerUsername = string | null


--- Start of frontend/src/api/models/agentConfigReadResponseUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigReadResponseUpdatedAt = string | null


--- Start of frontend/src/api/models/auditLogReadResponseEntityUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseEntityUuid = string | null


--- Start of frontend/src/api/models/regenerateAgentMessageStreamingParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type RegenerateAgentMessageStreamingParams = {
  conversationUuid: string
  messageUuid?: string | null
}


--- Start of frontend/src/api/models/generationMetadata.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { GenerationMetadataCostUsd } from './generationMetadataCostUsd'
import type { GenerationMetadataDurationMs } from './generationMetadataDurationMs'
import type { GenerationMetadataFinishReason } from './generationMetadataFinishReason'
import type { GenerationMetadataOutputTokens } from './generationMetadataOutputTokens'
import type { GenerationMetadataSettings } from './generationMetadataSettings'
import type { GenerationMetadataTimeToFirstTokenMs } from './generationMetadataTimeToFirstTokenMs'
import type { GenerationMetadataTokensPerSecond } from './generationMetadataTokensPerSecond'
import type { GenerationMetadataToolCalls } from './generationMetadataToolCalls'

/**
 * Metadata about a generation.
This allows downstream components to work with things like the finish reason, cost, duration, etc.
Output values are optional so the object can be instantiated with the input values only,
and updated with the output values during or after generation.

Note:
    Time to first token in milliseconds is only available for streaming generations
 */
export interface GenerationMetadata {
  costUsd?: GenerationMetadataCostUsd
  durationMs?: GenerationMetadataDurationMs
  finishReason?: GenerationMetadataFinishReason
  inputTokenCostUsd: number
  inputTokens: number
  llmModelId: string
  outputTokenCostUsd: number
  outputTokens?: GenerationMetadataOutputTokens
  settings?: GenerationMetadataSettings
  timeToFirstTokenMs?: GenerationMetadataTimeToFirstTokenMs
  readonly tokensPerSecond: GenerationMetadataTokensPerSecond
  toolCalls?: GenerationMetadataToolCalls
}


--- Start of frontend/src/api/models/auditLogReadResponseChangesAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseChangesAnyOf = { [key: string]: unknown }


--- Start of frontend/src/api/models/agentCreateDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentCreateDescription = string | null


--- Start of frontend/src/api/models/toolUseInfoInputsAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolUseInfoInputsAnyOf = { [key: string]: unknown }


--- Start of frontend/src/api/models/userProfileGivenName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileGivenName = string | null


--- Start of frontend/src/api/models/auditActionType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditActionType =
  (typeof AuditActionType)[keyof typeof AuditActionType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditActionType = {
  create: 'create',
  update: 'update',
  delete: 'delete',
  login: 'login',
  logout: 'logout',
  failedLogin: 'failed_login',
  other: 'other',
} as const


--- Start of frontend/src/api/models/toolReadResponseOutputsSchema.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolReadResponseOutputsSchema = { [key: string]: unknown }


--- Start of frontend/src/api/models/conversationReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationReadResponseUpdatedAt } from './conversationReadResponseUpdatedAt'

export interface ConversationReadResponse {
  createdAt: string
  name: string
  updatedAt?: ConversationReadResponseUpdatedAt
  uuid: string
  [key: string]: unknown
}


--- Start of frontend/src/api/models/auditLogReadResponseEntity.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseEntity = string | null


--- Start of frontend/src/api/models/messageSearchResultAgentUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageSearchResultAgentUuid = string | null


--- Start of frontend/src/api/models/messageCreateAssetUuids.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageCreateAssetUuids = string[] | null


--- Start of frontend/src/api/models/assetReadResponseConversationUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetReadResponseConversationUuid = string | null


--- Start of frontend/src/api/models/agentsListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentReadResponse } from './agentReadResponse'

export interface AgentsListResponse {
  items: AgentReadResponse[]
}


--- Start of frontend/src/api/models/searchRequestTruncateTextFieldsToLength.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type SearchRequestTruncateTextFieldsToLength = number | null


--- Start of frontend/src/api/models/finishReason.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FinishReason = (typeof FinishReason)[keyof typeof FinishReason]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FinishReason = {
  success: 'success',
  maxLength: 'max_length',
  stopSequence: 'stop_sequence',
  contentFilter: 'content_filter',
  toolUse: 'tool_use',
  unknown: 'unknown',
} as const


--- Start of frontend/src/api/models/messageIndexResults.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageIndexResultsFilters } from './messageIndexResultsFilters'
import type { MessageSearchResult } from './messageSearchResult'

export interface MessageIndexResults {
  filters: MessageIndexResultsFilters
  hits: MessageSearchResult[]
  indexName?: string
  limit: number
  offset: number
  processingTimeMs: number
  query: string
  totalHits: number
}


--- Start of frontend/src/api/models/promptTemplateInputCompletionTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PromptTemplateInputCompletionTemplate = string | null


--- Start of frontend/src/api/models/agentUpdateIsPublic.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentUpdateIsPublic = boolean | null


--- Start of frontend/src/api/models/messageReadResponseToolUseResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolUseResponse } from './toolUseResponse'

export type MessageReadResponseToolUseResponse = ToolUseResponse | null


--- Start of frontend/src/api/models/userRegistrationRequestGivenName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestGivenName = string | null


--- Start of frontend/src/api/models/toolCall.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface ToolCall {
  contentBlockIndex?: number
  id: string
  inputsJson: string
  name: string
}


--- Start of frontend/src/api/models/bodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type BodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf = {
  [key: string]: unknown
}


--- Start of frontend/src/api/models/sendMessageAndReceiveGeneratedResponseParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type SendMessageAndReceiveGeneratedResponseParams = {
  conversationUuid?: string | null
}


--- Start of frontend/src/api/models/messageSearchResultUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageSearchResultUpdatedAt = string | null


--- Start of frontend/src/api/models/searchRequest.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { SearchRequestConversationUuidFilter } from './searchRequestConversationUuidFilter'
import type { SearchRequestMessageRoleFilter } from './searchRequestMessageRoleFilter'
import type { SearchRequestMessageTypeFilter } from './searchRequestMessageTypeFilter'
import type { SearchRequestTruncateTextFieldsToLength } from './searchRequestTruncateTextFieldsToLength'

export interface SearchRequest {
  conversationUuidFilter?: SearchRequestConversationUuidFilter
  limit?: number
  messageRoleFilter?: SearchRequestMessageRoleFilter
  messageTypeFilter?: SearchRequestMessageTypeFilter
  offset?: number
  query: string
  queryAssetIndex?: boolean
  queryConversationIndex?: boolean
  queryMessageIndex?: boolean
  truncateTextFieldsToLength?: SearchRequestTruncateTextFieldsToLength
}


--- Start of frontend/src/api/models/userProfileImageUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileImageUrl = string | null


--- Start of frontend/src/api/models/bodyCreateAssetsApiAssetPost.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface BodyCreateAssetsApiAssetPost {
  files: Blob[]
}


--- Start of frontend/src/api/models/assetCreateError.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetCreateErrorErrorLog } from './assetCreateErrorErrorLog'

export interface AssetCreateError {
  error: string
  errorLog?: AssetCreateErrorErrorLog
  originalFilename: string
}


--- Start of frontend/src/api/models/patchUserMessageParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserMessageParams = {
  conversationUuid: string
}


--- Start of frontend/src/api/models/patchUserRequestTimezone.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestTimezone = string | null


--- Start of frontend/src/api/models/assetReadResponseIngestionStatus.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionStatus } from './ingestionStatus'

export type AssetReadResponseIngestionStatus = IngestionStatus | null


--- Start of frontend/src/api/models/auditLogReadResponseChanges.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AuditLogReadResponseChangesAnyOf } from './auditLogReadResponseChangesAnyOf'

export type AuditLogReadResponseChanges =
  AuditLogReadResponseChangesAnyOf | null


--- Start of frontend/src/api/models/userRegistrationRequestImageUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestImageUrl = string | null


--- Start of frontend/src/api/models/agentStockResponsesInitialMessage.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentStockResponsesInitialMessage = string | null


--- Start of frontend/src/api/models/toolOptions.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolOptionsAnyOf } from './toolOptionsAnyOf'

export type ToolOptions = ToolOptionsAnyOf | null


--- Start of frontend/src/api/models/messageSearchResultText.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageSearchResultText = string | null


--- Start of frontend/src/api/models/ingestionStatus.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionStatus =
  (typeof IngestionStatus)[keyof typeof IngestionStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IngestionStatus = {
  unsupported: 'unsupported',
  pending: 'pending',
  parsingError: 'parsing_error',
  processingError: 'processing_error',
  indexingError: 'indexing_error',
  ingested: 'ingested',
} as const


--- Start of frontend/src/api/models/userRegistrationRequestFamilyName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestFamilyName = string | null


--- Start of frontend/src/api/models/promptTemplateOutputMessagesTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { TextMessageTemplate } from './textMessageTemplate'

export type PromptTemplateOutputMessagesTemplate = TextMessageTemplate[] | null


--- Start of frontend/src/api/models/textMessageSectionTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMMessageRole } from './lLMMessageRole'
import type { LLMMessageType } from './lLMMessageType'
import type { TextMessageSectionTemplateId } from './textMessageSectionTemplateId'
import type { TextMessageSectionTemplateTitle } from './textMessageSectionTemplateTitle'
import type { TextMessageSectionTemplateUuid } from './textMessageSectionTemplateUuid'

export interface TextMessageSectionTemplate {
  createdAt?: string
  id?: TextMessageSectionTemplateId
  role: LLMMessageRole
  template?: string
  title?: TextMessageSectionTemplateTitle
  type?: LLMMessageType
  uuid?: TextMessageSectionTemplateUuid
}


--- Start of frontend/src/api/models/messageRole.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageRole = {
  user: 'user',
  assistant: 'assistant',
} as const


--- Start of frontend/src/api/models/agentReadResponseAssets.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetReadResponse } from './assetReadResponse'

export type AgentReadResponseAssets = AssetReadResponse[] | null


--- Start of frontend/src/api/models/searchResultsResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { SearchResultsResponseAsset } from './searchResultsResponseAsset'
import type { SearchResultsResponseConversation } from './searchResultsResponseConversation'
import type { SearchResultsResponseMessage } from './searchResultsResponseMessage'

export interface SearchResultsResponse {
  asset?: SearchResultsResponseAsset
  conversation?: SearchResultsResponseConversation
  message?: SearchResultsResponseMessage
}


--- Start of frontend/src/api/models/assetReadResponseIngestionMetadata.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { IngestionMetadata } from './ingestionMetadata'

export type AssetReadResponseIngestionMetadata = IngestionMetadata | null


--- Start of frontend/src/api/models/conversationSearchResultText.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ConversationSearchResultText = string | null


--- Start of frontend/src/api/models/auditLogReadResponseContextAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseContextAnyOf = { [key: string]: unknown }


--- Start of frontend/src/api/models/auditLogReadResponseConversationUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseConversationUuid = string | null


--- Start of frontend/src/api/models/messageType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageType = (typeof MessageType)[keyof typeof MessageType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageType = {
  audio: 'audio',
  image: 'image',
  multimodal: 'multimodal',
  text: 'text',
  video: 'video',
} as const


--- Start of frontend/src/api/models/messageReadResponseReasoning.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageReadResponseReasoning = string | null


--- Start of frontend/src/api/models/index.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export * from './agentConfigCreate'
export * from './agentConfigCreateFromExisting'
export * from './agentConfigCreateFromExistingIsActive'
export * from './agentConfigCreateFromExistingName'
export * from './agentConfigCreateFromExistingNotes'
export * from './agentConfigCreateFromExistingPromptTemplate'
export * from './agentConfigCreateNotes'
export * from './agentConfigCreateToolUseSectionTemplates'
export * from './agentConfigReadResponse'
export * from './agentConfigReadResponseNotes'
export * from './agentConfigReadResponseUpdatedAt'
export * from './agentConfigStatus'
export * from './agentConfigsListResponse'
export * from './agentCreate'
export * from './agentCreateBaselineConfigUuid'
export * from './agentCreateDescription'
export * from './agentReadResponse'
export * from './agentReadResponseAssets'
export * from './agentReadResponseDescription'
export * from './agentReadResponseOwnerUsername'
export * from './agentReadResponseOwnerUuid'
export * from './agentStockResponses'
export * from './agentStockResponsesInitialMessage'
export * from './agentType'
export * from './agentUpdate'
export * from './agentUpdateAssetUuids'
export * from './agentUpdateDescription'
export * from './agentUpdateIsPublic'
export * from './agentUpdateLlmModelId'
export * from './agentUpdateName'
export * from './agentsListResponse'
export * from './assetCreateError'
export * from './assetCreateErrorErrorLog'
export * from './assetIndexResults'
export * from './assetIndexResultsFilters'
export * from './assetReadResponse'
export * from './assetReadResponseAgentUuid'
export * from './assetReadResponseConversationUuid'
export * from './assetReadResponseDescription'
export * from './assetReadResponseIngestionErrorLog'
export * from './assetReadResponseIngestionMetadata'
export * from './assetReadResponseIngestionStatus'
export * from './assetReadResponseIngestionStepLogs'
export * from './assetReadResponseMessageUuid'
export * from './assetReadResponseSourceUrl'
export * from './assetSearchResult'
export * from './assetSearchResultAgentUuid'
export * from './assetSearchResultContent'
export * from './assetSearchResultContentHash'
export * from './assetSearchResultConversationName'
export * from './assetSearchResultDescription'
export * from './assetSearchResultIngestionStatus'
export * from './assetSearchResultMessageUuid'
export * from './assetSearchResultSummary'
export * from './assetSearchResultText'
export * from './assetSearchResultUpdatedAt'
export * from './assetType'
export * from './assetsCreateResponse'
export * from './assetsListResponse'
export * from './auditActionType'
export * from './auditLogReadResponse'
export * from './auditLogReadResponseAssetUuid'
export * from './auditLogReadResponseChanges'
export * from './auditLogReadResponseChangesAnyOf'
export * from './auditLogReadResponseContext'
export * from './auditLogReadResponseContextAnyOf'
export * from './auditLogReadResponseConversationUuid'
export * from './auditLogReadResponseEntity'
export * from './auditLogReadResponseEntityUuid'
export * from './auditLogReadResponseMessageUuid'
export * from './auditLogsListResponse'
export * from './availableResponse'
export * from './bodyCreateAssetsApiAssetPost'
export * from './bodyLoginApiAuthLoginPost'
export * from './bodyLoginApiAuthLoginPostClientId'
export * from './bodyLoginApiAuthLoginPostClientSecret'
export * from './bodyLoginApiAuthLoginPostGrantType'
export * from './bodyRunToolApiToolToolRegistryIdPost'
export * from './bodyRunToolApiToolToolRegistryIdPostToolInputs'
export * from './bodyRunToolApiToolToolRegistryIdPostToolOptions'
export * from './bodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf'
export * from './checkUsernameAvailableParams'
export * from './conversationHistoryResponse'
export * from './conversationIndexResults'
export * from './conversationIndexResultsFilters'
export * from './conversationListResponse'
export * from './conversationPatchRequest'
export * from './conversationPatchRequestName'
export * from './conversationReadResponse'
export * from './conversationReadResponseUpdatedAt'
export * from './conversationSearchResult'
export * from './conversationSearchResultText'
export * from './conversationSearchResultUpdatedAt'
export * from './conversationStarter'
export * from './conversationStarterListResponse'
export * from './createAssetsParams'
export * from './defaultConversationSettings'
export * from './deleteQueryFromSearchHistoryParams'
export * from './feedbackCreate'
export * from './feedbackCreateRating'
export * from './feedbackCreateTargetUuid'
export * from './feedbackCreateUrl'
export * from './feedbackRating'
export * from './feedbackResponse'
export * from './feedbackResponseAgentUuid'
export * from './feedbackResponseAssetUuid'
export * from './feedbackResponseConversationUuid'
export * from './feedbackResponseMessageUuid'
export * from './feedbackResponseRating'
export * from './feedbackResponseUpdatedAt'
export * from './feedbackResponseUrl'
export * from './feedbackTarget'
export * from './feedbackType'
export * from './finishReason'
export * from './generationMetadata'
export * from './generationMetadataCostUsd'
export * from './generationMetadataDurationMs'
export * from './generationMetadataFinishReason'
export * from './generationMetadataOutputTokens'
export * from './generationMetadataSettings'
export * from './generationMetadataTimeToFirstTokenMs'
export * from './generationMetadataTokensPerSecond'
export * from './generationMetadataToolCalls'
export * from './generationSettings'
export * from './generationSettingsExtra'
export * from './generationSettingsMaxOutputTokens'
export * from './generationSettingsReasoningEffort'
export * from './getAllAssetsParams'
export * from './getAllAuditLogsParams'
export * from './getAvailableLlmInfosParams'
export * from './getConversationStartersParams'
export * from './getSearchHistoryParams'
export * from './getSupportedExtensionsParams'
export * from './hTTPValidationError'
export * from './ingestionErrorLog'
export * from './ingestionErrorType'
export * from './ingestionMetadata'
export * from './ingestionMetadataFailedAt'
export * from './ingestionMetadataIndexingCompletedAt'
export * from './ingestionMetadataIngestedAt'
export * from './ingestionMetadataParsingCompletedAt'
export * from './ingestionMetadataProcessingCompletedAt'
export * from './ingestionStatus'
export * from './ingestionStepLog'
export * from './ingestionStepLogCompletedAt'
export * from './ingestionStepLogExecutionDetails'
export * from './lLMInfo'
export * from './lLMInfoListResponse'
export * from './lLMInfoResponse'
export * from './lLMInfoResponseNotSelectableReason'
export * from './lLMMessageRole'
export * from './lLMMessageType'
export * from './lLMNotSelectableReason'
export * from './lLMProviderInfo'
export * from './lLMProviderInfoDescription'
export * from './lLMProviderInfoImageUrl'
export * from './messageCreate'
export * from './messageCreateAgentConfigUuid'
export * from './messageCreateAssetUuids'
export * from './messageIndexResults'
export * from './messageIndexResultsFilters'
export * from './messageReadResponse'
export * from './messageReadResponseAgentConfigVersion'
export * from './messageReadResponseAssets'
export * from './messageReadResponseConversationNameUpdatedStreaming'
export * from './messageReadResponseGenerationMetadata'
export * from './messageReadResponseLlmModelId'
export * from './messageReadResponseReasoning'
export * from './messageReadResponseToolUseResponse'
export * from './messageReadResponseUpdatedAt'
export * from './messageRole'
export * from './messageSearchResult'
export * from './messageSearchResultAgentUuid'
export * from './messageSearchResultAuthorImageUrl'
export * from './messageSearchResultLlmModelId'
export * from './messageSearchResultText'
export * from './messageSearchResultUpdatedAt'
export * from './messageSearchResultUserUuid'
export * from './messageStatus'
export * from './messageType'
export * from './messageUpdate'
export * from './messageUpdateAssetUuids'
export * from './messageUpdateContent'
export * from './patchUserMessageParams'
export * from './patchUserMessageStreamingParams'
export * from './patchUserRequest'
export * from './patchUserRequestAppSettings'
export * from './patchUserRequestCountry'
export * from './patchUserRequestDefaultConversationSettings'
export * from './patchUserRequestDescription'
export * from './patchUserRequestFamilyName'
export * from './patchUserRequestGivenName'
export * from './patchUserRequestImageUrl'
export * from './patchUserRequestLanguageCode'
export * from './patchUserRequestLocale'
export * from './patchUserRequestTimezone'
export * from './promptTemplateInput'
export * from './promptTemplateInputCompletionTemplate'
export * from './promptTemplateInputMessagesTemplate'
export * from './promptTemplateInputSectionsTemplate'
export * from './promptTemplateOutput'
export * from './promptTemplateOutputCompletionTemplate'
export * from './promptTemplateOutputMessagesTemplate'
export * from './promptTemplateOutputSectionsTemplate'
export * from './reasoningDetection'
export * from './reasoningEffort'
export * from './rebuildSearchIndicesParams'
export * from './regenerateAgentMessageParams'
export * from './regenerateAgentMessageStreamingParams'
export * from './runTool200'
export * from './runToolParams'
export * from './searchHistoryResponse'
export * from './searchRequest'
export * from './searchRequestConversationUuidFilter'
export * from './searchRequestMessageRoleFilter'
export * from './searchRequestMessageTypeFilter'
export * from './searchRequestTruncateTextFieldsToLength'
export * from './searchResultsResponse'
export * from './searchResultsResponseAsset'
export * from './searchResultsResponseConversation'
export * from './searchResultsResponseMessage'
export * from './sendMessageAndReceiveGeneratedAgentResponseStreamingParams'
export * from './sendMessageAndReceiveGeneratedResponseParams'
export * from './supportedFileExtensionsResponse'
export * from './tags'
export * from './textMessageSectionID'
export * from './textMessageSectionTemplate'
export * from './textMessageSectionTemplateId'
export * from './textMessageSectionTemplateTitle'
export * from './textMessageSectionTemplateUuid'
export * from './textMessageTemplate'
export * from './textMessageTemplateUuid'
export * from './tool'
export * from './toolCall'
export * from './toolOptions'
export * from './toolOptionsAnyOf'
export * from './toolOutputFile'
export * from './toolOutputFileDescription'
export * from './toolOutputFileLocalPath'
export * from './toolOutputFileRemotePath'
export * from './toolOutputFormatting'
export * from './toolReadResponse'
export * from './toolReadResponseInputsSchema'
export * from './toolReadResponseOptionsSchema'
export * from './toolReadResponseOptionsSchemaAnyOf'
export * from './toolReadResponseOutputsSchema'
export * from './toolUseConfig'
export * from './toolUseInfo'
export * from './toolUseInfoCompletedAt'
export * from './toolUseInfoGenerationContext'
export * from './toolUseInfoInputs'
export * from './toolUseInfoInputsAnyOf'
export * from './toolUseInfoOutputs'
export * from './toolUseInfoOutputsAnyOf'
export * from './toolUseOptions'
export * from './toolUsePromptTemplateSections'
export * from './toolUseResponse'
export * from './toolUseStatus'
export * from './toolsListResponse'
export * from './userAppSettings'
export * from './userAppSettingsTheme'
export * from './userProfile'
export * from './userProfileCountry'
export * from './userProfileDescription'
export * from './userProfileFamilyName'
export * from './userProfileGivenName'
export * from './userProfileImageUrl'
export * from './userProfileLanguageCode'
export * from './userProfileLocale'
export * from './userProfileTimezone'
export * from './userRegistrationRequest'
export * from './userRegistrationRequestCountry'
export * from './userRegistrationRequestDescription'
export * from './userRegistrationRequestFamilyName'
export * from './userRegistrationRequestGivenName'
export * from './userRegistrationRequestImageUrl'
export * from './userRegistrationRequestLanguageCode'
export * from './userRegistrationRequestLocale'
export * from './userRegistrationRequestTimezone'
export * from './validationError'
export * from './validationErrorLocItem'


--- Start of frontend/src/api/models/agentConfigStatus.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentConfigStatus =
  (typeof AgentConfigStatus)[keyof typeof AgentConfigStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AgentConfigStatus = {
  active: 'active',
  inactive: 'inactive',
  disabled: 'disabled',
} as const


--- Start of frontend/src/api/models/promptTemplateOutputSectionsTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { TextMessageSectionTemplate } from './textMessageSectionTemplate'

export type PromptTemplateOutputSectionsTemplate =
  | TextMessageSectionTemplate[]
  | null


--- Start of frontend/src/api/models/feedbackResponseUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackResponseUpdatedAt = string | null


--- Start of frontend/src/api/models/searchRequestConversationUuidFilter.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type SearchRequestConversationUuidFilter = string | null


--- Start of frontend/src/api/models/toolUseInfoOutputsAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolUseInfoOutputsAnyOf = { [key: string]: unknown }


--- Start of frontend/src/api/models/sendMessageAndReceiveGeneratedAgentResponseStreamingParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type SendMessageAndReceiveGeneratedAgentResponseStreamingParams = {
  conversationUuid?: string | null
}


--- Start of frontend/src/api/models/generationMetadataOutputTokens.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationMetadataOutputTokens = number | null


--- Start of frontend/src/api/models/agentReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentConfigReadResponse } from './agentConfigReadResponse'
import type { AgentReadResponseAssets } from './agentReadResponseAssets'
import type { AgentReadResponseDescription } from './agentReadResponseDescription'
import type { AgentReadResponseOwnerUsername } from './agentReadResponseOwnerUsername'
import type { AgentReadResponseOwnerUuid } from './agentReadResponseOwnerUuid'
import type { AgentType } from './agentType'

export interface AgentReadResponse {
  activeConfig: AgentConfigReadResponse
  agentConfigs: AgentConfigReadResponse[]
  assets?: AgentReadResponseAssets
  description?: AgentReadResponseDescription
  isPublic: boolean
  llmModelId: string
  name: string
  ownerUsername?: AgentReadResponseOwnerUsername
  ownerUuid?: AgentReadResponseOwnerUuid
  type: AgentType
  uuid: string
}


--- Start of frontend/src/api/models/agentConfigCreateFromExisting.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentConfigCreateFromExistingIsActive } from './agentConfigCreateFromExistingIsActive'
import type { AgentConfigCreateFromExistingName } from './agentConfigCreateFromExistingName'
import type { AgentConfigCreateFromExistingNotes } from './agentConfigCreateFromExistingNotes'
import type { AgentConfigCreateFromExistingPromptTemplate } from './agentConfigCreateFromExistingPromptTemplate'
import type { AgentStockResponses } from './agentStockResponses'
import type { Tool } from './tool'

export interface AgentConfigCreateFromExisting {
  isActive?: AgentConfigCreateFromExistingIsActive
  name?: AgentConfigCreateFromExistingName
  notes?: AgentConfigCreateFromExistingNotes
  promptTemplate?: AgentConfigCreateFromExistingPromptTemplate
  stockResponses?: AgentStockResponses
  tools?: Tool[]
}


--- Start of frontend/src/api/models/assetsCreateResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AssetCreateError } from './assetCreateError'
import type { AssetReadResponse } from './assetReadResponse'

export interface AssetsCreateResponse {
  errors: AssetCreateError[]
  items: AssetReadResponse[]
}


--- Start of frontend/src/api/models/messageReadResponseLlmModelId.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageReadResponseLlmModelId = string | null


--- Start of frontend/src/api/models/assetType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetType = (typeof AssetType)[keyof typeof AssetType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssetType = {
  audio: 'audio',
  image: 'image',
  pdf: 'pdf',
  other: 'other',
  text: 'text',
  video: 'video',
} as const


--- Start of frontend/src/api/models/getAllAuditLogsParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GetAllAuditLogsParams = {
  conversationUuid?: string | null
  assetUuid?: string | null
  messageUuid?: string | null
}


--- Start of frontend/src/api/models/lLMMessageRole.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type LLMMessageRole =
  (typeof LLMMessageRole)[keyof typeof LLMMessageRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LLMMessageRole = {
  system: 'system',
  user: 'user',
  assistant: 'assistant',
} as const


--- Start of frontend/src/api/models/bodyLoginApiAuthLoginPostClientSecret.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type BodyLoginApiAuthLoginPostClientSecret = string | null


--- Start of frontend/src/api/models/lLMMessageType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type LLMMessageType =
  (typeof LLMMessageType)[keyof typeof LLMMessageType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LLMMessageType = {
  text: 'text',
  multimodal: 'multimodal',
} as const


--- Start of frontend/src/api/models/feedbackCreateUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

/**
 * Required for application feedback, optional for all others
 */
export type FeedbackCreateUrl = string | null


--- Start of frontend/src/api/models/conversationSearchResult.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationSearchResultText } from './conversationSearchResultText'
import type { ConversationSearchResultUpdatedAt } from './conversationSearchResultUpdatedAt'

export interface ConversationSearchResult {
  createdAt?: string
  name: string
  rankingScore: number
  text?: ConversationSearchResultText
  updatedAt?: ConversationSearchResultUpdatedAt
  uuid?: string
  [key: string]: unknown
}


--- Start of frontend/src/api/models/auditLogReadResponseAssetUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AuditLogReadResponseAssetUuid = string | null


--- Start of frontend/src/api/models/assetReadResponseSourceUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetReadResponseSourceUrl = string | null


--- Start of frontend/src/api/models/feedbackType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackType = {
  bug: 'bug',
  featureRequest: 'feature_request',
  improvement: 'improvement',
  other: 'other',
  performance: 'performance',
  quality: 'quality',
  question: 'question',
  usability: 'usability',
} as const


--- Start of frontend/src/api/models/feedbackResponseAgentUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type FeedbackResponseAgentUuid = string | null


--- Start of frontend/src/api/models/toolReadResponseInputsSchema.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolReadResponseInputsSchema = { [key: string]: unknown }


--- Start of frontend/src/api/models/userRegistrationRequestTimezone.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserRegistrationRequestTimezone = string | null


--- Start of frontend/src/api/models/promptTemplateInput.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { GenerationSettings } from './generationSettings'
import type { PromptTemplateInputCompletionTemplate } from './promptTemplateInputCompletionTemplate'
import type { PromptTemplateInputMessagesTemplate } from './promptTemplateInputMessagesTemplate'
import type { PromptTemplateInputSectionsTemplate } from './promptTemplateInputSectionsTemplate'

export interface PromptTemplateInput {
  completionTemplate?: PromptTemplateInputCompletionTemplate
  generationSettings?: GenerationSettings
  messagesTemplate?: PromptTemplateInputMessagesTemplate
  name: string
  sectionsTemplate?: PromptTemplateInputSectionsTemplate
}


--- Start of frontend/src/api/models/textMessageTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMMessageRole } from './lLMMessageRole'
import type { LLMMessageType } from './lLMMessageType'
import type { TextMessageTemplateUuid } from './textMessageTemplateUuid'

/**
 * This class allows you to make templates for text message types.
One template takes a role and the template specific to that role,
and that can be fed into a [PromptTemplate][tribe_ai.clients.llm.models.template.PromptTemplate] object.
 */
export interface TextMessageTemplate {
  createdAt?: string
  role: LLMMessageRole
  template?: string
  type?: LLMMessageType
  uuid?: TextMessageTemplateUuid
}


--- Start of frontend/src/api/models/agentCreateBaselineConfigUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentCreateBaselineConfigUuid = string | null


--- Start of frontend/src/api/models/toolOutputFileDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolOutputFileDescription = string | null


--- Start of frontend/src/api/models/userProfile.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { DefaultConversationSettings } from './defaultConversationSettings'
import type { UserAppSettings } from './userAppSettings'
import type { UserProfileCountry } from './userProfileCountry'
import type { UserProfileDescription } from './userProfileDescription'
import type { UserProfileFamilyName } from './userProfileFamilyName'
import type { UserProfileGivenName } from './userProfileGivenName'
import type { UserProfileImageUrl } from './userProfileImageUrl'
import type { UserProfileLanguageCode } from './userProfileLanguageCode'
import type { UserProfileLocale } from './userProfileLocale'
import type { UserProfileTimezone } from './userProfileTimezone'

export interface UserProfile {
  appSettings?: UserAppSettings
  country?: UserProfileCountry
  defaultConversationSettings?: DefaultConversationSettings
  description?: UserProfileDescription
  email: string
  familyName?: UserProfileFamilyName
  givenName?: UserProfileGivenName
  imageUrl?: UserProfileImageUrl
  languageCode?: UserProfileLanguageCode
  locale?: UserProfileLocale
  timezone?: UserProfileTimezone
  username: string
  uuid: string
}


--- Start of frontend/src/api/models/lLMInfoResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMInfoResponseNotSelectableReason } from './lLMInfoResponseNotSelectableReason'
import type { LLMProviderInfo } from './lLMProviderInfo'

export interface LLMInfoResponse {
  llmModelDisplayName: string
  llmModelId: string
  maxOutputTokens: number
  notSelectableReason?: LLMInfoResponseNotSelectableReason
  provider: LLMProviderInfo
  selectable?: boolean
  selected?: boolean
  supportsAudio: boolean
  supportsImages: boolean
}


--- Start of frontend/src/api/models/promptTemplateInputMessagesTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { TextMessageTemplate } from './textMessageTemplate'

export type PromptTemplateInputMessagesTemplate = TextMessageTemplate[] | null


--- Start of frontend/src/api/models/textMessageSectionID.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type TextMessageSectionID =
  (typeof TextMessageSectionID)[keyof typeof TextMessageSectionID]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TextMessageSectionID = {
  role: 'role',
  taskInstructions: 'task_instructions',
  taskExamples: 'task_examples',
  conversationHistorySummary: 'conversation_history_summary',
  toolUseInstructions: 'tool_use_instructions',
  toolUseOutputFormat: 'tool_use_output_format',
  toolUseOutput: 'tool_use_output',
  toolUseNextStepInitial: 'tool_use_next_step_initial',
  toolUseNextStepSuccessAndAvailable:
    'tool_use_next_step_success_and_available',
  toolUseNextStepSuccessAndNotAvailable:
    'tool_use_next_step_success_and_not_available',
  toolUseNextStepErrorAndAvailable: 'tool_use_next_step_error_and_available',
  toolUseNextStepErrorAndNotAvailable:
    'tool_use_next_step_error_and_not_available',
} as const


--- Start of frontend/src/api/models/agentStockResponses.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { AgentStockResponsesInitialMessage } from './agentStockResponsesInitialMessage'

/**
 * Stock responses that can be returned or appended to the agent's response for certain scenarios.
 */
export interface AgentStockResponses {
  initialMessage?: AgentStockResponsesInitialMessage
  maxLengthReached?: string
}


--- Start of frontend/src/api/models/assetReadResponseMessageUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetReadResponseMessageUuid = string | null


--- Start of frontend/src/api/models/bodyLoginApiAuthLoginPost.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { BodyLoginApiAuthLoginPostClientId } from './bodyLoginApiAuthLoginPostClientId'
import type { BodyLoginApiAuthLoginPostClientSecret } from './bodyLoginApiAuthLoginPostClientSecret'
import type { BodyLoginApiAuthLoginPostGrantType } from './bodyLoginApiAuthLoginPostGrantType'

export interface BodyLoginApiAuthLoginPost {
  clientId?: BodyLoginApiAuthLoginPostClientId
  clientSecret?: BodyLoginApiAuthLoginPostClientSecret
  grantType?: BodyLoginApiAuthLoginPostGrantType
  password: string
  scope?: string
  username: string
}


--- Start of frontend/src/api/models/toolOptionsAnyOf.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolOptionsAnyOf = { [key: string]: unknown }


--- Start of frontend/src/api/models/generationMetadataDurationMs.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationMetadataDurationMs = number | null


--- Start of frontend/src/api/models/generationMetadataTokensPerSecond.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type GenerationMetadataTokensPerSecond = number | null


--- Start of frontend/src/api/models/toolUseStatus.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ToolUseStatus = (typeof ToolUseStatus)[keyof typeof ToolUseStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolUseStatus = {
  pending: 'pending',
  inProgress: 'in_progress',
  retrying: 'retrying',
  completed: 'completed',
  failed: 'failed',
} as const


--- Start of frontend/src/api/models/userProfileTimezone.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type UserProfileTimezone = string | null


--- Start of frontend/src/api/models/lLMInfoListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { LLMInfoResponse } from './lLMInfoResponse'

export interface LLMInfoListResponse {
  items: LLMInfoResponse[]
}


--- Start of frontend/src/api/models/assetSearchResultAgentUuid.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultAgentUuid = string | null


--- Start of frontend/src/api/models/generationMetadataToolCalls.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolCall } from './toolCall'

export type GenerationMetadataToolCalls = ToolCall[] | null


--- Start of frontend/src/api/models/toolUsePromptTemplateSections.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { TextMessageSectionTemplate } from './textMessageSectionTemplate'

export interface ToolUsePromptTemplateSections {
  toolUseInstructions: TextMessageSectionTemplate
  toolUseNextStepErrorAndAvailable: TextMessageSectionTemplate
  toolUseNextStepErrorAndNotAvailable: TextMessageSectionTemplate
  toolUseNextStepInitial: TextMessageSectionTemplate
  toolUseNextStepSuccessAndAvailable: TextMessageSectionTemplate
  toolUseNextStepSuccessAndNotAvailable: TextMessageSectionTemplate
  toolUseOutput: TextMessageSectionTemplate
  toolUseOutputFormat: TextMessageSectionTemplate
}


--- Start of frontend/src/api/models/conversationPatchRequest.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationPatchRequestName } from './conversationPatchRequestName'

export interface ConversationPatchRequest {
  name?: ConversationPatchRequestName
}


--- Start of frontend/src/api/models/promptTemplateInputSectionsTemplate.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { TextMessageSectionTemplate } from './textMessageSectionTemplate'

export type PromptTemplateInputSectionsTemplate =
  | TextMessageSectionTemplate[]
  | null


--- Start of frontend/src/api/models/patchUserRequestImageUrl.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type PatchUserRequestImageUrl = string | null


--- Start of frontend/src/api/models/bodyRunToolApiToolToolRegistryIdPostToolOptions.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { BodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf } from './bodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf'

export type BodyRunToolApiToolToolRegistryIdPostToolOptions =
  BodyRunToolApiToolToolRegistryIdPostToolOptionsAnyOf | null


--- Start of frontend/src/api/models/ingestionMetadataIndexingCompletedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type IngestionMetadataIndexingCompletedAt = string | null


--- Start of frontend/src/api/models/messageStatus.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageStatus = {
  inProgress: 'in_progress',
  interrupted: 'interrupted',
  completed: 'completed',
  failed: 'failed',
  edited: 'edited',
  starting: 'starting',
} as const


--- Start of frontend/src/api/models/tags.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export interface Tags {
  start: string
  stop: string
}


--- Start of frontend/src/api/models/agentUpdateName.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AgentUpdateName = string | null


--- Start of frontend/src/api/models/toolsListResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolReadResponse } from './toolReadResponse'

export interface ToolsListResponse {
  items: ToolReadResponse[]
}


--- Start of frontend/src/api/models/toolUseResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolUseInfo } from './toolUseInfo'
import type { ToolUseOptions } from './toolUseOptions'

export interface ToolUseResponse {
  createdAt?: string
  options: ToolUseOptions
  toolUseInfos?: ToolUseInfo[]
}


--- Start of frontend/src/api/models/searchResultsResponseMessage.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageIndexResults } from './messageIndexResults'

export type SearchResultsResponseMessage = MessageIndexResults | null


--- Start of frontend/src/api/models/messageSearchResultLlmModelId.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type MessageSearchResultLlmModelId = string | null


--- Start of frontend/src/api/models/toolReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ToolReadResponseInputsSchema } from './toolReadResponseInputsSchema'
import type { ToolReadResponseOptionsSchema } from './toolReadResponseOptionsSchema'
import type { ToolReadResponseOutputsSchema } from './toolReadResponseOutputsSchema'

export interface ToolReadResponse {
  description: string
  inputsSchema: ToolReadResponseInputsSchema
  name: string
  optionsSchema?: ToolReadResponseOptionsSchema
  outputsSchema: ToolReadResponseOutputsSchema
  toolRegistryId: string
}


--- Start of frontend/src/api/models/feedbackCreateRating.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { FeedbackRating } from './feedbackRating'

export type FeedbackCreateRating = FeedbackRating | null


--- Start of frontend/src/api/models/validationErrorLocItem.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ValidationErrorLocItem = string | number


--- Start of frontend/src/api/models/messageReadResponseGenerationMetadata.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { GenerationMetadata } from './generationMetadata'

export type MessageReadResponseGenerationMetadata = GenerationMetadata | null


--- Start of frontend/src/api/models/runToolParams.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type RunToolParams = {
  agentUuid?: string | null
  conversationUuid?: string | null
}


--- Start of frontend/src/api/models/assetSearchResultDescription.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultDescription = string | null


--- Start of frontend/src/api/models/bodyLoginApiAuthLoginPostGrantType.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type BodyLoginApiAuthLoginPostGrantType = string | null


--- Start of frontend/src/api/models/conversationIndexResults.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { ConversationIndexResultsFilters } from './conversationIndexResultsFilters'
import type { ConversationSearchResult } from './conversationSearchResult'

export interface ConversationIndexResults {
  filters: ConversationIndexResultsFilters
  hits: ConversationSearchResult[]
  indexName?: string
  limit: number
  offset: number
  processingTimeMs: number
  query: string
  totalHits: number
}


--- Start of frontend/src/api/models/conversationReadResponseUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type ConversationReadResponseUpdatedAt = string | null


--- Start of frontend/src/api/models/messageReadResponse.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type { MessageReadResponseAgentConfigVersion } from './messageReadResponseAgentConfigVersion'
import type { MessageReadResponseAssets } from './messageReadResponseAssets'
import type { MessageReadResponseConversationNameUpdatedStreaming } from './messageReadResponseConversationNameUpdatedStreaming'
import type { MessageReadResponseGenerationMetadata } from './messageReadResponseGenerationMetadata'
import type { MessageReadResponseLlmModelId } from './messageReadResponseLlmModelId'
import type { MessageReadResponseReasoning } from './messageReadResponseReasoning'
import type { MessageReadResponseToolUseResponse } from './messageReadResponseToolUseResponse'
import type { MessageReadResponseUpdatedAt } from './messageReadResponseUpdatedAt'
import type { MessageRole } from './messageRole'
import type { MessageStatus } from './messageStatus'
import type { MessageType } from './messageType'

export interface MessageReadResponse {
  agentConfigVersion?: MessageReadResponseAgentConfigVersion
  assets?: MessageReadResponseAssets
  authorName: string
  content: string
  /** When streaming messages, this field is used to update the conversation name at the end of the stream */
  conversationNameUpdatedStreaming?: MessageReadResponseConversationNameUpdatedStreaming
  conversationUuid: string
  createdAt: string
  generationMetadata?: MessageReadResponseGenerationMetadata
  llmModelId?: MessageReadResponseLlmModelId
  reasoning?: MessageReadResponseReasoning
  role: MessageRole
  status: MessageStatus
  toolUseResponse?: MessageReadResponseToolUseResponse
  readonly totalCostUsd: number
  type: MessageType
  updatedAt?: MessageReadResponseUpdatedAt
  uuid: string
}


--- Start of frontend/src/api/models/assetSearchResultUpdatedAt.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */

export type AssetSearchResultUpdatedAt = string | null


--- Start of frontend/src/api/schemas/zod.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import { z as zod } from 'zod'

/**
 * @summary Get All Agents
 */
export const getAllAgentsResponse = zod.object({
  items: zod.array(
    zod.object({
      uuid: zod.string().uuid(),
      type: zod.enum(['ai', 'human']),
      name: zod.string(),
      description: zod.string().or(zod.null()).optional(),
      isPublic: zod.boolean(),
      llmModelId: zod.string(),
      activeConfig: zod.object({
        uuid: zod.string().uuid().optional(),
        version: zod.number().optional(),
        notes: zod.string().or(zod.null()).optional(),
        agentClass: zod.string(),
        reasoningDetection: zod
          .object({
            enabled: zod.boolean().optional(),
            tags: zod
              .object({
                start: zod.string(),
                stop: zod.string(),
              })
              .optional(),
          })
          .optional(),
        promptTemplate: zod.object({
          name: zod.string(),
          completionTemplate: zod.string().or(zod.null()).optional(),
          messagesTemplate: zod
            .array(
              zod.object({
                uuid: zod.string().uuid().or(zod.null()).optional(),
                createdAt: zod.string().datetime().optional(),
                type: zod.enum(['text', 'multimodal']).optional(),
                role: zod.enum(['system', 'user', 'assistant']),
                template: zod.string().optional(),
              }),
            )
            .or(zod.null())
            .optional(),
          sectionsTemplate: zod
            .array(
              zod.object({
                uuid: zod.string().uuid().or(zod.null()).optional(),
                createdAt: zod.string().datetime().optional(),
                type: zod.enum(['text', 'multimodal']).optional(),
                role: zod.enum(['system', 'user', 'assistant']),
                template: zod.string().optional(),
                id: zod
                  .enum([
                    'role',
                    'task_instructions',
                    'task_examples',
                    'conversation_history_summary',
                    'tool_use_instructions',
                    'tool_use_output_format',
                    'tool_use_output',
                    'tool_use_next_step_initial',
                    'tool_use_next_step_success_and_available',
                    'tool_use_next_step_success_and_not_available',
                    'tool_use_next_step_error_and_available',
                    'tool_use_next_step_error_and_not_available',
                  ])
                  .or(zod.null())
                  .optional(),
                title: zod.string().or(zod.null()).optional(),
              }),
            )
            .or(zod.null())
            .optional(),
          generationSettings: zod
            .object({
              maxOutputTokens: zod.number().or(zod.null()).optional(),
              temperature: zod.number().optional(),
              stopSequences: zod.array(zod.string()).optional(),
              cachingEnabled: zod.boolean().optional(),
              reasoningEffort: zod
                .enum(['low', 'medium', 'high'])
                .or(zod.null())
                .optional(),
              extra: zod.record(zod.string(), zod.string()).optional(),
            })
            .optional(),
        }),
        stockResponses: zod
          .object({
            initialMessage: zod.string().or(zod.null()).optional(),
            maxLengthReached: zod.string().optional(),
          })
          .optional(),
        tools: zod.array(
          zod.object({
            registryId: zod.string(),
            options: zod.object({}).or(zod.null()).optional(),
          }),
        ),
        toolUseConfig: zod
          .object({
            maxSubsequentToolUses: zod.number().optional(),
            maxRetries: zod.number().optional(),
            outputFormatting: zod
              .enum(['custom', 'json', 'xml', 'yaml'])
              .optional(),
            outputMaxTokens: zod.number().optional(),
          })
          .optional(),
        createdAt: zod.string().datetime().optional(),
        updatedAt: zod.string().datetime().or(zod.null()).optional(),
        name: zod.string(),
        status: zod.enum(['active', 'inactive', 'disabled']),
        agentUuid: zod.string().uuid(),
        toolDefinitions: zod
          .array(
            zod.object({
              toolRegistryId: zod.string(),
              name: zod.string(),
              description: zod.string(),
              inputsSchema: zod.object({}),
              outputsSchema: zod.object({}),
              optionsSchema: zod.object({}).or(zod.null()).optional(),
            }),
          )
          .optional(),
        isEditable: zod.boolean().optional(),
      }),
      agentConfigs: zod.array(
        zod.object({
          uuid: zod.string().uuid().optional(),
          version: zod.number().optional(),
          notes: zod.string().or(zod.null()).optional(),
          agentClass: zod.string(),
          reasoningDetection: zod
            .object({
              enabled: zod.boolean().optional(),
              tags: zod
                .object({
                  start: zod.string(),
                  stop: zod.string(),
                })
                .optional(),
            })
            .optional(),
          promptTemplate: zod.object({
            name: zod.string(),
            completionTemplate: zod.string().or(zod.null()).optional(),
            messagesTemplate: zod
              .array(
                zod.object({
                  uuid: zod.string().uuid().or(zod.null()).optional(),
                  createdAt: zod.string().datetime().optional(),
                  type: zod.enum(['text', 'multimodal']).optional(),
                  role: zod.enum(['system', 'user', 'assistant']),
                  template: zod.string().optional(),
                }),
              )
              .or(zod.null())
              .optional(),
            sectionsTemplate: zod
              .array(
                zod.object({
                  uuid: zod.string().uuid().or(zod.null()).optional(),
                  createdAt: zod.string().datetime().optional(),
                  type: zod.enum(['text', 'multimodal']).optional(),
                  role: zod.enum(['system', 'user', 'assistant']),
                  template: zod.string().optional(),
                  id: zod
                    .enum([
                      'role',
                      'task_instructions',
                      'task_examples',
                      'conversation_history_summary',
                      'tool_use_instructions',
                      'tool_use_output_format',
                      'tool_use_output',
                      'tool_use_next_step_initial',
                      'tool_use_next_step_success_and_available',
                      'tool_use_next_step_success_and_not_available',
                      'tool_use_next_step_error_and_available',
                      'tool_use_next_step_error_and_not_available',
                    ])
                    .or(zod.null())
                    .optional(),
                  title: zod.string().or(zod.null()).optional(),
                }),
              )
              .or(zod.null())
              .optional(),
            generationSettings: zod
              .object({
                maxOutputTokens: zod.number().or(zod.null()).optional(),
                temperature: zod.number().optional(),
                stopSequences: zod.array(zod.string()).optional(),
                cachingEnabled: zod.boolean().optional(),
                reasoningEffort: zod
                  .enum(['low', 'medium', 'high'])
                  .or(zod.null())
                  .optional(),
                extra: zod.record(zod.string(), zod.string()).optional(),
              })
              .optional(),
          }),
          stockResponses: zod
            .object({
              initialMessage: zod.string().or(zod.null()).optional(),
              maxLengthReached: zod.string().optional(),
            })
            .optional(),
          tools: zod.array(
            zod.object({
              registryId: zod.string(),
              options: zod.object({}).or(zod.null()).optional(),
            }),
          ),
          toolUseConfig: zod
            .object({
              maxSubsequentToolUses: zod.number().optional(),
              maxRetries: zod.number().optional(),
              outputFormatting: zod
                .enum(['custom', 'json', 'xml', 'yaml'])
                .optional(),
              outputMaxTokens: zod.number().optional(),
            })
            .optional(),
          createdAt: zod.string().datetime().optional(),
          updatedAt: zod.string().datetime().or(zod.null()).optional(),
          name: zod.string(),
          status: zod.enum(['active', 'inactive', 'disabled']),
          agentUuid: zod.string().uuid(),
          toolDefinitions: zod
            .array(
              zod.object({
                toolRegistryId: zod.string(),
                name: zod.string(),
                description: zod.string(),
                inputsSchema: zod.object({}),
                outputsSchema: zod.object({}),
                optionsSchema: zod.object({}).or(zod.null()).optional(),
              }),
            )
            .optional(),
          isEditable: zod.boolean().optional(),
        }),
      ),
      assets: zod
        .array(
          zod.object({
            uuid: zod.string().uuid(),
            createdAt: zod.string().datetime(),
            type: zod.enum(['audio', 'image', 'pdf', 'other', 'text', 'video']),
            name: zod.string(),
            description: zod.string().or(zod.null()).optional(),
            originalFilename: zod.string(),
            sourceUrl: zod.string().or(zod.null()).optional(),
            ingestionStatus: zod
              .enum([
                'unsupported',
                'pending',
                'parsing_error',
                'processing_error',
                'indexing_error',
                'ingested',
              ])
              .or(zod.null())
              .optional(),
            ingestionErrorLog: zod
              .object({
                createdAt: zod.string().datetime().optional(),
                requestUuid: zod.string().uuid(),
                stepName: zod.string(),
                type: zod.enum([
                  'parsing_error',
                  'file_extension_not_supported',
                  'file_not_found',
                  'file_extension_invalid',
                  'file_open_error',
                  'file_encoding_error',
                  'file_validation_error',
                  'no_content_found',
                  'processing_error',
                  'processing_timeout',
                  'indexing_error',
                ]),
                message: zod.string(),
              })
              .or(zod.null())
              .optional(),
            ingestionMetadata: zod
              .object({
                codeVersion: zod.string().optional(),
                filename: zod.string(),
                totalCostUsd: zod.number().optional(),
                requestedAt: zod.string().datetime(),
                ingestionStartedAt: zod.string().datetime().optional(),
                parsingCompletedAt: zod
                  .string()
                  .datetime()
                  .or(zod.null())
                  .optional(),
                processingCompletedAt: zod
                  .string()
                  .datetime()
                  .or(zod.null())
                  .optional(),
                indexingCompletedAt: zod
                  .string()
                  .datetime()
                  .or(zod.null())
                  .optional(),
                failedAt: zod.string().datetime().or(zod.null()).optional(),
                ingestedAt: zod.string().datetime().or(zod.null()).optional(),
              })
              .or(zod.null())
              .optional(),
            ingestionStepLogs: zod
              .array(
                zod.object({
                  stepName: zod.string(),
                  executionDetails: zod
                    .record(zod.string(), zod.string())
                    .optional(),
                  startedAt: zod.string().datetime().optional(),
                  completedAt: zod
                    .string()
                    .datetime()
                    .or(zod.null())
                    .optional(),
                  costUsd: zod.number().optional(),
                }),
              )
              .or(zod.null())
              .optional(),
            agentUuid: zod.string().uuid().or(zod.null()).optional(),
            conversationUuid: zod.string().uuid().or(zod.null()).optional(),
            messageUuid: zod.string().uuid().or(zod.null()).optional(),
            userUuid: zod.string().uuid(),
          }),
        )
        .or(zod.null())
        .optional(),
      ownerUuid: zod.string().uuid().or(zod.null()).optional(),
      ownerUsername: zod.string().or(zod.null()).optional(),
    }),
  ),
})

/**
 * @summary Create New Agent
 */
export const createNewAgentBody = zod.object({
  name: zod.string(),
  description: zod.string().or(zod.null()).optional(),
  llmModelId: zod.string(),
  baselineConfigUuid: zod.string().uuid().or(zod.null()).optional(),
})

export const createNewAgentResponse = zod.object({
  uuid: zod.string().uuid(),
  type: zod.enum(['ai', 'human']),
  name: zod.string(),
  description: zod.string().or(zod.null()).optional(),
  isPublic: zod.boolean(),
  llmModelId: zod.string(),
  activeConfig: zod.object({
    uuid: zod.string().uuid().optional(),
    version: zod.number().optional(),
    notes: zod.string().or(zod.null()).optional(),
    agentClass: zod.string(),
    reasoningDetection: zod
      .object({
        enabled: zod.boolean().optional(),
        tags: zod
          .object({
            start: zod.string(),
            stop: zod.string(),
          })
          .optional(),
      })
      .optional(),
    promptTemplate: zod.object({
      name: zod.string(),
      completionTemplate: zod.string().or(zod.null()).optional(),
      messagesTemplate: zod
        .array(
          zod.object({
            uuid: zod.string().uuid().or(zod.null()).optional(),
            createdAt: zod.string().datetime().optional(),
            type: zod.enum(['text', 'multimodal']).optional(),
            role: zod.enum(['system', 'user', 'assistant']),
            template: zod.string().optional(),
          }),
        )
        .or(zod.null())
        .optional(),
      sectionsTemplate: zod
        .array(
          zod.object({
            uuid: zod.string().uuid().or(zod.null()).optional(),
            createdAt: zod.string().datetime().optional(),
            type: zod.enum(['text', 'multimodal']).optional(),
            role: zod.enum(['system', 'user', 'assistant']),
            template: zod.string().optional(),
            id: zod
              .enum([
                'role',
                'task_instructions',
                'task_examples',
                'conversation_history_summary',
                'tool_use_instructions',
                'tool_use_output_format',
                'tool_use_output',
                'tool_use_next_step_initial',
                'tool_use_next_step_success_and_available',
                'tool_use_next_step_success_and_not_available',
                'tool_use_next_step_error_and_available',
                'tool_use_next_step_error_and_not_available',
              ])
              .or(zod.null())
              .optional(),
            title: zod.string().or(zod.null()).optional(),
          }),
        )
        .or(zod.null())
        .optional(),
      generationSettings: zod
        .object({
          maxOutputTokens: zod.number().or(zod.null()).optional(),
          temperature: zod.number().optional(),
          stopSequences: zod.array(zod.string()).optional(),
          cachingEnabled: zod.boolean().optional(),
          reasoningEffort: zod
            .enum(['low', 'medium', 'high'])
            .or(zod.null())
            .optional(),
          extra: zod.record(zod.string(), zod.string()).optional(),
        })
        .optional(),
    }),
    stockResponses: zod
      .object({
        initialMessage: zod.string().or(zod.null()).optional(),
        maxLengthReached: zod.string().optional(),
      })
      .optional(),
    tools: zod.array(
      zod.object({
        registryId: zod.string(),
        options: zod.object({}).or(zod.null()).optional(),
      }),
    ),
    toolUseConfig: zod
      .object({
        maxSubsequentToolUses: zod.number().optional(),
        maxRetries: zod.number().optional(),
        outputFormatting: zod
          .enum(['custom', 'json', 'xml', 'yaml'])
          .optional(),
        outputMaxTokens: zod.number().optional(),
      })
      .optional(),
    createdAt: zod.string().datetime().optional(),
    updatedAt: zod.string().datetime().or(zod.null()).optional(),
    name: zod.string(),
    status: zod.enum(['active', 'inactive', 'disabled']),
    agentUuid: zod.string().uuid(),
    toolDefinitions: zod
      .array(
        zod.object({
          toolRegistryId: zod.string(),
          name: zod.string(),
          description: zod.string(),
          inputsSchema: zod.object({}),
          outputsSchema: zod.object({}),
          optionsSchema: zod.object({}).or(zod.null()).optional(),
        }),
      )
      .optional(),
    isEditable: zod.boolean().optional(),
  }),
  agentConfigs: zod.array(
    zod.object({
      uuid: zod.string().uuid().optional(),
      version: zod.number().optional(),
      notes: zod.string().or(zod.null()).optional(),
      agentClass: zod.string(),
      reasoningDetection: zod
        .object({
          enabled: zod.boolean().optional(),
          tags: zod
            .object({
              start: zod.string(),
              stop: zod.string(),
            })
            .optional(),
        })
        .optional(),
      promptTemplate: zod.object({
        name: zod.string(),
        completionTemplate: zod.string().or(zod.null()).optional(),
        messagesTemplate: zod
          .array(
            zod.object({
              uuid: zod.string().uuid().or(zod.null()).optional(),
              createdAt: zod.string().datetime().optional(),
              type: zod.enum(['text', 'multimodal']).optional(),
              role: zod.enum(['system', 'user', 'assistant']),
              template: zod.string().optional(),
            }),
          )
          .or(zod.null())
          .optional(),
        sectionsTemplate: zod
          .array(
            zod.object({
              uuid: zod.string().uuid().or(zod.null()).optional(),
              createdAt: zod.string().datetime().optional(),
              type: zod.enum(['text', 'multimodal']).optional(),
              role: zod.enum(['system', 'user', 'assistant']),
              template: zod.string().optional(),
              id: zod
                .enum([
                  'role',
                  'task_instructions',
                  'task_examples',
                  'conversation_history_summary',
                  'tool_use_instructions',
                  'tool_use_output_format',
                  'tool_use_output',
                  'tool_use_next_step_initial',
                  'tool_use_next_step_success_and_available',
                  'tool_use_next_step_success_and_not_available',
                  'tool_use_next_step_error_and_available',
                  'tool_use_next_step_error_and_not_available',
                ])
                .or(zod.null())
                .optional(),
              title: zod.string().or(zod.null()).optional(),
            }),
          )
          .or(zod.null())
          .optional(),
        generationSettings: zod
          .object({
            maxOutputTokens: zod.number().or(zod.null()).optional(),
            temperature: zod.number().optional(),
            stopSequences: zod.array(zod.string()).optional(),
            cachingEnabled: zod.boolean().optional(),
            reasoningEffort: zod
              .enum(['low', 'medium', 'high'])
              .or(zod.null())
              .optional(),
            extra: zod.record(zod.string(), zod.string()).optional(),
          })
          .optional(),
      }),
      stockResponses: zod
        .object({
          initialMessage: zod.string().or(zod.null()).optional(),
          maxLengthReached: zod.string().optional(),
        })
        .optional(),
      tools: zod.array(
        zod.object({
          registryId: zod.string(),
          options: zod.object({}).or(zod.null()).optional(),
        }),
      ),
      toolUseConfig: zod
        .object({
          maxSubsequentToolUses: zod.number().optional(),
          maxRetries: zod.number().optional(),
          outputFormatting: zod
            .enum(['custom', 'json', 'xml', 'yaml'])
            .optional(),
          outputMaxTokens: zod.number().optional(),
        })
        .optional(),
      createdAt: zod.string().datetime().optional(),
      updatedAt: zod.string().datetime().or(zod.null()).optional(),
      name: zod.string(),
      status: zod.enum(['active', 'inactive', 'disabled']),
      agentUuid: zod.string().uuid(),
      toolDefinitions: zod
        .array(
          zod.object({
            toolRegistryId: zod.string(),
            name: zod.string(),
            description: zod.string(),
            inputsSchema: zod.object({}),
            outputsSchema: zod.object({}),
            optionsSchema: zod.object({}).or(zod.null()).optional(),
          }),
        )
        .optional(),
      isEditable: zod.boolean().optional(),
    }),
  ),
  assets: zod
    .array(
      zod.object({
        uuid: zod.string().uuid(),
        createdAt: zod.string().datetime(),
        type: zod.enum(['audio', 'image', 'pdf', 'other', 'text', 'video']),
        name: zod.string(),
        description: zod.string().or(zod.null()).optional(),
        originalFilename: zod.string(),
        sourceUrl: zod.string().or(zod.null()).optional(),
        ingestionStatus: zod
          .enum([
            'unsupported',
            'pending',
            'parsing_error',
            'processing_error',
            'indexing_error',
            'ingested',
          ])
          .or(zod.null())
          .optional(),
        ingestionErrorLog: zod
          .object({
            createdAt: zod.string().datetime().optional(),
            requestUuid: zod.string().uuid(),
            stepName: zod.string(),
            type: zod.enum([
              'parsing_error',
              'file_extension_not_supported',
              'file_not_found',
              'file_extension_invalid',
              'file_open_error',
              'file_encoding_error',
              'file_validation_error',
              'no_content_found',
              'processing_error',
              'processing_timeout',
              'indexing_error',
            ]),
            message: zod.string(),
          })
          .or(zod.null())
          .optional(),
        ingestionMetadata: zod
          .object({
            codeVersion: zod.string().optional(),
            filename: zod.string(),
            totalCostUsd: zod.number().optional(),
            requestedAt: zod.string().datetime(),
            ingestionStartedAt: zod.string().datetime().optional(),
            parsingCompletedAt: zod
              .string()
              .datetime()
              .or(zod.null())
              .optional(),
            processingCompletedAt: zod
              .string()
              .datetime()
              .or(zod.null())
              .optional(),
            indexingCompletedAt: zod
              .string()
              .datetime()
              .or(zod.null())
              .optional(),
            failedAt: zod.string().datetime().or(zod.null()).optional(),
            ingestedAt: zod.string().datetime().or(zod.null()).optional(),
          })
          .or(zod.null())
          .optional(),
        ingestionStepLogs: zod
          .array(
            zod.object({
              stepName: zod.string(),
              executionDetails: zod
                .record(zod.string(), zod.string())
                .optional(),
              startedAt: zod.string().datetime().optional(),
              completedAt: zod.string().datetime().or(zod.null()).optional(),
              costUsd: zod.number().optional(),
            }),
          )
          .or(zod.null())
          .optional(),
        agentUuid: zod.string().uuid().or(zod.null()).optional(),
        conversationUuid: zod.string().uuid().or(zod.null()).optional(),
        messageUuid: zod.string().uuid().or(zod.null()).optional(),
        userUuid: zod.string().uuid(),
      }),
    )
    .or(zod.null())
    .optional(),
  ownerUuid: zod.string().uuid().or(zod.null()).optional(),
  ownerUsername: zod.string().or(zod.null()).optional(),
})

/**
 * @summary Get Agent By Uuid
 */
export const getAgentByUuidParams = zod.object({
  agentUuid: zod.string().uuid(),
})

export const getAgentByUuidResponse = zod.object({
  uuid: zod.string().uuid(),
  type: zod.enum(['ai', 'human']),
  name: zod.string(),
  description: zod.string().or(zod.null()).optional(),
  isPublic: zod.boolean(),
  llmModelId: zod.string(),
  activeConfig: zod.object({
    uuid: zod.string().uuid().optional(),
    version: zod.number().optional(),
    notes: zod.string().or(zod.null()).optional(),
    agentClass: zod.string(),
    reasoningDetection: zod
      .object({
        enabled: zod.boolean().optional(),
        tags: zod
          .object({
            start: zod.string(),
            stop: zod.string(),
          })
          .optional(),
      })
      .optional(),
    promptTemplate: zod.object({
      name: zod.string(),
      completionTemplate: zod.string().or(zod.null()).optional(),
      messagesTemplate: zod
        .array(
          zod.object({
            uuid: zod.string().uuid().or(zod.null()).optional(),
            createdAt: zod.string().datetime().optional(),
            type: zod.enum(['text', 'multimodal']).optional(),
            role: zod.enum(['system', 'user', 'assistant']),
            template: zod.string().optional(),
          }),
        )
        .or(zod.null())
        .optional(),
      sectionsTemplate: zod
        .array(
          zod.object({
            uuid: zod.string().uuid().or(zod.null()).optional(),
            createdAt: zod.string().datetime().optional(),
            type: zod.enum(['text', 'multimodal']).optional(),
            role: zod.enum(['system', 'user', 'assistant']),
            template: zod.string().optional(),
            id: zod
              .enum([
                'role',
                'task_instructions',
                'task_examples',
                'conversation_history_summary',
                'tool_use_instructions',
                'tool_use_output_format',
                'tool_use_output',
                'tool_use_next_step_initial',
                'tool_use_next_step_success_and_available',
                'tool_use_next_step_success_and_not_available',
                'tool_use_next_step_error_and_available',
                'tool_use_next_step_error_and_not_available',
              ])
              .or(zod.null())
              .optional(),
            title: zod.string().or(zod.null()).optional(),
          }),
        )
        .or(zod.null())
        .optional(),
      generationSettings: zod
        .object({
          maxOutputTokens: zod.number().or(zod.null()).optional(),
          temperature: zod.number().optional(),
          stopSequences: zod.array(zod.string()).optional(),
          cachingEnabled: zod.boolean().optional(),
          reasoningEffort: zod
            .enum(['low', 'medium', 'high'])
            .or(zod.null())
            .optional(),
          extra: zod.record(zod.string(), zod.string()).optional(),
        })
        .optional(),
    }),
    stockResponses: zod
      .object({
        initialMessage: zod.string().or(zod.null()).optional(),
        maxLengthReached: zod.string().optional(),
      })
      .optional(),
    tools: zod.array(
      zod.object({
        registryId: zod.string(),
        options: zod.object({}).or(zod.null()).optional(),
      }),
    ),
    toolUseConfig: zod
      .object({
        maxSubsequentToolUses: zod.number().optional(),
        maxRetries: zod.number().optional(),
        outputFormatting: zod
          .enum(['custom', 'json', 'xml', 'yaml'])
          .optional(),
        outputMaxTokens: zod.number().optional(),
      })
      .optional(),
    createdAt: zod.string().datetime().optional(),
    updatedAt: zod.string().datetime().or(zod.null()).optional(),
    name: zod.string(),
    status: zod.enum(['active', 'inactive', 'disabled']),
    agentUuid: zod.string().uuid(),
    toolDefinitions: zod
      .array(
        zod.object({
          toolRegistryId: zod.string(),
          name: zod.string(),
          description: zod.string(),
          inputsSchema: zod.object({}),
          outputsSchema: zod.object({}),
          optionsSchema: zod.object({}).or(zod.null()).optional(),
        }),
      )
      .optional(),
    isEditable: zod.boolean().optional(),
  }),
  agentConfigs: zod.array(
    zod.object({
      uuid: zod.string().uuid().optional(),
      version: zod.number().optional(),
      notes: zod.string().or(zod.null()).optional(),
      agentClass: zod.string(),
      reasoningDetection: zod
        .object({
          enabled: zod.boolean().optional(),
          tags: zod
            .object({
              start: zod.string(),
              stop: zod.string(),
            })
            .optional(),
        })
        .optional(),
      promptTemplate: zod.object({
        name: zod.string(),
        completionTemplate: zod.string().or(zod.null()).optional(),
        messagesTemplate: zod
          .array(
            zod.object({
              uuid: zod.string().uuid().or(zod.null()).optional(),
              createdAt: zod.string().datetime().optional(),
              type: zod.enum(['text', 'multimodal']).optional(),
              role: zod.enum(['system', 'user', 'assistant']),
              template: zod.string().optional(),
            }),
          )
          .or(zod.null())
          .optional(),
        sectionsTemplate: zod
          .array(
            zod.object({
              uuid: zod.string().uuid().or(zod.null()).optional(),
              createdAt: zod.string().datetime().optional(),
              type: zod.enum(['text', 'multimodal']).optional(),
              role: zod.enum(['system', 'user', 'assistant']),
              template: zod.string().optional(),
              id: zod
                .enum([
                  'role',
                  'task_instructions',
                  'task_examples',
                  'conversation_history_summary',
                  'tool_use_instructions',
                  'tool_use_output_format',
                  'tool_use_output',
                  'tool_use_next_step_initial',
                  'tool_use_next_step_success_and_available',
                  'tool_use_next_step_success_and_not_available',
                  'tool_use_next_step_error_and_available',
                  'tool_use_next_step_error_and_not_available',
                ])
                .or(zod.null())
                .optional(),
              title: zod.string().or(zod.null()).optional(),
            }),
          )
          .or(zod.null())
          .optional(),
        generationSettings: zod
          .object({
            maxOutputTokens: zod.number().or(zod.null()).optional(),
            temperature: zod.number().optional(),
            stopSequences: zod.array(zod.string()).optional(),
            cachingEnabled: zod.boolean().optional(),
            reasoningEffort: zod
              .enum(['low', 'medium', 'high'])
              .or(zod.null())
              .optional(),
            extra: zod.record(zod.string(), zod.string()).optional(),
          })
          .optional(),
      }),
      stockResponses: zod
        .object({
          initialMessage: zod.string().or(zod.null()).optional(),
          maxLengthReached: zod.string().optional(),
        })
        .optional(),
      tools: zod.array(
        zod.object({
          registryId: zod.string(),
          options: zod.object({}).or(zod.null()).optional(),
        }),
      ),
      toolUseConfig: zod
        .object({
          maxSubsequentToolUses: zod.number().optional(),
          maxRetries: zod.number().optional(),
          outputFormatting: zod
            .enum(['custom', 'json', 'xml', 'yaml'])
            .optional(),
          outputMaxTokens: zod.number().optional(),
        })
        .optional(),
      createdAt: zod.string().datetime().optional(),
      updatedAt: zod.string().datetime().or(zod.null()).optional(),
      name: zod.string(),
      status: zod.enum(['active', 'inactive', 'disabled']),
      agentUuid: zod.string().uuid(),
      toolDefinitions: zod
        .array(
          zod.object({
            toolRegistryId: zod.string(),
            name: zod.string(),
            description: zod.string(),
            inputsSchema: zod.object({}),
            outputsSchema: zod.object({}),
            optionsSchema: zod.object({}).or(zod.null()).optional(),
          }),
        )
        .optional(),
      isEditable: zod.boolean().optional(),
    }),
  ),
  assets: zod
    .array(
      zod.object({
        uuid: zod.string().uuid(),
        createdAt: zod.string().datetime(),
        type: zod.enum(['audio', 'image', 'pdf', 'other', 'text', 'video']),
        name: zod.string(),
        description: zod.string().or(zod.null()).optional(),
        originalFilename: zod.string(),
        sourceUrl: zod.string().or(zod.null()).optional(),
        ingestionStatus: zod
          .enum([
            'unsupported',
            'pending',
            'parsing_error',
            'processing_error',
            'indexing_error',
            'ingested',
          ])
          .or(zod.null())
          .optional(),
        ingestionErrorLog: zod
          .object({
            createdAt: zod.string().datetime().optional(),
            requestUuid: zod.string().uuid(),
            stepName: zod.string(),
            type: zod.enum([
              'parsing_error',
              'file_extension_not_supported',
              'file_not_found',
              'file_extension_invalid',
              'file_open_error',
              'file_encoding_error',
              'file_validation_error',
              'no_content_found',
              'processing_error',
              'processing_timeout',
              'indexing_error',
            ]),
            message: zod.string(),
          })
          .or(zod.null())
          .optional(),
        ingestionMetadata: zod
          .object({
            codeVersion: zod.string().optional(),
            filename: zod.string(),
            totalCostUsd: zod.number().optional(),

... [file truncated after 1000 lines] ...

--- Start of frontend/src/api/mutator/custom-form-url-encoded.ts ---

export function customFormUrlEncoded<Body>(
  body: Body extends object ? Body : never,
): FormData {
  const formData = new FormData()

  Object.entries(body).forEach(([key, value]) => {
    if (value != null) {
      formData.append(key, value)
    }
  })

  return formData
}

export default customFormUrlEncoded


--- Start of frontend/src/api/mutator/custom-instance.ts ---

import Axios, { type AxiosError, type AxiosRequestConfig } from 'axios'

import { apiBase } from '@/api/api-base'

export function customInstance<T>(
  config: AxiosRequestConfig,
  options?: AxiosRequestConfig,
): Promise<T> {
  if (
    config.headers &&
    config.headers['Content-Type'] === 'multipart/form-data'
  ) {
    config.transformRequest = [
      () => {
        return config.data
      },
    ]
  }
  const source = Axios.CancelToken.source()
  const promise = apiBase({
    ...config,
    ...options,
    cancelToken: source.token,
  }).then(({ data }) => data)

  // @ts-expect-error - This is a custom property
  promise.cancel = () => {
    source.cancel('Query was cancelled')
  }

  return promise
}
export interface ErrorType<Error> extends AxiosError<Error> {}


--- Start of frontend/src/api/mutator/custom-form-data.ts ---

export function customFormData<Body extends object>(body: Body): FormData {
  const formData = new FormData()

  Object.entries(body).forEach(([key, value]) => {
    if (key === 'files' && Array.isArray(value)) {
      // Append each file in the 'files' array correctly
      value.forEach((file) => {
        if (file instanceof File || file instanceof Blob) {
          formData.append(key, file) // Append files without array index
        }
      })
    } else if (value instanceof File || value instanceof Blob) {
      // For single File or Blob fields
      formData.append(key, value)
    } else {
      // For all other fields, append as strings
      formData.append(key, String(value))
    }
  })

  return formData
}


--- Start of frontend/src/api/custom/schema.ts ---

import { z } from 'zod'

import { registerUserBody } from '@/api/schemas/zod'

// Add any custom schemas here.

export const loginUserBody = z.object({
  username: z
    .string()
    .email('Invalid email address')
    .refine(
      (value) => value.includes('@tribe.ai'),
      'Invalid email address, must be a tribe.ai email',
    ),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/\d/, 'Password must contain at least one number'),
})

export const extendedRegisterUserBody = registerUserBody
  .pick({ username: true, email: true, password: true })
  .merge(
    z.object({
      confirmPassword: z.string(),
    }),
  )
  .refine((data) => data.password === data.confirmPassword, {
    message: 'Passwords do not match',
    path: ['confirmPassword'],
  })


--- Start of frontend/src/api/custom/api.ts ---

import { useCallback, useRef } from 'react'
import { useMutation, type UseMutationOptions } from '@tanstack/react-query'

import { fetchWithSSE } from '@/api/api-sse-base'
import type {
  MessageCreate,
  MessageReadResponse,
  MessageUpdate,
  PatchUserMessageStreamingParams,
  RegenerateAgentMessageParams,
  SendMessageAndReceiveGeneratedResponseParams,
} from '@/api/models'

// Common hook to handle abort controller setup and stream stopping logic
export function useAbortController() {
  const abortController = useRef(new AbortController())

  const handleStopStream = useCallback(() => {
    abortController.current.abort()
    abortController.current = new AbortController()
  }, [abortController])

  return { abortController: abortController.current, handleStopStream }
}

export type SSEMutationOptions<Params, Data = unknown> = {
  method: 'POST' | 'PATCH' | 'GET' | 'DELETE' | 'PUT'
  abortController: AbortController
} & Omit<
  UseMutationOptions<void, unknown, SSEMutationVariables<Params, Data>, any>,
  'mutationFn'
>

export interface SSEMutationVariables<Params, Data> {
  params: Params
  data?: Data
}

/*
 * Wraps the fetchWithSSE function to provide a mutation function that sends a message and receives a generated SSE response.
 * fetchWithSSE returns a promise which plays nicely with react-query. The only difference is that the fetchWithSSE function is a streaming request
 * and so the data comes through the onSSEMessage callback. The wrapper exposes the onSSEMessage callback to the caller.
 *
 * Here is the fetchWithSSE callback order and React Query mutation's corresponding states (idle, isPending, isError, isSuccess):
 * 1. onSSEOpen (mutation isPending)
 * 2. onSSEMessage (mutation isPending)
 * 3. onSSEClose (mutation isSuccess or isError)
 * 4. onSSEError (mutation isError)
 */
export function useSSEMutation<Response, Params, Data = unknown>(
  options: SSEMutationOptions<Params, Data>,
) {
  const { method, abortController, ...mutationOptions } = options
  return useMutation({
    ...mutationOptions,
    mutationKey: options.mutationKey,
    mutationFn: async ({
      url,
      params,
      data,
      onSSEOpen,
      onSSEClose,
      onSSEMessage,
      onSSEError,
    }: {
      url:
        | '/api/message/streaming'
        | '/api/message/regenerate/streaming'
        | `/api/message/${string}/streaming`
      params: Params
      onSSEMessage?: ({ data }: { data: Response }) => void
      onSSEOpen?: () => void
      onSSEClose?: () => void
      onSSEError?: (error: Error) => void
      data?: Data
    }) => {
      return fetchWithSSE<Response, Params>({
        method,
        url,
        onSSEMessage({ data }) {
          onSSEMessage?.({ data })
        },
        onSSEOpen: () => {
          onSSEOpen?.()
        },
        onSSEClose: () => {
          onSSEClose?.()
        },
        onSSEError(error) {
          onSSEError?.(error)
        },
        body: data,
        params,
        signal: abortController.signal,
      })
    },
  })
}

export function useSendMessageAndReceiveStreamedResponse(
  abortController: AbortController,
  options?: Omit<
    SSEMutationOptions<
      SendMessageAndReceiveGeneratedResponseParams,
      MessageCreate
    >,
    'url' | 'method' | 'abortController'
  >,
) {
  return useSSEMutation<
    MessageReadResponse,
    SendMessageAndReceiveGeneratedResponseParams,
    MessageCreate
  >({
    mutationKey: ['/api/message/streaming'],
    method: 'POST',
    abortController,
    ...options,
  })
}

export function useRegenerateMessage(
  abortController: AbortController,
  options?: Omit<
    SSEMutationOptions<RegenerateAgentMessageParams, unknown>,
    'url' | 'method' | 'abortController'
  >,
) {
  return useSSEMutation<MessageReadResponse, RegenerateAgentMessageParams>({
    mutationKey: ['/api/message/regenerate/streaming'],
    method: 'GET',
    abortController,
    ...options,
  })
}

export function usePatchUserMessage(
  abortController: AbortController,
  options?: Omit<
    SSEMutationOptions<PatchUserMessageStreamingParams, MessageUpdate>,
    'method' | 'abortController' | ''
  >,
) {
  return useSSEMutation<
    MessageReadResponse,
    PatchUserMessageStreamingParams,
    MessageUpdate
  >({
    mutationKey: ['/api/message/:messageUuid/streaming'],
    method: 'PATCH',
    abortController,
    ...options,
  })
}


--- Start of frontend/src/api/services/api.ts ---

/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Tribe AI Chat
 * A basic chatbot. If using the Swagger UI, authenticate by using the /api/auth/login endpoint (not the auth button), using valid credentials and using the email in the 'username' field. This will set the cookie in your browser, which will be sent in all subsequent requests. To remove the cookie, call the /api/auth/logout endpoint.
 * OpenAPI spec version: 0.20.0-rc.2
 */
import type {
  AgentConfigCreate,
  AgentConfigCreateFromExisting,
  AgentConfigReadResponse,
  AgentConfigsListResponse,
  AgentCreate,
  AgentReadResponse,
  AgentsListResponse,
  AgentUpdate,
  AssetReadResponse,
  AssetsCreateResponse,
  AssetsListResponse,
  AuditLogsListResponse,
  AvailableResponse,
  BodyCreateAssetsApiAssetPost,
  BodyLoginApiAuthLoginPost,
  BodyRunToolApiToolToolRegistryIdPost,
  CheckUsernameAvailableParams,
  ConversationHistoryResponse,
  ConversationListResponse,
  ConversationPatchRequest,
  ConversationReadResponse,
  ConversationStarterListResponse,
  CreateAssetsParams,
  DeleteQueryFromSearchHistoryParams,
  FeedbackCreate,
  FeedbackResponse,
  GetAllAssetsParams,
  GetAllAuditLogsParams,
  GetAvailableLlmInfosParams,
  GetConversationStartersParams,
  GetSearchHistoryParams,
  GetSupportedExtensionsParams,
  HTTPValidationError,
  LLMInfo,
  LLMInfoListResponse,
  MessageCreate,
  MessageReadResponse,
  MessageUpdate,
  PatchUserMessageParams,
  PatchUserMessageStreamingParams,
  PatchUserRequest,
  RebuildSearchIndicesParams,
  RegenerateAgentMessageParams,
  RegenerateAgentMessageStreamingParams,
  RunTool200,
  RunToolParams,
  SearchHistoryResponse,
  SearchRequest,
  SearchResultsResponse,
  SendMessageAndReceiveGeneratedAgentResponseStreamingParams,
  SendMessageAndReceiveGeneratedResponseParams,
  SupportedFileExtensionsResponse,
  ToolReadResponse,
  ToolsListResponse,
  UserProfile,
  UserRegistrationRequest,
} from '../models'
import { customFormData } from '../mutator/custom-form-data'
import { customFormUrlEncoded } from '../mutator/custom-form-url-encoded'
import { customInstance, type ErrorType } from '../mutator/custom-instance'
import {
  useMutation,
  useQuery,
  type DataTag,
  type DefinedInitialDataOptions,
  type DefinedUseQueryResult,
  type MutationFunction,
  type QueryFunction,
  type QueryKey,
  type UndefinedInitialDataOptions,
  type UseMutationOptions,
  type UseMutationResult,
  type UseQueryOptions,
  type UseQueryResult,
} from '@tanstack/react-query'

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * @summary Get All Agents
 */
export const getAllAgents = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentsListResponse>(
    { url: `/api/agent`, method: 'GET', signal },
    options,
  )
}

export const getGetAllAgentsQueryKey = () => {
  return [`/api/agent`] as const
}

export const getGetAllAgentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllAgents>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAgents>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllAgentsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAgents>>> = ({
    signal,
  }) => getAllAgents(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllAgents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAllAgentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllAgents>>
>
export type GetAllAgentsQueryError = ErrorType<unknown>

export function useGetAllAgents<
  TData = Awaited<ReturnType<typeof getAllAgents>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAgents>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getAllAgents>>,
        TError,
        TData
      >,
      'initialData'
    >
  request?: SecondParameter<typeof customInstance>
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>
}
export function useGetAllAgents<
  TData = Awaited<ReturnType<typeof getAllAgents>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAgents>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getAllAgents>>,
        TError,
        TData
      >,
      'initialData'
    >
  request?: SecondParameter<typeof customInstance>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllAgents<
  TData = Awaited<ReturnType<typeof getAllAgents>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAgents>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get All Agents
 */

export function useGetAllAgents<
  TData = Awaited<ReturnType<typeof getAllAgents>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAgents>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllAgentsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create New Agent
 */
export const createNewAgent = (
  agentCreate: AgentCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentReadResponse>(
    {
      url: `/api/agent`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: agentCreate,
      signal,
    },
    options,
  )
}

export const getCreateNewAgentMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNewAgent>>,
    TError,
    { data: AgentCreate },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNewAgent>>,
  TError,
  { data: AgentCreate },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNewAgent>>,
    { data: AgentCreate }
  > = (props) => {
    const { data } = props ?? {}

    return createNewAgent(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateNewAgentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNewAgent>>
>
export type CreateNewAgentMutationBody = AgentCreate
export type CreateNewAgentMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Create New Agent
 */
export const useCreateNewAgent = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNewAgent>>,
    TError,
    { data: AgentCreate },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createNewAgent>>,
  TError,
  { data: AgentCreate },
  TContext
> => {
  const mutationOptions = getCreateNewAgentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get Agent By Uuid
 */
export const getAgentByUuid = (
  agentUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentReadResponse>(
    { url: `/api/agent/${agentUuid}`, method: 'GET', signal },
    options,
  )
}

export const getGetAgentByUuidQueryKey = (agentUuid: string) => {
  return [`/api/agent/${agentUuid}`] as const
}

export const getGetAgentByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof getAgentByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAgentByUuid>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAgentByUuidQueryKey(agentUuid)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgentByUuid>>> = ({
    signal,
  }) => getAgentByUuid(agentUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!agentUuid,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAgentByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgentByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAgentByUuid>>
>
export type GetAgentByUuidQueryError = ErrorType<HTTPValidationError>

export function useGetAgentByUuid<
  TData = Awaited<ReturnType<typeof getAgentByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAgentByUuid>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentByUuid>>,
          TError,
          TData
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgentByUuid<
  TData = Awaited<ReturnType<typeof getAgentByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAgentByUuid>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentByUuid>>,
          TError,
          TData
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgentByUuid<
  TData = Awaited<ReturnType<typeof getAgentByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAgentByUuid>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Agent By Uuid
 */

export function useGetAgentByUuid<
  TData = Awaited<ReturnType<typeof getAgentByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAgentByUuid>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAgentByUuidQueryOptions(agentUuid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Rate limited to 6/minute to prevent abuse
 * @summary Update Agent By Uuid
 */
export const updateAgentByUuid = (
  agentUuid: string,
  agentUpdate: AgentUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AgentReadResponse>(
    {
      url: `/api/agent/${agentUuid}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: agentUpdate,
    },
    options,
  )
}

export const getUpdateAgentByUuidMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAgentByUuid>>,
    TError,
    { agentUuid: string; data: AgentUpdate },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAgentByUuid>>,
  TError,
  { agentUuid: string; data: AgentUpdate },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAgentByUuid>>,
    { agentUuid: string; data: AgentUpdate }
  > = (props) => {
    const { agentUuid, data } = props ?? {}

    return updateAgentByUuid(agentUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateAgentByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAgentByUuid>>
>
export type UpdateAgentByUuidMutationBody = AgentUpdate
export type UpdateAgentByUuidMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Update Agent By Uuid
 */
export const useUpdateAgentByUuid = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAgentByUuid>>,
    TError,
    { agentUuid: string; data: AgentUpdate },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateAgentByUuid>>,
  TError,
  { agentUuid: string; data: AgentUpdate },
  TContext
> => {
  const mutationOptions = getUpdateAgentByUuidMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Rate limited to 6/minute to prevent abuse
 * @summary Delete Agent By Uuid
 */
export const deleteAgentByUuid = (
  agentUuid: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<unknown>(
    { url: `/api/agent/${agentUuid}`, method: 'DELETE' },
    options,
  )
}

export const getDeleteAgentByUuidMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAgentByUuid>>,
    TError,
    { agentUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAgentByUuid>>,
  TError,
  { agentUuid: string },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAgentByUuid>>,
    { agentUuid: string }
  > = (props) => {
    const { agentUuid } = props ?? {}

    return deleteAgentByUuid(agentUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteAgentByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAgentByUuid>>
>

export type DeleteAgentByUuidMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Delete Agent By Uuid
 */
export const useDeleteAgentByUuid = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAgentByUuid>>,
    TError,
    { agentUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteAgentByUuid>>,
  TError,
  { agentUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteAgentByUuidMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Rate limited to 6/minute to prevent abuse
 * @summary Create Agent From Existing
 */
export const createAgentFromExisting = (
  agentUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentReadResponse>(
    { url: `/api/agent/${agentUuid}/clone`, method: 'POST', signal },
    options,
  )
}

export const getCreateAgentFromExistingMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAgentFromExisting>>,
    TError,
    { agentUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAgentFromExisting>>,
  TError,
  { agentUuid: string },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAgentFromExisting>>,
    { agentUuid: string }
  > = (props) => {
    const { agentUuid } = props ?? {}

    return createAgentFromExisting(agentUuid, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateAgentFromExistingMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAgentFromExisting>>
>

export type CreateAgentFromExistingMutationError =
  ErrorType<HTTPValidationError>

/**
 * @summary Create Agent From Existing
 */
export const useCreateAgentFromExisting = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAgentFromExisting>>,
    TError,
    { agentUuid: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createAgentFromExisting>>,
  TError,
  { agentUuid: string },
  TContext
> => {
  const mutationOptions = getCreateAgentFromExistingMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get All Agent Configs
 */
export const getAllAgentConfigs = (
  agentUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentConfigsListResponse>(
    { url: `/api/agent/${agentUuid}/config`, method: 'GET', signal },
    options,
  )
}

export const getGetAllAgentConfigsQueryKey = (agentUuid: string) => {
  return [`/api/agent/${agentUuid}/config`] as const
}

export const getGetAllAgentConfigsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllAgentConfigs>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAgentConfigs>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllAgentConfigsQueryKey(agentUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllAgentConfigs>>
  > = ({ signal }) => getAllAgentConfigs(agentUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!agentUuid,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllAgentConfigs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAllAgentConfigsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllAgentConfigs>>
>
export type GetAllAgentConfigsQueryError = ErrorType<HTTPValidationError>

export function useGetAllAgentConfigs<
  TData = Awaited<ReturnType<typeof getAllAgentConfigs>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAgentConfigs>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAgentConfigs>>,
          TError,
          TData
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllAgentConfigs<
  TData = Awaited<ReturnType<typeof getAllAgentConfigs>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAgentConfigs>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAgentConfigs>>,
          TError,
          TData
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllAgentConfigs<
  TData = Awaited<ReturnType<typeof getAllAgentConfigs>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAgentConfigs>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get All Agent Configs
 */

export function useGetAllAgentConfigs<
  TData = Awaited<ReturnType<typeof getAllAgentConfigs>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAgentConfigs>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllAgentConfigsQueryOptions(agentUuid, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Rate limited to 6/minute to prevent abuse
 * @summary Create Agent Config
 */
export const createAgentConfig = (
  agentUuid: string,
  agentConfigCreate: AgentConfigCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentConfigReadResponse>(
    {
      url: `/api/agent/${agentUuid}/config`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: agentConfigCreate,
      signal,
    },
    options,
  )
}

export const getCreateAgentConfigMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAgentConfig>>,
    TError,
    { agentUuid: string; data: AgentConfigCreate },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAgentConfig>>,
  TError,
  { agentUuid: string; data: AgentConfigCreate },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAgentConfig>>,
    { agentUuid: string; data: AgentConfigCreate }
  > = (props) => {
    const { agentUuid, data } = props ?? {}

    return createAgentConfig(agentUuid, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateAgentConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAgentConfig>>
>
export type CreateAgentConfigMutationBody = AgentConfigCreate
export type CreateAgentConfigMutationError = ErrorType<HTTPValidationError>

/**
 * @summary Create Agent Config
 */
export const useCreateAgentConfig = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAgentConfig>>,
    TError,
    { agentUuid: string; data: AgentConfigCreate },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createAgentConfig>>,
  TError,
  { agentUuid: string; data: AgentConfigCreate },
  TContext
> => {
  const mutationOptions = getCreateAgentConfigMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get Agent Config By Uuid
 */
export const getAgentConfigByUuid = (
  agentUuid: string,
  configUuid: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AgentConfigReadResponse>(
    {
      url: `/api/agent/${agentUuid}/config/${configUuid}`,
      method: 'GET',
      signal,
    },
    options,
  )
}

export const getGetAgentConfigByUuidQueryKey = (
  agentUuid: string,
  configUuid: string,
) => {
  return [`/api/agent/${agentUuid}/config/${configUuid}`] as const
}

export const getGetAgentConfigByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof getAgentConfigByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  configUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentConfigByUuid>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetAgentConfigByUuidQueryKey(agentUuid, configUuid)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAgentConfigByUuid>>
  > = ({ signal }) =>
    getAgentConfigByUuid(agentUuid, configUuid, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!(agentUuid && configUuid),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAgentConfigByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgentConfigByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAgentConfigByUuid>>
>
export type GetAgentConfigByUuidQueryError = ErrorType<HTTPValidationError>

export function useGetAgentConfigByUuid<
  TData = Awaited<ReturnType<typeof getAgentConfigByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  configUuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentConfigByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentConfigByUuid>>,
          TError,
          TData
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgentConfigByUuid<
  TData = Awaited<ReturnType<typeof getAgentConfigByUuid>>,
  TError = ErrorType<HTTPValidationError>,
>(
  agentUuid: string,
  configUuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentConfigByUuid>>,
        TError,

... [file truncated after 1000 lines] ...

--- Start of frontend/src/pages/login.tsx ---

import { useState } from 'react'
import { Helmet } from 'react-helmet-async'
import { FormProvider, useForm } from 'react-hook-form'
import { useTranslation } from 'react-i18next'
import { useNavigate, useSearchParams } from 'react-router-dom'
import { zodResolver } from '@hookform/resolvers/zod'
import { usePostHog } from 'posthog-js/react'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Divider from '@mui/joy/Divider'
import IconButton from '@mui/joy/IconButton'
import type { InputProps } from '@mui/joy/Input'
import Link from '@mui/joy/Link'
import Typography from '@mui/joy/Typography'

import { useAppConfiguration } from '@/shared/configuration'
import { useResponsiveAppMode } from '@/shared/configuration/hooks'
import { loginUserBody } from '@/api/custom/schema'
import type { BodyLoginApiAuthLoginPost } from '@/api/models'
import { useLogin, type LoginMutationBody } from '@/api/services/api'
import { ErrorMessage, FormWrapper, Icon } from '@/components/common'
import { LoginWithGoogleButton, UserInput } from '@/components/interactive'

const fallback = '/'

interface LoginField {
  type: string
  inputId: 'username' | 'password'
  customProps?: InputProps
  i18nId: {
    label: string
    helperText?: string
  }
  withTooltip?: boolean
}

function useGetInputFields(): LoginField[] {
  const [showPassword, setShowPassword] = useState(false)

  return [
    {
      type: 'email',
      inputId: 'username',
      i18nId: {
        label: 'login.form.email.label',
        helperText: 'login.form.email.helperText',
      },
      customProps: {
        autoComplete: 'email',
        autoFocus: true,
      },
    },
    {
      type: showPassword ? 'text' : 'password',
      inputId: 'password',
      i18nId: {
        label: 'login.form.password.label',
        helperText: 'login.form.password.helperText',
      },
      customProps: {
        autoComplete: 'current-password',
        endDecorator: (
          <IconButton onClick={() => setShowPassword(!showPassword)} size="sm">
            <Icon
              size={16}
              color="neutral"
              name={showPassword ? 'eyeOff' : 'eye'}
            />
          </IconButton>
        ),
      },
    },
  ]
}

type FormValue = Pick<LoginMutationBody, 'password' | 'username'>

export function LoginPage() {
  const { t } = useTranslation()
  const [searchParams] = useSearchParams()
  const navigate = useNavigate()
  const posthog = usePostHog()
  const inputFields = useGetInputFields()
  const { enableSSOAuthentication } = useAppConfiguration()
  const { mutate: login, isPending, error, isError } = useLogin()

  const { responsiveAppMode } = useResponsiveAppMode()

  const form = useForm<BodyLoginApiAuthLoginPost>({
    resolver: zodResolver(loginUserBody),
  })
  const { handleSubmit } = form

  const handleLogin = async (data: BodyLoginApiAuthLoginPost) => {
    await login(
      {
        data,
      },
      {
        onSuccess: () => {
          posthog.identify(data?.username)
          const redirect = searchParams.get('redirect') || fallback
          navigate(redirect)
        },
      },
    )
  }

  return (
    <>
      <Helmet>
        <title>{`${t('login.metaTitle')} | ${t('app.name')}`}</title>
        <meta name="description" content={t('login.metaDescription')} />
      </Helmet>
      <FormProvider {...form}>
        <FormWrapper
          onSubmit={handleSubmit(handleLogin)}
          height={responsiveAppMode === 'widget' ? '100%' : 'auto'}
        >
          <Box
            display="flex"
            flexDirection="column"
            gap={2}
            justifyContent="center"
            alignItems="center"
            width={1}
          >
            <Typography level="h2">{t('login.form.title')}</Typography>
            <Divider />
          </Box>

          <Box
            display="flex"
            flexDirection="column"
            gap={4}
            justifyContent="space-between"
            width={1}
          >
            {isError && <ErrorMessage error={error as any} />}

            {enableSSOAuthentication && (
              <>
                <Box display="flex" flexDirection="column" gap={2} width={1}>
                  <LoginWithGoogleButton />
                </Box>

                <Divider sx={{ '--Divider-childPosition': `50%` }}>
                  <Typography level="body-xs" color="neutral">
                    Or
                  </Typography>
                </Divider>
              </>
            )}

            <Box display="flex" flexDirection="column" gap={2}>
              <Box display="flex" flexDirection="column" gap={2}>
                {inputFields?.map(({ type, inputId, customProps, i18nId }) => (
                  <UserInput<FormValue>
                    key={inputId}
                    type={type}
                    inputId={inputId}
                    customProps={customProps}
                    i18nId={i18nId}
                  />
                ))}
              </Box>
            </Box>

            <Button
              id="submit"
              type="submit"
              variant="solid"
              color="primary"
              loading={isPending}
            >
              {t('login.form.submit')}
            </Button>

            <Box
              display="flex"
              gap={0.5}
              justifyContent="center"
              alignItems="center"
            >
              <Typography level="body-xs" color="neutral">
                {t('login.form.dontHaveAccountLabel')}
              </Typography>
              <Link level="body-xs" onClick={() => navigate('/register')}>
                {t('login.form.registerButtonLabel')}
              </Link>
            </Box>
          </Box>
        </FormWrapper>
      </FormProvider>
    </>
  )
}


--- Start of frontend/src/pages/home.tsx ---

import { lazy, useState } from 'react'
import { Helmet } from 'react-helmet-async'
import { useTranslation } from 'react-i18next'

import { useResponsiveAppMode } from '@/shared/configuration/hooks'
import {
  useGetAgentByUuid,
  useGetAvailableLlmInfos,
  useGetUserProfile,
} from '@/api/services/api'
import { AgentInitialMessage } from '@/features/agent/components/AgentInitialMessage'
import {
  ConversationStarters,
  HomeTextarea,
  HomeTopbar,
  IntroductoryNotification,
  IntroductoryText,
} from '@/features/home/components'
import { Container, Main, ScrollContainer } from '@/components/layout'

const MobileBottomNavigation = lazy(() =>
  import('@/components/layout/MobileBottomNavigation').then((module) => ({
    default: module.MobileBottomNavigation,
  })),
)

export function HomePage() {
  const { t } = useTranslation()
  const { isSmallScreen } = useResponsiveAppMode()

  // To save a trip to the server, we generate a UUID on the frontend
  const [frontendGeneratedConversationUuid] = useState(() =>
    crypto.randomUUID(),
  )

  const { data: availableLlms } = useGetAvailableLlmInfos()
  const { data: userProfile, isLoading: userProfileIsLoading } =
    useGetUserProfile({
      query: {
        staleTime: 1000 * 60 * 60 * 24,
      },
    })
  const agentUuid = userProfile?.defaultConversationSettings?.agentUuid

  const { data: activeAgent } = useGetAgentByUuid(agentUuid as string, {
    query: {
      enabled: !!agentUuid,
      staleTime: 1000 * 60 * 60 * 24,
    },
  })
  const currentAgentConfig = activeAgent?.agentConfigs?.find(
    (config) => config.status === 'active',
  )
  const initialMessage = currentAgentConfig?.stockResponses?.initialMessage
  const hasInitialMessage = initialMessage != null && initialMessage !== ''
  const llmInfo = availableLlms?.items?.find(
    (llm) => llm.llmModelId === activeAgent?.llmModelId,
  )

  return (
    <>
      <Helmet>
        <title>{`${t('home.title')} | ${t('app.name')}`}</title>
        <meta name="description" content={t('home.metaDescription')} />
      </Helmet>
      <HomeTopbar />
      <Main>
        <ScrollContainer>
          <Container
            sx={{
              gap: isSmallScreen ? 2 : 4,
              justifyContent: isSmallScreen ? 'start' : 'center',
              pb: isSmallScreen ? 2 : 0,
            }}
          >
            {hasInitialMessage ?
              <AgentInitialMessage
                initialMessage={initialMessage}
                llmInfo={llmInfo}
                activeAgent={activeAgent}
              />
            : <>
                <IntroductoryNotification />
                <IntroductoryText
                  username={userProfile?.username}
                  isLoading={userProfileIsLoading}
                />
                <ConversationStarters
                  conversationUuid={frontendGeneratedConversationUuid}
                />
              </>
            }
          </Container>
        </ScrollContainer>
        <Container>
          <HomeTextarea conversationUuid={frontendGeneratedConversationUuid} />
        </Container>
        <MobileBottomNavigation />
      </Main>
    </>
  )
}


--- Start of frontend/src/pages/conversations.tsx ---

import { lazy } from 'react'
import { Helmet } from 'react-helmet-async'
import { useTranslation } from 'react-i18next'

import IconButton from '@mui/joy/IconButton'
import Tooltip from '@mui/joy/Tooltip'

import { AgentSelectionDropdown } from '@/features/agent/components/AgentSelectionDropdown'
import { useAgentStore } from '@/features/agent/store'
import { ConversationTable } from '@/features/conversation/components/ConversationTable'
import { Icon } from '@/components/common'
import { Container, ScrollContainer, TopNavigation } from '@/components/layout'
import { Main } from '@/components/layout/Main'

const MobileBottomNavigation = lazy(() =>
  import('@/components/layout/MobileBottomNavigation').then((module) => ({
    default: module.MobileBottomNavigation,
  })),
)

export function ConversationsPage() {
  const { t } = useTranslation()
  const {
    setAgentConfigurationSidePanelOpen,
    agentConfigurationSidePanelOpen,
  } = useAgentStore()

  return (
    <>
      <Helmet>
        <title>{`${t('conversations.title')} | ${t('app.name')}`}</title>
        <meta name="description" content={t('conversations.metaDescription')} />
      </Helmet>
      <TopNavigation justifyContent="space-between">
        <AgentSelectionDropdown />
        <Tooltip title="Configuration" arrow variant="soft">
          <IconButton
            size="sm"
            onClick={() =>
              setAgentConfigurationSidePanelOpen({
                open: !agentConfigurationSidePanelOpen,
              })
            }
          >
            <Icon name="config" />
          </IconButton>
        </Tooltip>
      </TopNavigation>
      <Main>
        <ScrollContainer>
          <Container maxWidth="md" sx={{ mb: 2 }}>
            <ConversationTable />
          </Container>
        </ScrollContainer>
        <MobileBottomNavigation />
      </Main>
    </>
  )
}


--- Start of frontend/src/pages/register.tsx ---

import { Helmet } from 'react-helmet-async'
import { FormProvider, useForm } from 'react-hook-form'
import { useTranslation } from 'react-i18next'
import { useNavigate } from 'react-router-dom'
import { zodResolver } from '@hookform/resolvers/zod'

import Box from '@mui/joy/Box'
import Button from '@mui/joy/Button'
import Divider from '@mui/joy/Divider'
import type { InputProps } from '@mui/joy/Input'
import Link from '@mui/joy/Link'
import Tooltip, { type TooltipProps } from '@mui/joy/Tooltip'
import Typography from '@mui/joy/Typography'

import {
  useAppConfiguration,
  useResponsiveAppMode,
} from '@/shared/configuration'
import { extendedRegisterUserBody } from '@/api/custom/schema'
import {
  useRegisterUser,
  type RegisterUserMutationBody,
} from '@/api/services/api'
import { ErrorMessage, FormWrapper } from '@/components/common'
import { LoginWithGoogleButton, UserInput } from '@/components/interactive'

const inputFields: RegisterField[] = [
  {
    type: 'username',
    inputId: 'username',
    i18nId: {
      label: 'register.form.username.label',
      helperText: 'register.form.username.helperText',
    },
    withTooltip: true,
    customProps: {
      autoComplete: 'username',
      autoFocus: true,
    },
  },
  {
    type: 'email',
    inputId: 'email',
    i18nId: {
      label: 'register.form.email.label',
      helperText: 'register.form.email.helperText',
    },
    withTooltip: true,
    customProps: {
      autoComplete: 'email',
    },
  },
  {
    type: 'password',
    inputId: 'password',
    i18nId: {
      label: 'register.form.password.label',
      helperText: 'register.form.password.helperText',
    },
    withTooltip: true,
    customProps: {
      autoComplete: 'new-password',
    },
  },
  {
    type: 'password',
    inputId: 'confirmPassword',
    i18nId: {
      label: 'register.form.confirmPassword.label',
    },
    customProps: {
      autoComplete: 'new-password',
    },
  },
]
interface RegisterField {
  type: string
  inputId: 'username' | 'email' | 'password' | 'confirmPassword'
  customProps?: InputProps
  withTooltip?: boolean
  i18nId: {
    label: string
    helperText?: string
  }
}
type FormValue = RegisterUserMutationBody & { confirmPassword: string }

export function RegisterPage() {
  const { t } = useTranslation()
  const navigate = useNavigate()
  const { enableSSOAuthentication } = useAppConfiguration()
  const { responsiveAppMode } = useResponsiveAppMode()
  const {
    mutate: registerUser,
    isPending: registerUserIsPending,
    isError: registerUserIsError,
    error: registerUserError,
  } = useRegisterUser()

  const form = useForm<RegisterUserMutationBody & { confirmPassword: string }>({
    resolver: zodResolver(extendedRegisterUserBody),
  })

  const handleMutation = async (data: RegisterUserMutationBody) => {
    await registerUser(
      { data },
      {
        onSuccess() {
          navigate('/login')
        },
      },
    )
  }

  return (
    <>
      <Helmet>
        <title>{`${t('register.metaTitle')} | ${t('app.name')}`}</title>
        <meta name="description" content={t('register.metaDescription')} />
      </Helmet>

      <FormProvider {...form}>
        <FormWrapper
          onSubmit={form?.handleSubmit(handleMutation)}
          height={responsiveAppMode === 'widget' ? '100%' : 'auto'}
        >
          <Box
            display="flex"
            flexDirection="column"
            gap={2}
            justifyContent="center"
            alignItems="center"
            width={1}
          >
            <Typography level="h2">{t('register.form.title')}</Typography>
            <Divider />
          </Box>

          {registerUserIsError && <ErrorMessage error={registerUserError} />}
          {enableSSOAuthentication && (
            <>
              <Box display="flex" flexDirection="column" gap={2} width={1}>
                <LoginWithGoogleButton />
              </Box>
              <Divider sx={{ '--Divider-childPosition': `50%` }}>
                <Typography level="body-xs" color="neutral">
                  Or
                </Typography>
              </Divider>
            </>
          )}
          <Box
            display="flex"
            flexDirection="column"
            gap={4}
            justifyContent="space-between"
            width={1}
          >
            <Box display="flex" flexDirection="column" gap={2}>
              {inputFields?.map(
                ({ type, inputId, customProps, i18nId, withTooltip }) => (
                  <UserInput<FormValue>
                    key={inputId}
                    type={type}
                    inputId={inputId}
                    customProps={customProps}
                    i18nId={i18nId}
                    withTooltip={withTooltip}
                  />
                ),
              )}
            </Box>

            <Button
              id="submit"
              type="submit"
              variant="solid"
              color="primary"
              loading={registerUserIsPending}
            >
              {t('register.form.submit')}
            </Button>

            <Box
              display="flex"
              gap={0.5}
              justifyContent="center"
              alignItems="center"
            >
              <Typography level="body-xs" color="neutral">
                {t('register.form.alreadyHaveAccountLabel')}
              </Typography>
              <Link level="body-xs" onClick={() => navigate('/login')}>
                {t('register.form.loginButtonLabel')}
              </Link>
            </Box>
          </Box>
        </FormWrapper>
      </FormProvider>
    </>
  )
}

export default function InputValidationTooltip({
  children,
  title,
}: {
  children: TooltipProps['children']
  title: TooltipProps['title']
}) {
  return (
    <Tooltip placement="bottom" variant="soft" arrow title={title}>
      {children}
    </Tooltip>
  )
}


--- Start of frontend/src/pages/conversation.tsx ---

import { useRef } from 'react'
import { Helmet } from 'react-helmet-async'
import { useTranslation } from 'react-i18next'
import { Navigate, useParams } from 'react-router-dom'

import { useGetConversationByUuid } from '@/api/services/api'
import { ConversationMessagesList } from '@/features/conversation/components/conversation-message/ConversationMessageList'
import { ConversationScrollToBottomButton } from '@/features/conversation/components/ConversationScrollToBottomButton'
import { ConversationTextarea } from '@/features/conversation/components/ConversationTextarea'
import { ConversationTopbar } from '@/features/conversation/components/ConversationTopbar'
import { Container, Main, ScrollContainer } from '@/components/layout'

const redirectToHomeStatuses = [404, 403]
export function ConversationPage() {
  const { t } = useTranslation()
  const { conversationUuid } = useParams() as { conversationUuid: string }
  const containerRef = useRef<HTMLDivElement | null>(null)

  const {
    data: conversation,
    error: conversationError,
    isError: conversationIsError,
  } = useGetConversationByUuid(conversationUuid, {
    query: { enabled: conversationUuid != null },
  })

  const shouldRedirectToHome =
    conversationError != null &&
    conversationIsError &&
    redirectToHomeStatuses.includes(conversationError.status as number)
  if (shouldRedirectToHome) {
    return <Navigate to="/" replace />
  }

  return (
    <>
      <Helmet>
        <title>{`${conversation?.name ? `${conversation?.name} | ` : ''}${t('app.name')}`}</title>
        <meta name="description" content={t('conversation.metaDescription')} />
      </Helmet>
      <ConversationTopbar />
      <Main sx={{ height: 1 }}>
        <ScrollContainer containerRef={containerRef}>
          <Container sx={{ flexGrow: 1 }}>
            <ConversationMessagesList
              conversationUuid={conversationUuid}
              containerRef={containerRef}
            />
          </Container>
        </ScrollContainer>

        <Container sx={{ position: 'relative' }}>
          <ConversationScrollToBottomButton
            onClick={() =>
              containerRef.current?.scrollTo({
                top: containerRef.current?.scrollHeight,
                behavior: 'smooth',
              })
            }
            containerRef={containerRef}
          />
          <ConversationTextarea conversationExists={conversation != null} />
        </Container>
      </Main>
    </>
  )
}


--- Start of frontend/src/pages/index.ts ---

import { ConversationPage } from './conversation'
import { ConversationsPage } from './conversations'
import { HomePage } from './home'
import { LoginPage } from './login'
import { RegisterPage } from './register'

export {
  HomePage,
  ConversationsPage,
  ConversationPage,
  LoginPage,
  RegisterPage,
}


--- Start of backend/Dockerfile ---

FROM python:3.12-slim AS builder
ENV DEBIAN_FRONTEND=noninteractive

# install system dependencies
# we require git currently because of the temporary installation method used by common lib
RUN apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates git && \
    rm -rf /var/lib/apt/lists/*

# set working directory for future commands
WORKDIR /workspace

# install python dependencies
COPY --from=ghcr.io/astral-sh/uv:0.5 /uv /bin/uv
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    uv sync --frozen --no-dev --no-install-project --no-editable

# copy files and install project
COPY ./backend/ /workspace/
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    uv sync --frozen --no-dev

# separate stage as runner
FROM python:3.12-slim AS runner
COPY --from=builder --chown=nobody:nogroup /workspace /workspace
# set PATH to activate virtual environment
ENV PATH="/workspace/.venv/bin:$PATH"
USER 65534
WORKDIR /workspace

# development runner
FROM runner AS development
COPY --chown=nobody:nogroup ./backend/ /workspace/
ENTRYPOINT ["uvicorn", "src.app:app", "--host=0.0.0.0", "--port=8000", "--reload", "--reload-dir=."]

# production runner
FROM runner AS production
ENTRYPOINT ["/workspace/scripts/entrypoint.sh"]


--- Start of backend/README.md ---

# Backend

## Description

- Backend for the Tribe Platform Chat app that manages users, conversations, messages, and agents. This service enables chat functionality, feedback collection, and agent integration.

## Features

- User management and authentication
- Conversation handling and persistence
- Real-time message processing with streaming responses
- Agent abstraction and integration
- Comprehensive feedback system
- OpenAPI schema generation for frontend client
- Automated database migrations

## Quick Start Guide

### Prerequisites

- Docker
- Git
- AWS CLI configured with appropriate credentials

## Configuration

- Configuration is managed through YAML config files and environment variables
- The main settings file is `src/settings.py`
- Defaults are stored in `configs/defaults.yaml`

## Key Scripts

The following scripts can be run from inside the `backend/` directory

```sh
# Activate virtual environment
source ./scripts/activate.sh

# Run tests
./scripts/test.sh

# Create a new migration (make sure the version is higher than the last migration version)
./scripts/generate_migration.sh

# Regenerate OpenAPI schema
./scripts/generate_openapi.sh
```

### Database Migrations

When changing database models:

1. Make sure the version is higher than the last migration (versions are bumped automatically when anything lands on `main`)

2. Run `./scripts/generate_migration.sh`

3. Review the generated migration in `src/db/migrations/versions/`

### Releasing a New Version

Run the `release` Github Action through the UI

## Documentation

Some extra documentation is available in the `docs/` directory:

- [Auth](docs/auth.md)
- [Tooling](docs/tooling.md)

## Developing with Common Library

To develop with the common library in tandem:

1. Clone the common library repository in a sibling directory
2. Install it in editable mode:

   ```sh
   uv pip install -e ../tribe-platform-chat-backend-api-ai-common-lib/[all] --config-settings editable_mode=strict
   ```

3. Use the `./scripts/dev.sh` script (this is temporary until we figure out having an editable install work with in-cluster development)

## Troubleshooting

If you encounter issues:

1. Ensure prerequisites are installed and up-to-date
2. Verify all environment variables are set correctly
3. Check logs for error messages


--- Start of backend/scripts/check_migration.sh ---

#!/bin/bash
# shellcheck disable=SC1091,SC2181

set -euo pipefail

[[ -d ../.git ]] || { echo "Script should be run from the backend/ dir"; exit 1; }

MIGRATION_LOG_PATH="/tmp/migrate.log"

echo "Checking if migration is required..."
./scripts/generate_migration.sh "check" &> ${MIGRATION_LOG_PATH}

if [ $? -ne 0 ]; then
  echo
  cat ${MIGRATION_LOG_PATH}
  echo
  echo "Migration failed, see above for details"
  echo
  exit 1
else
  rm ${MIGRATION_LOG_PATH}
fi

if [ -f "src/db/migrations/versions/version_check_*.py" ]; then
  rm src/db/migrations/versions/verson_check*.py &> /dev/null
  echo "Migration is required, please bump the version and run ./scripts/generate_migration.sh"
  exit 1
else
  echo "Migration is not required"
  exit 0
fi


--- Start of backend/scripts/activate.sh ---

#!/bin/bash
# shellcheck disable=SC1091,SC2128

[[ -d ../.git ]] || { echo "Script should be run from the backend/ dir"; exit 1; }

if [ "$0" = "${BASH_SOURCE}" ]; then
  echo "This script should be sourced, not executed: 'source scripts/activate.sh' or '. scripts/activate.sh'"
  exit 1
fi

echo "Activating virtual environment"
source ../.venv/bin/activate


--- Start of backend/scripts/generate_openapi.sh ---

#!/bin/bash
# shellcheck disable=SC1091

set -aeuo pipefail

[[ -d ../.git ]] || { echo "Script should be run from the backend/ dir"; exit 1; }

source scripts/activate.sh

export APP__EXPORT_SCHEMA_AND_EXIT=true

echo
echo "Generating schema..."
if [ -f schemas/openapi.yaml ]; then
  mv schemas/openapi.yaml schemas/openapi-previous.yaml
fi

CMD_OUTPUT=$(uvicorn src.app:app 2>&1 || true)
if [ ! -f schemas/openapi.yaml ]; then
  echo
  echo "$CMD_OUTPUT"
  echo
  echo "Schema generation failed, see above for details."
  echo
  if [ -f schemas/openapi.yaml ]; then
    echo "Restoring previous schema."
    mv schemas/openapi-previous.yaml schemas/openapi.yaml
  fi
  exit 1
else
  echo "Schema generated and saved to schemas/openapi.yaml"
  echo
  if [ -f schemas/openapi-previous.yaml ]; then
    rm schemas/openapi-previous.yaml
  fi
fi


--- Start of backend/scripts/generate_migration.sh ---

#!/bin/bash
# shellcheck disable=SC1091,SC2001,SC2086,SC2155

set -aeuo pipefail

[[ -d ../.git ]] || { echo "Script should be run from the backend/ dir"; exit 1; }

source scripts/activate.sh

export DB__CONNECT_ARGS='{"check_same_thread": false}'
export DB__URI="sqlite+aiosqlite:///dev.sqlite"
export MIGRATIONS_DIR=src/db/migrations
DEFAULT_VERSION=$(grep '^version = ' pyproject.toml | sed 's/^version = "\(.*\)"$/\1/')
export VERSION=${1:-$DEFAULT_VERSION}
export VERSION_WITH_UNDERSCORES=$(echo "${VERSION}" | sed 's/\./_/g')
export EXISTING_MIGRATION=$(find "${MIGRATIONS_DIR}/versions" -name "*${VERSION_WITH_UNDERSCORES}*.py")

if [ -n "${EXISTING_MIGRATION}" ]; then
  echo "Migration for version ${VERSION} already exists"
  exit 1
fi

echo "Creating migration for version: ${VERSION}"
rm dev.sqlite &>/dev/null || true
mkdir -p "${MIGRATIONS_DIR}/versions"
alembic -c "${MIGRATIONS_DIR}/alembic.ini" upgrade head
alembic -c "${MIGRATIONS_DIR}/alembic.ini" revision --autogenerate -m "version_${VERSION}"
rm dev.sqlite &>/dev/null || true

MIGRATION_CREATED=$(find "${MIGRATIONS_DIR}/versions" -name "*${VERSION_WITH_UNDERSCORES}*.py")
if [ -z "${MIGRATION_CREATED}" ]; then
  echo "No migration required for version: ${VERSION}"
else
  echo "Migration created: ${MIGRATION_CREATED}"
  echo "Remember to check and commit the generated migration!"
fi


--- Start of backend/scripts/load_test.sh ---

#!/bin/bash
# shellcheck disable=SC1091

set -a

[[ -d ../.git ]] || { echo "Script should be run from the backend/ dir"; exit 1; }

source ../secrets.env

HOST_URL=${HOST_URL:-"http://localhost:8000"}
LOG_LEVEL=${LOG_LEVEL:-"INFO"}

export APP__DEFAULT_RATE_LIMIT=100000/second
export APP__MESSAGE_POST_RATE_LIMIT=100000/second

if ! command -v locust &> /dev/null; then
  echo "locust is not installed. Please install it first."
  exit 1
fi

echo "Running dev script in the background..."
scripts/dev.sh clean > /dev/null 2>&1 &
DEV_PID=$!

trap 'kill $DEV_PID' ERR EXIT

echo "Load test configured to run against ${HOST_URL} with log level ${LOG_LEVEL}"
echo "Starting locust, open http://localhost:8089 to run the test"
echo
locust -H "${HOST_URL}" -f src/tests/load_test.py


--- Start of backend/scripts/test.sh ---

#!/bin/bash
# shellcheck disable=SC1091

set -a

export CONFIG_OVERRIDE_PATHS=configs/test.yaml
export DB__CONNECT_ARGS='{"check_same_thread":false}'
export DB__URI=sqlite+aiosqlite://
export TEST_PATH=${1:-"src"}

echo "Running tests in ${TEST_PATH}..."
START_TIME=$(date +%s)
uv run pytest -p no:cacheprovider --numprocesses=auto --dist=loadscope "${TEST_PATH}"

TESTS_PASSED=$?
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

if [ $TESTS_PASSED -ne 0 ]; then
  echo
  echo "Tests failed (took: $((DURATION / 60))m $((DURATION % 60))s)"
  echo
  exit 1
fi

echo
echo "Tests passed (took: $((DURATION / 60))m $((DURATION % 60))s)"
echo


--- Start of backend/scripts/entrypoint.sh ---

#!/bin/bash
# shellcheck disable=SC1091

set -euo pipefail

MIGRATIONS_ENABLED=${MIGRATIONS_ENABLED:-true}
MIGRATIONS_DIR=src/db/migrations

if [ "$MIGRATIONS_ENABLED" = "true" ]; then
  echo "Running migrations..."
  echo "DB revision before migration: $(alembic -c ${MIGRATIONS_DIR}/alembic.ini current)"
  alembic -c ${MIGRATIONS_DIR}/alembic.ini upgrade head
  echo "DB revision after migration: $(alembic -c ${MIGRATIONS_DIR}/alembic.ini current)"
fi

exec gunicorn \
  --bind :8000 \
  --workers 1 \
  --worker-class uvicorn.workers.UvicornWorker \
  --log-level warning \
  --access-logfile - \
  --error-logfile - \
  --timeout 300 \
  src.app:app


--- Start of backend/scripts/runbooks/run_sql.sql ---

-- edit this file to add your SQL query
-- example query to list all tables in the database
SELECT
    table_name
FROM
    information_schema.tables
WHERE
    table_schema = 'public'
ORDER BY
    table_name;


--- Start of backend/scripts/runbooks/backup_db.sh ---

#!/bin/bash

set -euo pipefail

DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-chat_api}
DB_USER=${DB_USER:-chat_api}
DB_DUMP_NAME=${DB_DUMP_NAME:-"db_backup__${DB_NAME}__$(date +%Y%m%d_%H%M%S).sql"}
DB_GLOBALS_DUMP_NAME=${DB_GLOBALS_DUMP_NAME:-"db_backup__${DB_NAME}__globals_$(date +%Y%m%d_%H%M%S).sql"}
export PGPASSWORD=${DB_PASSWORD}

echo "Dumping database global objects to ${DB_GLOBALS_DUMP_NAME}..."
pg_dumpall -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" --globals-only > "${DB_GLOBALS_DUMP_NAME}"

echo "Dumping database to ${DB_DUMP_NAME}..."
time pg_dump -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" -d "${DB_NAME}" -f "${DB_DUMP_NAME}"

echo
echo "Database backup completed successfully."


--- Start of backend/scripts/runbooks/restore_db.sh ---

#!/bin/bash

set -eo pipefail

DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-chat_api}
DB_USER=${DB_USER:-chat_api}
DB_GLOBALS_DUMP_FILE=${1:-$DB_GLOBALS_DUMP_FILE}
DB_DUMP_FILE=${2:-$DB_DUMP_FILE}
export PGPASSWORD=${DB_PASSWORD}

if [ -z "$DB_GLOBALS_DUMP_FILE" ]; then
    echo "Error: Missing globals dump file, pass it as first argument or set DB_GLOBALS_DUMP_FILE environment variable"
    exit 1
fi

if [ -z "$DB_DUMP_FILE" ]; then
    echo "Error: Missing database dump file, pass it as second argument or set DB_DUMP_FILE environment variable"
    exit 1
fi

if [ ! -f "$DB_GLOBALS_DUMP_FILE" ]; then
    echo "Error: Globals dump file $DB_GLOBALS_DUMP_FILE does not exist"
    exit 1
fi

if [ ! -f "$DB_DUMP_FILE" ]; then
    echo "Error: Database dump file $DB_DUMP_FILE does not exist"
    exit 1
fi

check_db_connection() {
    if ! psql -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" -d "postgres" -c '\q' 2>/dev/null; then
        echo "Error: Could not connect to PostgreSQL server"
        exit 1
    fi
}

echo "Checking database connection..."
check_db_connection

echo "Restoring database global objects from ${DB_GLOBALS_DUMP_FILE}..."
psql -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" -d "postgres" < "${DB_GLOBALS_DUMP_FILE}"

echo "Recreating database ${DB_NAME}..."
dropdb -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" --if-exists "${DB_NAME}"
createdb -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" "${DB_NAME}"

echo "Restoring database from ${DB_DUMP_FILE}..."
time psql -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" -d "${DB_NAME}" < "${DB_DUMP_FILE}"

echo
echo "Database restore completed successfully."


--- Start of backend/scripts/runbooks/run_sql.sh ---

#!/bin/bash

DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-chat_api}
DB_USER=${DB_USER:-chat_api}
SQL_FILE=${SQL_FILE:-scripts/runbooks/run_sql.sql}


if [ -z "${DB_PASSWORD}" ]; then
  echo "DB_PASSWORD is required, set it as an environment variable before running this script"
  exit 1
fi

if [ ! -f "${SQL_FILE}" ]; then
  echo "SQL file not found: ${SQL_FILE}"
  exit 1
fi

echo "Connecting to database ${DB_NAME} on ${DB_HOST}:${DB_PORT} as ${DB_USER}"
echo
echo "Running SQL from ${SQL_FILE}"
echo "----------------------------------------"
cat "${SQL_FILE}"
echo "----------------------------------------"
echo

export PGPASSWORD="${DB_PASSWORD}"
psql -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" -d "${DB_NAME}" -f "${SQL_FILE}"


--- Start of backend/src/conftest.py ---

import asyncio
from collections.abc import AsyncGenerator, Generator
from typing import Any

import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy import select
from tribe_ai.common.db.models import BaseDB
from tribe_ai.utils.timing import log_timing_async

from src.app.initialize import initialize_app
from src.db.connect import AsyncSessionMaker, DBSession, async_engine
from src.db.initialize import init_db_tables, preload_db_data
from src.db.models import *  # noqa: F403  # NOTE: import all models for db metadata initialization
from src.db.models import AgentConfigDB, AgentDB, ConversationDB, MessageDB, UserDB
from src.logger import silence_unwanted_warnings
from src.settings import global_settings


"""
This file is used to define fixtures that are used in tests.
Fixtures are functions that provide test data or setup for tests.
They can be defined here or in the test files themselves, and can be requested in tests by passing the fixture name as an argument.
Fixtures by default are function scoped, but can be changed to module, class, or session scoped.
The decision to keep tests close to the code means the conftest.py file has to be in the src directory.
"""


@pytest_asyncio.fixture
async def api_client() -> AsyncGenerator:
    app = initialize_app()
    async with AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest_asyncio.fixture(scope="session")
def event_loop(request: Any) -> Generator:
    """
    By default, the event loop is function scoped, which can cause issues with async fixtures.
    This fixture provides a session-scoped event loop to avoid those issues.
    Pytest warns about this with a suggested change, but the change doesn't seem to work, something for further investigation.
    """
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    yield loop
    loop.close()


@pytest_asyncio.fixture
async def db_session() -> AsyncGenerator[DBSession, None]:
    """
    The fixture is named db_session to avoid conflict with 'db' variable used in non-test code.
    If they are named the same the editor gets confused and sees regular `db` arguments as fixtures.
    """
    async with AsyncSessionMaker() as db:  # type: ignore
        yield db


@pytest_asyncio.fixture(autouse=True)
async def initialize_db() -> AsyncGenerator[None, None]:
    await prepare_test_db()
    yield
    await cleanup_test_db()


@pytest_asyncio.fixture(autouse=True)
async def silence_warnings() -> None:
    silence_unwanted_warnings()


@pytest_asyncio.fixture
async def test_user_auth_cookie() -> dict[str, str]:
    """
    This works because we use a mock auth implementation for testing that simply serializes the token as JSON.
    """
    return {"session_token": '{"sub": "dev"}'}


@pytest_asyncio.fixture
async def test_agent(db_session: DBSession) -> AgentDB | None:
    query = select(AgentDB).where(AgentDB.uuid == "40a3607c-be98-485a-b498-fb70e5ff273d")
    return (await db_session.execute(query)).unique().scalar()


@pytest_asyncio.fixture
async def test_agent_config(db_session: DBSession) -> AgentConfigDB | None:
    query = select(AgentConfigDB).where(AgentConfigDB.uuid == "b32b1287-6c0b-4f8e-afb8-ca7d5b9adced")
    return (await db_session.execute(query)).unique().scalar()


@pytest_asyncio.fixture
async def test_agent_config_with_tool(db_session: DBSession) -> AgentConfigDB | None:
    query = select(AgentConfigDB).where(AgentConfigDB.uuid == "b32b1287-6c0b-4f8e-afb8-ca7d5b9adced")
    return (await db_session.execute(query)).unique().scalar()


@pytest_asyncio.fixture
async def test_conversation(db_session: DBSession) -> ConversationDB | None:
    query = select(ConversationDB).where(ConversationDB.uuid == "66ede431-3436-4886-9896-c3a306cd9b7a")
    return (await db_session.execute(query)).unique().scalar()


@pytest_asyncio.fixture
async def test_assistant_message(db_session: DBSession) -> MessageDB | None:
    query = select(MessageDB).where(MessageDB.uuid == "8e2c6070-4b5a-4c18-bf79-368a9cc2c72c")
    return (await db_session.execute(query)).unique().scalar()


@pytest_asyncio.fixture
async def test_user_message(db_session: DBSession) -> MessageDB | None:
    query = select(MessageDB).where(MessageDB.uuid == "312744c6-e3ea-4b62-b50b-c0223b64c64e")
    return (await db_session.execute(query)).unique().scalar()


@pytest_asyncio.fixture
async def test_user(db_session: DBSession) -> UserDB | None:
    query = select(UserDB).where(UserDB.username == "dev")
    return (await db_session.execute(query)).unique().scalar()


@log_timing_async
async def cleanup_test_db() -> None:
    async with async_engine.begin() as conn:
        await conn.run_sync(BaseDB.metadata.drop_all)


@log_timing_async
async def prepare_test_db() -> None:
    await init_db_tables()
    await preload_db_data(data_path=global_settings.app.db_preload_data_path)


--- Start of backend/src/__init__.py ---

from pathlib import Path


pyproject_toml_path = Path(__file__).parent.parent / "pyproject.toml"
pyproject_toml_text = pyproject_toml_path.read_text()
version_line = next(line for line in pyproject_toml_text.split("\n") if line.startswith("version = "))
__version__ = app_version = version_line.split(" = ")[1].strip().strip('"')


--- Start of backend/src/logger.py ---

import logging
import warnings

from tribe_ai.logger import colorize_logs, configure_formatter, configure_handler, configure_logger
from urllib3.exceptions import InsecureRequestWarning

from src.settings import global_settings


def configure_root_logger() -> logging.Logger:
    logging_settings = global_settings.logging
    if logging_settings.colors:
        colorize_logs()

    formatter = configure_formatter(settings=logging_settings)
    handler = configure_handler(formatter=formatter, settings=logging_settings)
    return configure_logger(handler=handler, settings=logging_settings)


def silence_unwanted_loggers() -> None:
    """
    Silence loggers that are too verbose or not relevant to the current context.
    """
    logging.getLogger("aiocache").setLevel(logging.ERROR)
    logging.getLogger("asyncio").setLevel(logging.INFO)
    logging.getLogger("anthropic").setLevel(logging.WARNING)
    logging.getLogger("aiosqlite").setLevel(logging.WARNING)
    logging.getLogger("botocore").setLevel(logging.WARNING)
    logging.getLogger("faker").setLevel(logging.WARNING)
    logging.getLogger("filelock").setLevel(logging.WARNING)
    logging.getLogger("gunicorn.access").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("httpcore").setLevel(logging.WARNING)
    logging.getLogger("markdown_it").setLevel(logging.WARNING)
    logging.getLogger("multipart.multipart").setLevel(logging.WARNING)
    logging.getLogger("opensearch").setLevel(logging.CRITICAL)
    logging.getLogger("passlib.handlers.bcrypt").setLevel(logging.CRITICAL)
    logging.getLogger("passlib.registry").setLevel(logging.WARNING)
    logging.getLogger("passlib.utils").setLevel(logging.WARNING)
    logging.getLogger("sse_starlette.sse").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("uvicorn.error").handlers = []


def silence_unwanted_warnings() -> None:
    """
    Silence warnings that are too verbose or not relevant to the current context.
    """
    warnings.filterwarnings("ignore", category=DeprecationWarning, module=r"aiosqlite\..*")
    warnings.filterwarnings("ignore", category=DeprecationWarning, module=r"httpx\..*")
    warnings.filterwarnings("ignore", category=FutureWarning, module=r"huggingface_hub\.file_download")
    warnings.filterwarnings("ignore", category=InsecureRequestWarning, module=r"urllib3\..*")
    warnings.filterwarnings("ignore", category=UserWarning, module=r"opensearchpy\..*")


silence_unwanted_loggers()
silence_unwanted_warnings()
root_logger = configure_root_logger()


--- Start of backend/src/settings.py ---

from os import getenv
from pathlib import Path
from typing import Self
from uuid import UUID

from pydantic import AnyHttpUrl, BaseModel, Field, SecretStr, model_validator
from pydantic_settings import BaseSettings, PydanticBaseSettingsSource, SettingsConfigDict, YamlConfigSettingsSource
from tribe_ai.clients.analytics import AnalyticsConfig
from tribe_ai.clients.authentication import AuthenticationConfig
from tribe_ai.clients.llm import LLMConfig, StructuredOutputStrategy
from tribe_ai.clients.object_storage import ObjectStorageConfig
from tribe_ai.clients.search.vector import VectorSearchConfig
from tribe_ai.common.db import DbConfig
from tribe_ai.logger import LoggingSettings
from tribe_ai.services.ingestion import IngestionConfig

from src import app_version


"""
We prefer to set all values from the environment to increase clarity on what value is being set.
"""


class AppConfig(BaseModel):
    """
    General configuration for the application.

    Some of the 'app' attributes match FastAPI __init__ parameters for convenient instantiation.
    """

    # app
    title: str
    description: str
    docs_enabled: bool = True
    docs_url: str | None
    host_url: AnyHttpUrl
    openapi_url: str
    port: int
    root_path: str
    version: str = app_version

    # cors
    cors_origins: list[str]

    # defaults
    default_rate_limit: str
    max_dynamic_starters_to_generate: int

    # initialization
    db_preload_data_path: Path | None = None
    db_preload_enabled: bool = True
    db_preload_override_existing: bool = False
    init_db_tables: bool = True
    init_error_analytics: bool = True
    init_search_indices: bool = True
    search_preload_enabled: bool = True

    # feedback
    feedback_slack_webhook: str | None = None

    # middleware
    enable_timing_middleware: bool

    # rate limits
    message_post_rate_limit: str

    # static files
    static_dir: Path
    static_image_endpoint_path: str

    # tracing
    tracing_enabled: bool = False
    tracing_service_name: str = "tribe-platform-chat"

    # validation
    validate_username_regex: str

    # special startup flags
    export_schema_and_exit: bool = False

    @model_validator(mode="after")
    def validate_docs_url(self) -> Self:
        if not self.docs_enabled:
            self.docs_url = None

        return self

    def get_docs_url(self) -> str | None:
        """
        The `docs_url` attribute is actually just the path (incorrectly named in the FastAPI __init__), so we need to prepend the host.
        The `host_url` is the base URL for the (frontend) application, whereas we need the URL for the backend (this server),
        so if running locally we need to replace the port.
        """
        if not self.docs_enabled or not self.docs_url:
            return None

        host_url = str(self.host_url)
        if "localhost" in host_url:
            host_url, _ = host_url.rsplit(":", 1)
            host_url += f":{self.port}"

        host_url = host_url.rstrip("/")
        return host_url + self.docs_url


class AgentsConfig(BaseModel):
    default_agent_uuid: UUID
    default_agent_config_uuid: UUID = UUID("72beca29-4fe3-4940-8012-a6d8aca5a922")
    conversation_context_local_dir: Path
    conversation_context_bucket_key_prefix_template: str
    conversation_context_cleanup_local_dir_after_sync: bool
    tool_registry_ids_hidden_from_api: list[str] = Field(default_factory=list)


class AssetConfig(BaseModel):
    bucket_key_template: str


class EmbeddingCacheConfig(BaseModel):
    bucket_name: str
    bucket_key_template: str
    enabled: bool = True


class LLMFunctionsConfig(BaseModel):
    """
    Configuration for LLM functions.
    Currently shared, could be split out to configure each task separately if needed.
    """

    llm_model_id: str
    structured_output_strategy: StructuredOutputStrategy = StructuredOutputStrategy.NAIVE
    structured_output_max_retries: int = 3


class PathsConfig(BaseModel):
    project_root: Path = Path(__file__).parent.parent
    configs_dir: Path = project_root / "configs"
    defaults_config_path: Path = configs_dir / "defaults.yaml"
    overrides_configs_dir: Path = Path("/etc/tribe/chat-api.d/")


class ProviderConfig(BaseModel):
    auth: str
    object_storage: str
    search: str


class ToolsConfig(BaseModel):
    data_analyst_sql_tool_demo_data_dir: Path = Path("data/demo")
    data_analyst_sql_tool_demo_db_path: Path = Path("outputs/demo.db")
    tribe_hub_db_uri: SecretStr | None = None
    tribe_projects_airtable_base_id: str | None = None
    tribe_projects_airtable_table_id: str | None = None
    tribe_projects_airtable_api_key: SecretStr | None = None
    tribe_projects_airtable_page_id: str | None = None


class GlobalSettings(BaseSettings):
    """
    Automatically loads configuration from environment variables.
    Uses nested config BaseModels for cleaner namespacing.

    Note:
        Loading from environment variables is case-insensitive, so `ALLOWED_EMAIL_DOMAINS` and `allowed_email_domains` are equivalent.
        We choose to _set_ all environment variables in uppercase in line with the convention of most systems.
        We choose to _read_ all environment variables in lowercase to match Python naming conventions.

    Note:
        Complex types (like list, dict) are loaded as JSON strings.
        For example, a field `allowed_email_domains: list[str]` would be set in the environment as `ALLOWED_EMAIL_DOMAINS='["tribe.ai"]'`.

    Warning:
        A quirk of nested settings is that at least one value of each nested model
        must be set in the environment, or instantiation will fail.

        For example, if all values of ProviderConfig were optional, and none were set in the environment,
        and `provider: ProviderConfig` was used, instantiation would fail unless at least one value was set.
        To avoid this behavior you can add default instantiation like `provider: ProviderConfig = ProviderConfig()`.
    """

    model_config = SettingsConfigDict(
        env_prefix=getenv("CHAT_API__ENV_PREFIX", ""), env_nested_delimiter="__", extra="ignore"
    )

    app: AppConfig
    agents: AgentsConfig
    analytics: AnalyticsConfig
    asset: AssetConfig
    auth: AuthenticationConfig
    db: DbConfig
    embedding_cache: EmbeddingCacheConfig
    ingestion: IngestionConfig
    logging: LoggingSettings = LoggingSettings()
    llm_functions: LLMFunctionsConfig
    llm: LLMConfig
    object_storage: ObjectStorageConfig
    paths: PathsConfig = PathsConfig()
    provider: ProviderConfig
    search: VectorSearchConfig
    tools: ToolsConfig = ToolsConfig()

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        defaults_yaml_source = YamlConfigSettingsSource(settings_cls, yaml_file=PathsConfig().defaults_config_path)
        yaml_override_paths = sorted(PathsConfig().overrides_configs_dir.glob("*.yaml"))
        extra_yaml_override_paths = getenv("CONFIG_OVERRIDE_PATHS", "").split(",")
        for path in extra_yaml_override_paths:
            config_path = Path(path)
            if config_path.exists():
                yaml_override_paths.append(config_path)
                continue

            raise FileNotFoundError(f"Config override path does not exist: {config_path}")

        yaml_override_sources = [YamlConfigSettingsSource(settings_cls, yaml_file=path) for path in yaml_override_paths]
        # NOTE: sources are in order of priority, so the sources defined first will override later sources
        return (env_settings, *yaml_override_sources, defaults_yaml_source, init_settings)


# type ignore: global_settings will instantiate the objects itself
global_settings = GlobalSettings()  # type: ignore[call-arg]


--- Start of backend/src/exceptions.py ---

from fastapi import HTTPException


# NOTE: we subclass FastAPI's HTTPException for convenience
class NotFoundError(HTTPException):
    def __init__(self, entity: str, by: str | list[str] | None = None) -> None:
        if by is None:
            by = []

        if isinstance(by, str):
            by = [by]

        # NOTE: prefer to only log fields to prevent leaking sensitive information
        message = f"{entity} not found"
        if by:
            message += f" by {', '.join(by)}"

        super().__init__(status_code=404, detail=message)


--- Start of backend/src/clients/__init__.py ---

from src.clients.airtable.client import AirtableClient


__all__ = ["AirtableClient"]


--- Start of backend/src/clients/airtable/client.py ---

from pyairtable import Api, Table

from src.settings import global_settings


class AirtableClient:
    def __init__(self) -> None:
        if not global_settings.tools.tribe_projects_airtable_api_key:
            raise ValueError("Airtable API key must be set")

        self._api = Api(global_settings.tools.tribe_projects_airtable_api_key.get_secret_value())

    def get_projects_table(self) -> Table:
        if (
            not global_settings.tools.tribe_projects_airtable_base_id
            or not global_settings.tools.tribe_projects_airtable_table_id
        ):
            raise ValueError("Airtable base ID and table ID must be set")

        return self._api.table(
            global_settings.tools.tribe_projects_airtable_base_id,
            global_settings.tools.tribe_projects_airtable_table_id,
        )

    def get_project_page_link(self, record_id: str) -> str:
        if not global_settings.tools.tribe_projects_airtable_page_id:
            raise ValueError("Airtable page ID must be set")

        return f"https://airtable.com/{global_settings.tools.tribe_projects_airtable_base_id}/{global_settings.tools.tribe_projects_airtable_page_id}?ovRVG={record_id}"


--- Start of backend/src/clients/airtable/__init__.py ---



--- Start of backend/src/ingestion/initialize.py ---

from tribe_ai.clients.embedding import BaseEmbeddingClient, embedding_client_registry
from tribe_ai.clients.embedding.config import EmbeddingConfig

from src.ingestion.embeddings_caching import embedding_cache_get_fn, embedding_cache_put_fn
from src.settings import global_settings


def get_or_create_embedding_client(name: str, config: EmbeddingConfig, caching: bool = True) -> BaseEmbeddingClient:
    if caching and global_settings.embedding_cache.enabled:
        return embedding_client_registry.get_or_create_instance(
            name=name,
            config=config,
            embedding_cache_get_fn=embedding_cache_get_fn,
            embedding_cache_put_fn=embedding_cache_put_fn,
        )

    return embedding_client_registry.get_or_create_instance(
        name=name,
        config=config,
    )


--- Start of backend/src/ingestion/embeddings_caching.py ---

import json
from hashlib import blake2b
from pathlib import Path
from tempfile import NamedTemporaryFile

import aiofiles
from tribe_ai.clients.embedding.models import Embedding
from tribe_ai.clients.object_storage import object_storage_client_registry

from src.settings import global_settings


async def embedding_cache_get_fn(text: str) -> Embedding | None:
    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.embedding_cache.bucket_name,
    )

    content_hash = _get_content_hash_from_text(text)
    bucket_key = global_settings.embedding_cache.bucket_key_template.format(
        content_hash=content_hash,
    )

    if not await object_storage_client.key_exists(bucket_key):
        return None

    with NamedTemporaryFile() as temp_file:
        temp_path = Path(temp_file.name)
        await object_storage_client.download(key=bucket_key, local_path=temp_path)
        async with aiofiles.open(temp_path, "rb") as f:
            data = await f.read()
            embedding = json.loads(data)

        return Embedding(
            text=text,
            embedding=embedding,  # type: ignore
        )


async def embedding_cache_put_fn(embedding: Embedding) -> None:
    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.embedding_cache.bucket_name,
    )

    content_hash = _get_content_hash_from_text(embedding.text)
    bucket_key = global_settings.embedding_cache.bucket_key_template.format(
        content_hash=content_hash,
    )

    with NamedTemporaryFile(mode="w", delete=False) as temp_file:
        temp_path = Path(temp_file.name)
        json.dump(embedding.embedding, temp_file)

    try:
        await object_storage_client.upload(local_path=temp_path, key=bucket_key)
    finally:
        temp_path.unlink(missing_ok=True)


def _get_content_hash_from_text(text: str) -> str:
    text_bytes = text.encode("utf-8")
    text_hash = blake2b()
    text_hash.update(text_bytes)

    return text_hash.hexdigest()


--- Start of backend/src/ingestion/__init__.py ---



--- Start of backend/src/ingestion/pipeline.py ---

from tribe_ai.clients.embedding.config import EmbeddingConfig
from tribe_ai.services.ingestion import IngestionPipeline
from tribe_ai.services.ingestion.steps import BaseIndexingStep, all_parsing_steps
from tribe_ai.services.ingestion.steps.processing.embed import EmbedStep
from tribe_ai.services.ingestion.steps.processing.fix_text_encoding import FixTextEncodingStep
from tribe_ai.services.ingestion.steps.processing.summarize import SummarizeStep

from src.ingestion.indexing_functions.database import index_chunks_in_db, index_document_in_db
from src.ingestion.indexing_functions.search import index_chunks_in_search, index_document_in_search
from src.ingestion.initialize import get_or_create_embedding_client
from src.llm.initialize import get_or_create_llm_client
from src.logger import root_logger
from src.settings import global_settings


ingestion_pipeline: IngestionPipeline | None = None
log = root_logger.getChild(__name__)


def get_or_create_ingestion_pipeline() -> IngestionPipeline:
    """
    Get or create the ingestion pipeline.

    Instantiation of steps is done differently for each type:
    - You probably want all possible parsing steps to support as many file types as possible.
      therefore, we instantiate all parsing steps from the `all_parsing_steps` list.
    - Processing steps will be different per project. Here, we instantiate using a configuration value.
      This allows for easy configuration without changing the code, enabling rapid experimentation.
      Instantiating classes directly here is of course also possible.
    - Indexing is also a special case, as where and how to index will be different per project.
      We simply instantiate the BaseIndexingStep with functions for indexing both documents and chunks.
      In the current application, we index to both a database and a search index.
    """
    global ingestion_pipeline
    if ingestion_pipeline is not None:
        return ingestion_pipeline

    parsing_steps = [step() for step in all_parsing_steps]  # type: ignore[abstract]
    processing_steps = [
        FixTextEncodingStep(),
        SummarizeStep(llm_client=get_or_create_llm_client(global_settings.ingestion.summarization_llm_model_id)),
        EmbedStep(
            embedding_client=get_or_create_embedding_client(
                global_settings.search.embedding_model_id,
                config=EmbeddingConfig(
                    api_key=global_settings.search.embedding_api_key,
                    base_url=global_settings.search.embedding_base_url,
                ),
            )
        ),
    ]

    indexing_steps = [
        BaseIndexingStep(document_indexing_fn=index_document_in_db, chunks_indexing_fn=index_chunks_in_db),
        BaseIndexingStep(document_indexing_fn=index_document_in_search, chunks_indexing_fn=index_chunks_in_search),
    ]

    ingestion_pipeline = IngestionPipeline(
        config=global_settings.ingestion,
        parsing_steps=parsing_steps,
        processing_steps=processing_steps,
        indexing_steps=indexing_steps,
    )

    msg = "Created ingestion pipeline with steps:\n"
    msg += f"Parsing steps:\n  - {ingestion_pipeline.parsing_steps}\n"
    msg += f"Processing steps:\n  - {ingestion_pipeline.processing_steps}\n"
    msg += f"Indexing steps:\n  - {ingestion_pipeline.indexing_steps}\n"
    log.info(msg)
    return ingestion_pipeline


--- Start of backend/src/ingestion/indexing_functions/database.py ---

from tribe_ai.services.ingestion import IngestionChunk, IngestionDocument

from src.db.connect import AsyncSessionMaker, DBSession
from src.db.models import IngestionChunkDB, IngestionDocumentDB
from src.logger import root_logger
from src.models import IngestionChunkDTO, IngestionDocumentDTO


log = root_logger.getChild(__name__)


async def index_document_in_db(ingestion_document: IngestionDocument) -> IngestionDocument:
    log.info(f"Ingesting document {ingestion_document.uuid} in database")
    db: DBSession
    async with AsyncSessionMaker() as db:  # type: ignore
        ingestion_document_dto: IngestionDocumentDTO = IngestionDocumentDTO.from_library_model(
            ingestion_document=ingestion_document
        )
        ingestion_document_db = IngestionDocumentDB.from_dto(ingestion_document_dto)

        # TODO: consider doing create_or_update to allow for re-ingestion of the same document
        db.add(ingestion_document_db)
        await db.commit()
        await db.refresh(ingestion_document_db)
        return ingestion_document


async def index_chunks_in_db(chunks: list[IngestionChunk]) -> list[IngestionChunk]:
    log.info(f"Ingesting {len(chunks)} chunks in database")
    db: DBSession
    async with AsyncSessionMaker() as db:  # type: ignore
        ingestion_chunk_dtos: list[IngestionChunkDTO] = [
            IngestionChunkDTO.from_library_model(ingestion_chunk=c) for c in chunks
        ]
        ingestion_chunks_db = [IngestionChunkDB.from_dto(c) for c in ingestion_chunk_dtos]
        db.add_all(ingestion_chunks_db)
        await db.commit()
        return chunks


--- Start of backend/src/ingestion/indexing_functions/__init__.py ---



--- Start of backend/src/ingestion/indexing_functions/search.py ---

from tribe_ai.clients.search import IndexableSearchDocument
from tribe_ai.services.ingestion import IngestionChunk, IngestionDocument

from src.logger import root_logger
from src.models import IngestionChunkDTO, IngestionDocumentDTO
from src.search.connect import get_hybrid_search_client
from src.search.indices import ingestion_chunk_search_index, ingestion_document_search_index


log = root_logger.getChild(__name__)


async def index_document_in_search(ingestion_document: IngestionDocument) -> IngestionDocument:
    log.info(f"Ingesting document {ingestion_document.uuid} in search indices")
    ingestion_document_dto: IngestionDocumentDTO = IngestionDocumentDTO.from_library_model(
        ingestion_document=ingestion_document
    )

    indexable_dict = ingestion_document_search_index.filter_and_cast_indexable_fields(
        ingestion_document_dto.model_dump()
    )
    indexable_document = IndexableSearchDocument(**indexable_dict)

    hybrid_search_client = get_hybrid_search_client()
    await hybrid_search_client.index_documents(
        documents=[indexable_document], index_schema=ingestion_document_search_index
    )
    return ingestion_document


async def index_chunks_in_search(chunks: list[IngestionChunk]) -> list[IngestionChunk]:
    log.info(f"Ingesting {len(chunks)} chunks in search indices")
    ingestion_chunk_dtos: list[IngestionChunkDTO] = [
        IngestionChunkDTO.from_library_model(ingestion_chunk=c) for c in chunks
    ]

    indexable_dicts = [
        ingestion_chunk_search_index.filter_and_cast_indexable_fields(c.model_dump()) for c in ingestion_chunk_dtos
    ]
    indexable_documents = [IndexableSearchDocument(**d) for d in indexable_dicts]

    hybrid_search_client = get_hybrid_search_client()

    # TODO: consider handling errors for search indexing
    await hybrid_search_client.index_documents(documents=indexable_documents, index_schema=ingestion_chunk_search_index)
    return chunks


--- Start of backend/src/ingestion/search_indices/__init__.py ---



--- Start of backend/src/ingestion/search_indices/ingestion_document.py ---

from tribe_ai.clients.search import SearchIndexSchema


ingestion_document_search_index = SearchIndexSchema(
    index_name="ingestion_document",
    indexed_fields=["filename", "content_processed", "summary", "questions_answered_in_text", "topics"],
    filterable_fields=["asset_type", "user_uuid", "asset_uuid", "ingestion_document_uuid"],
    datetime_fields=["created_at", "updated_at"],
    extra_fields=["settings"],
)


--- Start of backend/src/ingestion/search_indices/ingestion_chunk.py ---

from tribe_ai.clients.search import SearchIndexSchema


ingestion_chunk_search_index = SearchIndexSchema(
    index_name="ingestion_chunk",
    indexed_fields=["content_processed", "summary", "questions_answered_in_text", "topics"],
    embedding_field="embedding",
    filterable_fields=["conversation_uuid", "user_uuid", "uuid", "asset_uuid"],
    datetime_fields=["created_at", "updated_at"],
    extra_fields=["section", "extra"],
)


--- Start of backend/src/llm/initialize.py ---

from tribe_ai.clients.llm import BaseLLMClient, StructuredOutputAdapter, StructuredOutputConfig, llm_client_registry

from src.db import crud
from src.settings import global_settings


def get_or_create_llm_client(name: str, caching: bool = True) -> BaseLLMClient:
    if caching:
        return llm_client_registry.get_or_create_instance(
            name=name,
            config=global_settings.llm,
            generation_cache_get_fn=crud.generation_log.generation_cache_get_fn,
            generation_cache_put_fn=crud.generation_log.generation_cache_put_fn,
        )

    return llm_client_registry.get_or_create_instance(name=name, config=global_settings.llm)


def get_or_create_llm_functions_llm_client() -> StructuredOutputAdapter:
    llm_config = global_settings.llm.model_copy()
    llm_config.verbose_logging = False

    llm_functions_llm_client = llm_client_registry.get_or_create_instance(
        name=global_settings.llm_functions.llm_model_id,
        config=llm_config,
        generation_cache_get_fn=crud.generation_log.generation_cache_get_fn,
        generation_cache_put_fn=crud.generation_log.generation_cache_put_fn,
    )
    llm_functions_structured_output_config = StructuredOutputConfig(
        max_retries=global_settings.llm_functions.structured_output_max_retries,
        structured_output_strategy=global_settings.llm_functions.structured_output_strategy,
    )
    return StructuredOutputAdapter(config=llm_functions_structured_output_config, llm_client=llm_functions_llm_client)


--- Start of backend/src/llm/__init__.py ---



--- Start of backend/src/app/enums.py ---

from enum import StrEnum


class ProductAnalyticsEvent(StrEnum):
    CONVERSATION_CREATE = "conversation_create"
    CONVERSATION_UPDATE = "conversation_update"
    CONVERSATION_DELETE = "conversation_delete"

    USER_SIGNUP = "user_signup"
    USER_LOGIN = "user_login"
    USER_LOGIN_SSO = "user_login_sso"
    USER_LOGIN_FAILED = "user_login_failed"
    USER_LOGOUT = "user_logout"
    USER_DELETED = "user_deleted"
    USER_PROFILE_UPDATE = "user_profile_update"


--- Start of backend/src/app/initialize.py ---

from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from importlib import reload

import tribe_ai
from fastapi import FastAPI
from httpx import AsyncClient
from tribe_ai.common.app.utils.openapi import (
    collapse_swagger_ui_sections_by_default,
    export_openapi_schema,
    use_route_names_as_operation_ids,
)
from tribe_ai.common.app.utils.rate_limiter import rate_limiter, rate_limiter_exception, rate_limiter_handler
from tribe_ai.common.tracing import initialize_tracing

from src import __version__ as app_version
from src.app.apis.endpoints.agent import router as agent_router
from src.app.apis.endpoints.asset import router as asset_router
from src.app.apis.endpoints.audit_log import router as audit_log_router
from src.app.apis.endpoints.auth import router as auth_router
from src.app.apis.endpoints.conversation import router as conversation_router
from src.app.apis.endpoints.feedback import router as feedback_router
from src.app.apis.endpoints.health import router as health_router
from src.app.apis.endpoints.llm import router as models_router
from src.app.apis.endpoints.message import router as message_router
from src.app.apis.endpoints.search import router as search_router
from src.app.apis.endpoints.tool import router as tool_router
from src.app.apis.endpoints.user import router as user_router
from src.app.middlewares import mount_middleware
from src.app.utils.error_analytics import initialize_error_analytics
from src.app.utils.static_files import mount_static_file_router
from src.db.initialize import init_db_tables, preload_db_data
from src.ingestion.pipeline import get_or_create_ingestion_pipeline
from src.logger import root_logger
from src.search.initialize import init_search_indices, preload_search_data
from src.settings import global_settings


log = root_logger.getChild(__name__)


@asynccontextmanager
async def lifespan(app_: FastAPI) -> AsyncGenerator[None, None]:
    if global_settings.app.export_schema_and_exit:
        export_openapi_schema(app_)
        raise SystemExit

    if global_settings.app.init_db_tables:
        await init_db_tables()

    if global_settings.app.init_error_analytics:
        await initialize_error_analytics()

    if global_settings.app.db_preload_enabled:
        await preload_db_data(data_path=global_settings.app.db_preload_data_path)

    if global_settings.app.init_search_indices:
        await init_search_indices()

    if global_settings.app.search_preload_enabled:
        await preload_search_data(db_data_path=global_settings.app.db_preload_data_path)

    get_or_create_ingestion_pipeline()

    config_overrides = sorted(global_settings.paths.overrides_configs_dir.glob("*.yaml"))
    for config_override in config_overrides:
        log.info(f"Applied config override: {config_override}")

    log.info("Application initialized")
    if global_settings.app.docs_enabled:
        log.info(f"View the API documentation at {global_settings.app.get_docs_url()}")

    async with AsyncClient() as client:
        app_.state.httpx_client = client
        yield


def initialize_app() -> FastAPI:
    app = FastAPI(lifespan=lifespan, **global_settings.app.model_dump())
    app.include_router(agent_router)
    app.include_router(asset_router)
    app.include_router(audit_log_router)
    app.include_router(auth_router)
    app.include_router(conversation_router)
    app.include_router(feedback_router)
    app.include_router(health_router)
    app.include_router(message_router)
    app.include_router(models_router)
    app.include_router(search_router)
    app.include_router(tool_router)
    app.include_router(user_router)
    app.state.limiter = rate_limiter
    # type ignore: the slowapi library types its exception handler too narrowly
    app.add_exception_handler(exc_class_or_status_code=rate_limiter_exception, handler=rate_limiter_handler)  # type: ignore[arg-type]

    # NOTE: tracing must be initialized before mounting tracing middleware
    if global_settings.app.tracing_enabled:
        initialize_tracing(service_name=global_settings.app.tracing_service_name, version=app_version)

    mount_static_file_router(app)
    mount_middleware(app)
    collapse_swagger_ui_sections_by_default()
    use_route_names_as_operation_ids(app)
    reload(tribe_ai)
    return app


--- Start of backend/src/app/__init__.py ---

from src.app.initialize import initialize_app


app = initialize_app()


--- Start of backend/src/app/middlewares.py ---

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from tribe_ai.common.app.middleware.timing import TimingMiddleware

from src.settings import global_settings


def mount_middleware(app: FastAPI) -> None:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=global_settings.app.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # NOTE: we always enable OpenTelemetry default tracing of all FastAPI routes
    #       if tracing is not configured in the environment, this will have no effect
    FastAPIInstrumentor.instrument_app(
        app,
        # we don't want these to show up in the traces
        excluded_urls="/health,/ready",
        # we disable the instrumentation of the send and receive method to avoid showing loads of spans
        # from, for example, Server Side Events. Also they don't really contain information we currently value.
        exclude_spans=["receive", "send"],
    )

    if global_settings.app.enable_timing_middleware:
        app.add_middleware(TimingMiddleware)


--- Start of backend/src/app/apis/__init__.py ---



--- Start of backend/src/app/apis/endpoints/auth.py ---

from fastapi import APIRouter, HTTPException, Request, Response, status
from fastapi.responses import RedirectResponse
from pydantic import AwareDatetime
from tribe_ai.clients.analytics import analytics_client_registry
from tribe_ai.clients.authentication import AuthenticationError
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.auth import LoginRequest
from src.app.enums import ProductAnalyticsEvent
from src.app.handlers.auth import (
    LoggedInUser,
    LoginRequestForm,
    generate_token,
    get_or_create_user_from_sso,
    get_sso_provider,
    verify_hashed_secret,
)
from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.models import AuditActionType, AuditLogDTO
from src.settings import global_settings


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/auth", tags=["Auth"])


@router.get("/check")
async def check_login(user_dto: LoggedInUser) -> None:
    pass


@router.post(
    "/login",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def login(request: Request, response: Response, db: DBSession, form_data: LoginRequestForm) -> None:
    # type ignore: str not recognized as valid input for SecretStr
    login_request = LoginRequest(email=form_data.username, password=form_data.password)  # type: ignore[arg-type]

    user = await crud.user.get_by_email(db=db, email=login_request.email)
    if user is None:
        log.info(f"Failed login attempt for email {login_request.email} (user not found)")
        raise AuthenticationError(detail="Invalid email or password")

    if not user.password_hash:
        log.info(f"Failed login attempt for username {user.username} (no password hash)")
        # TODO: consider raising a different error type for if the user exists but has no password hash
        #       consider whether it's worth leaking information about whether a user exists
        #       when in fact the user should use SSO
        raise AuthenticationError(detail="Invalid email or password")

    password = login_request.password.get_secret_value()
    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    if not verify_hashed_secret(plain=password, hashed=user.password_hash):
        log.info(f"Failed login attempt for username {user.username} (incorrect password)")

        audit_log_dto = AuditLogDTO(user_uuid=user.uuid, action_type=AuditActionType.FAILED_LOGIN)
        await crud.audit_log.create(db=db, audit_log=audit_log_dto)

        await product_analytics_client.capture(
            event_type=ProductAnalyticsEvent.USER_LOGIN_FAILED,
            **user.get_analytics_properties(),
        )

        raise AuthenticationError(detail="Invalid email or password")

    log.info(f"Logging in user {user.username}")
    token = generate_token(username=user.username)
    _set_session_token_cookie(response=response, token=token.token, expires=token.expires_at)

    audit_log_dto = AuditLogDTO(user_uuid=user.uuid, action_type=AuditActionType.LOGIN)
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)

    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.USER_LOGIN,
        **user.get_analytics_properties(),
    )


@router.post("/logout")
async def logout(response: Response, user_dto: LoggedInUser) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Logging out user {user_dto.username}")
    response.delete_cookie(key="session_token")

    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.USER_LOGOUT,
        **user_dto.get_analytics_properties(),
    )


@router.get("/sso/google/login")
async def sso_google_login(request: Request) -> str:
    if not global_settings.auth.google_sso or not global_settings.auth.google_sso.client_id:
        raise HTTPException(status.HTTP_501_NOT_IMPLEMENTED, detail="Google SSO not configured")

    sso = get_sso_provider("google")
    if not sso:
        raise HTTPException(status.HTTP_501_NOT_IMPLEMENTED, detail="SSO not configured")

    with sso:
        response = await sso.get_login_redirect(params=global_settings.auth.google_sso.redirect_params)
        return response.headers["location"]


@router.get("/sso/google/callback")
async def sso_google_callback(request: Request, db: DBSession) -> RedirectResponse:
    user_dto = await get_or_create_user_from_sso(db=db, request=request)
    token = generate_token(username=user_dto.username)
    response = RedirectResponse(url=str(global_settings.app.host_url))
    _set_session_token_cookie(response=response, token=token.token, expires=token.expires_at)

    audit_log_dto = AuditLogDTO(user_uuid=user_dto.uuid, action_type=AuditActionType.LOGIN)
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)

    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.USER_LOGIN_SSO,
        **user_dto.get_analytics_properties(),
    )
    return response


def _set_session_token_cookie(response: Response, token: str, expires: AwareDatetime) -> None:
    """
    Set the session token in a cookie with the correct security settings.
    This is a separate function so we can ensure we always set the right security settings.
    """
    response.set_cookie(
        key="session_token", value=token, expires=expires, httponly=True, secure=True, samesite="strict"
    )


--- Start of backend/src/app/apis/endpoints/user.py ---

import re

from fastapi import APIRouter, BackgroundTasks, HTTPException, Request, status
from opentelemetry import trace
from tribe_ai.clients.analytics import analytics_client_registry
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.user import AvailableResponse, PatchUserRequest, UserProfile, UserRegistrationRequest
from src.app.enums import ProductAnalyticsEvent
from src.app.handlers.auth import LoggedInUser, hash_secret
from src.db import crud
from src.db.connect import DBSession
from src.db.crud.user import is_email_available, is_username_available
from src.logger import root_logger
from src.models import UserDTO
from src.settings import global_settings


log = root_logger.getChild(__name__)
tracer = trace.get_tracer(__name__)
router = APIRouter(prefix="/api/user", tags=["User"])


@router.get("/check_username")
async def check_username_available(db: DBSession, username: str) -> AvailableResponse:
    if not username:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Username is required")

    if not re.match(global_settings.app.validate_username_regex, username):
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Invalid username")

    return AvailableResponse(available=await is_username_available(db=db, username=username))


@router.post("/register", status_code=status.HTTP_201_CREATED, response_model_exclude_none=True)
async def register_user(
    db: DBSession, background_tasks: BackgroundTasks, registration_request: UserRegistrationRequest
) -> UserProfile:
    if not await is_email_available(db=db, email=registration_request.email):
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Email is already registered")

    if not await is_username_available(db=db, username=registration_request.username):
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Username is not available")

    password_hash = hash_secret(secret=registration_request.password.get_secret_value())
    user_dto = UserDTO(
        email_verified=False,
        password_hash=password_hash,
        **registration_request.model_dump(exclude={"password"}),
    )
    user_dto = await crud.user.create(db=db, user_dto=user_dto)

    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.USER_SIGNUP,
        **user_dto.get_analytics_properties(with_groups=True),
    )

    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    return UserProfile(**user_dto.model_dump())


# TODO: calculate and return costs incurred by user in /profile or separate endpoint
@router.get("/profile", response_model_exclude_none=True)
async def get_user_profile(user_dto: LoggedInUser) -> UserProfile:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.debug(f"Getting profile for user {user_dto.username}")
    return UserProfile(**user_dto.model_dump(exclude_none=True))


@router.patch(
    "/profile",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def update_user_profile(
    request: Request, db: DBSession, user_dto: LoggedInUser, user_patch_request: PatchUserRequest
) -> UserProfile:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.debug(f"Updating profile for user {user_dto.username}")
    updated_fields = user_patch_request.model_dump(mode="json", exclude_unset=True)
    updated_user = await crud.user.patch(db=db, uuid=user_dto.uuid, fields=updated_fields)
    return UserProfile(**updated_user.model_dump(exclude_none=True))


@router.delete(
    "/delete", description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit)
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def delete_user(request: Request, db: DBSession, user_dto: LoggedInUser) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Deleting user {user_dto.username}")
    user_uuid = user_dto.uuid
    await crud.user.delete(db=db, uuid=user_uuid)

    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.USER_SIGNUP,
        **user_dto.get_analytics_properties(),
    )


--- Start of backend/src/app/apis/endpoints/asset.py ---

import asyncio
from uuid import UUID

from fastapi import APIRouter, BackgroundTasks, HTTPException, UploadFile, status
from fastapi.responses import FileResponse, StreamingResponse
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.asset import (
    AssetCreateError,
    AssetReadResponse,
    AssetsCreateResponse,
    AssetsListResponse,
    SupportedFileExtensionsResponse,
)
from src.app.handlers.asset import create_asset, get_file_response, stream_video_file
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.conversation import validate_conversation_before_asset_create
from src.app.handlers.llm import get_supported_extensions_for_entity
from src.db import crud
from src.db.connect import DBSession
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AssetType


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/asset", tags=["Asset"])


@router.get("", response_model_exclude_none=True)
async def get_all_assets(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID | None = None
) -> AssetsListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    log.info(f"Getting all assets for user {user_dto.username}")
    assets_dto = await crud.asset.get_all_for_user(db=db, user_uuid=user_dto.uuid, conversation_uuid=conversation_uuid)
    return AssetsListResponse(items=[AssetReadResponse(**c.model_dump()) for c in assets_dto])


@router.post("")
async def create_assets(
    db: DBSession,
    user_dto: LoggedInUser,
    files: list[UploadFile],
    conversation_uuid: UUID | None = None,
) -> AssetsCreateResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    await validate_conversation_before_asset_create(db=db, user_dto=user_dto, conversation_uuid=conversation_uuid)
    log.info(f"Uploading assets for user {user_dto.username} and conversation {conversation_uuid}")
    asset_responses = await asyncio.gather(
        *[create_asset(file=file, user_dto=user_dto, conversation_uuid=conversation_uuid) for file in files]
    )
    assets = [a for a in asset_responses if isinstance(a, AssetReadResponse)]
    errors = [a for a in asset_responses if isinstance(a, AssetCreateError)]
    return AssetsCreateResponse(items=assets, errors=errors)


@router.get("/supported_extensions")
async def get_supported_extensions(
    db: DBSession,
    user_dto: LoggedInUser,
    agent_uuid: UUID | None = None,
    conversation_uuid: UUID | None = None,
    llm_model_id: str | None = None,
) -> SupportedFileExtensionsResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    if not agent_uuid and not conversation_uuid and not llm_model_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="One of agent_uuid, conversation_uuid, or llm_model_id is required",
        )

    if sum(bool(x) for x in [agent_uuid, conversation_uuid, llm_model_id]) > 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Only one of agent_uuid, conversation_uuid, or llm_model_id can be provided",
        )

    return await get_supported_extensions_for_entity(
        db=db, user_dto=user_dto, agent_uuid=agent_uuid, conversation_uuid=conversation_uuid, llm_model_id=llm_model_id
    )


@router.get("/download/{asset_uuid}")
async def download_asset_by_uuid(
    db: DBSession, user_dto: LoggedInUser, background_tasks: BackgroundTasks, asset_uuid: UUID
) -> FileResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Downloading asset {asset_uuid} for user {user_dto.username}")
    asset_dto = await crud.asset.get_by_uuid(db=db, uuid=asset_uuid)
    if not asset_dto:
        raise NotFoundError(entity="asset", by=["uuid"])

    if not asset_dto.user_uuid == user_dto.uuid:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to access this asset"
        )

    return await get_file_response(asset_dto=asset_dto, background_tasks=background_tasks)


@router.get("/video/{asset_uuid}")
async def serve_video(
    db: DBSession, user_dto: LoggedInUser, background_tasks: BackgroundTasks, asset_uuid: UUID
) -> StreamingResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    asset_dto = await crud.asset.get_by_uuid(db=db, uuid=asset_uuid)
    if not asset_dto:
        raise NotFoundError(entity="asset", by=["uuid"])

    if not asset_dto.user_uuid == user_dto.uuid:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to access this asset"
        )

    if not asset_dto.type == AssetType.VIDEO:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="This asset is not a video")

    return await stream_video_file(asset_dto=asset_dto, background_tasks=background_tasks)


@router.get("/{asset_uuid}", response_model_exclude_none=True)
async def get_asset_by_uuid(db: DBSession, user_dto: LoggedInUser, asset_uuid: UUID) -> AssetReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting asset {asset_uuid} for user {user_dto.username}")
    asset_dto = await crud.asset.get_by_uuid(db=db, uuid=asset_uuid)
    if not asset_dto:
        raise NotFoundError(entity="asset", by=["uuid"])

    return AssetReadResponse(**asset_dto.model_dump())


@router.delete("/{asset_uuid}")
async def delete_asset_by_uuid(db: DBSession, user_dto: LoggedInUser, asset_uuid: UUID) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Deleting asset {asset_uuid} for user {user_dto.username}")
    await crud.asset.delete_by_uuid(db=db, uuid=asset_uuid, user_uuid=user_dto.uuid)


--- Start of backend/src/app/apis/endpoints/health.py ---

from fastapi import APIRouter

from src.logger import root_logger


"""
Health and readiness check endpoints.
These endpoints are not mounted on /api to prevent public exposure.
"""


router = APIRouter(tags=["Health"])
log = root_logger.getChild(__name__)


@router.get("/health", include_in_schema=False)
async def health() -> dict[str, str]:
    """Placeholder for future health checks."""
    return {"status": "healthy"}


@router.get("/ready", include_in_schema=False)
async def ready() -> dict[str, str]:
    """Placeholder for future readiness checks."""
    return {"status": "ready"}


--- Start of backend/src/app/apis/endpoints/conversation.py ---

from uuid import UUID

from fastapi import APIRouter, HTTPException, Request, status
from tribe_ai.clients.analytics import analytics_client_registry
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.conversation import (
    ConversationHistoryResponse,
    ConversationListResponse,
    ConversationPatchRequest,
    ConversationReadResponse,
    ConversationStarterListResponse,
)
from src.app.enums import ProductAnalyticsEvent
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.conversation import generate_and_update_conversation_name, get_conversation_starters_for_user
from src.app.handlers.message import cast_message_dtos_to_read_response
from src.db import crud
from src.db.connect import DBSession
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/conversation", tags=["Conversation"])


@router.get("", response_model_exclude_none=True)
async def get_all_conversations(db: DBSession, user_dto: LoggedInUser) -> ConversationListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting all conversations for user {user_dto.username}")
    conversations_dto = await crud.conversation.get_all_for_user(db=db, user_dto=user_dto)
    return ConversationListResponse(items=[ConversationReadResponse(**c.model_dump()) for c in conversations_dto])


@router.post("", status_code=status.HTTP_201_CREATED, response_model_exclude_none=True)
async def get_or_create_new_conversation(db: DBSession, user_dto: LoggedInUser) -> ConversationReadResponse:
    log.info(f"Creating conversation for user {user_dto.username}")
    conversation_dto = await crud.conversation.get_or_create_new(db=db, user_dto=user_dto)
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_dto.uuid, code_path=__file__)
    return ConversationReadResponse(**conversation_dto.model_dump())


# NOTE: it seems this endpoint should be defined before the /{conversation_uuid} endpoint so it can be matched first
@router.get("/starters", response_model_exclude_none=True)
async def get_conversation_starters(
    db: DBSession,
    user_dto: LoggedInUser,
    dynamic: bool = True,
    num_starters: int = 4,
) -> ConversationStarterListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting conversation starters for user {user_dto.username}")
    starters = await get_conversation_starters_for_user(
        db=db, user_dto=user_dto, dynamic=dynamic, num_starters=num_starters
    )
    return ConversationStarterListResponse(items=starters)


@router.get("/{conversation_uuid}", response_model_exclude_none=True)
async def get_conversation_by_uuid(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID
) -> ConversationReadResponse:
    log.info(f"Getting conversation {conversation_uuid} for user {user_dto.username}")
    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        raise NotFoundError(entity="conversation", by=["uuid"])

    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    return ConversationReadResponse(**conversation_dto.model_dump())


@router.get("/{conversation_uuid}/history", response_model_exclude_none=True)
async def get_conversation_history(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID
) -> ConversationHistoryResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    log.info(f"Getting conversation history for conversation {conversation_uuid} for user {user_dto.username}")
    messages_dto = await crud.message.get_all_by_conversation_and_user_uuid(
        db=db, conversation_uuid=conversation_uuid, user_uuid=user_dto.uuid
    )
    # NOTE: if the agent should send an initial message, add it here
    message_responses = await cast_message_dtos_to_read_response(db=db, user_dto=user_dto, messages_dto=messages_dto)
    return ConversationHistoryResponse(items=message_responses)


@router.post(
    "/{conversation_uuid}/generate_name",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def generate_conversation_name(
    request: Request, db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID
) -> ConversationReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    log.info(f"Generating conversation name for conversation {conversation_uuid} for user {user_dto.username}")
    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        raise NotFoundError(entity="conversation", by=["uuid"])

    if conversation_dto.user_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User is not allowed to generate a name for this conversation")

    conversation_dto = await generate_and_update_conversation_name(db=db, conversation_dto=conversation_dto)
    return ConversationReadResponse(**conversation_dto.model_dump())


@router.patch("/{conversation_uuid}", response_model_exclude_none=True)
async def patch_conversation(
    db: DBSession, user_dto: LoggedInUser, patch_request: ConversationPatchRequest, conversation_uuid: UUID
) -> ConversationReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    log.info(f"Updating conversation {conversation_uuid} for user {user_dto.username}")
    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        raise NotFoundError(entity="conversation", by=["uuid"])

    if conversation_dto.user_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User is not allowed to update this conversation")

    if not patch_request.model_fields_set:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "No fields provided to update conversation")

    if patch_request.name:
        conversation_dto.name = patch_request.name

    conversation_dto = await crud.conversation.update(db=db, conversation_dto=conversation_dto)
    return ConversationReadResponse(**conversation_dto.model_dump())


@router.delete("/{conversation_uuid}")
async def delete_conversation(db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        raise NotFoundError(entity="conversation", by=["uuid"])

    if conversation_dto.user_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User is not allowed to delete this conversation")

    set_trace_attributes(session_uuid=conversation_uuid)
    log.info(f"Deleting conversation {conversation_uuid} for user {user_dto.username}")
    await crud.conversation.delete(db=db, uuid=conversation_uuid)

    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.CONVERSATION_DELETE,
        **user_dto.get_analytics_properties(),
    )


@router.post(
    "/delete_many", description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit)
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def delete_many_conversations(
    request: Request, db: DBSession, user_dto: LoggedInUser, conversation_uuids: list[UUID]
) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    all_owned = await crud.conversation.check_if_user_owns_conversations(
        db=db, user_uuid=user_dto.uuid, conversation_uuids=conversation_uuids
    )
    if not all_owned:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User is not allowed to delete some or all of the conversations")

    log.info(f"Deleting conversations {conversation_uuids} for user {user_dto.username}")
    await crud.conversation.delete_many(db=db, uuids=conversation_uuids)

    product_analytics_client = analytics_client_registry.get_or_create_instance(
        name="product", config=global_settings.analytics
    )
    await product_analytics_client.capture(
        event_type=ProductAnalyticsEvent.CONVERSATION_DELETE,
        **user_dto.get_analytics_properties(),
    )


--- Start of backend/src/app/apis/endpoints/feedback.py ---

from fastapi import APIRouter, Request, status
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.feedback import FeedbackCreate, FeedbackResponse
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.feedback import store_feedback
from src.db.connect import DBSession
from src.logger import root_logger
from src.models import FeedbackDTO, FeedbackTarget
from src.settings import global_settings


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/feedback", tags=["Feedback"])


@router.post(
    "",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model=FeedbackResponse,
    status_code=status.HTTP_201_CREATED,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def send_feedback(
    request: Request, db: DBSession, user_dto: LoggedInUser, feedback: FeedbackCreate
) -> FeedbackResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"User {user_dto.uuid} sent feedback (target={feedback.type})")
    target_uuid = {}
    if feedback.target == FeedbackTarget.AGENT:
        target_uuid = {"agent_uuid": feedback.target_uuid}
    elif feedback.target == FeedbackTarget.CONVERSATION:
        target_uuid = {"conversation_uuid": feedback.target_uuid}
        set_trace_attributes(session_uuid=feedback.target_uuid)
    elif feedback.target == FeedbackTarget.MESSAGE:
        target_uuid = {"message_uuid": feedback.target_uuid}
    elif feedback.target == FeedbackTarget.OUTPUT:
        target_uuid = {"asset_uuid": feedback.target_uuid}

    feedback_dto = FeedbackDTO(**feedback.model_dump(exclude={"target_uuid"}), **target_uuid)  # type: ignore
    feedback_dto = await store_feedback(db=db, feedback_dto=feedback_dto)
    return FeedbackResponse(**feedback_dto.model_dump())


--- Start of backend/src/app/apis/endpoints/__init__.py ---



--- Start of backend/src/app/apis/endpoints/llm.py ---

from uuid import UUID

from fastapi import APIRouter, HTTPException, status
from tribe_ai.clients.llm import llm_client_registry
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.llm import LLMInfo, LLMInfoListResponse
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.llm import generate_llm_info_responses
from src.app.utils.static_files import get_static_image_url_template
from src.db.connect import DBSession
from src.logger import root_logger


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/llm", tags=["LLMs"])


@router.get("", response_model_exclude_none=True)
async def get_available_llm_infos(
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID | None = None,
    agent_uuid: UUID | None = None,
    supports_audio: bool | None = None,
    supports_images: bool | None = None,
) -> LLMInfoListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    if conversation_uuid and (supports_audio is not None or supports_images is not None):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="provide either conversation_uuid or supports_audio/supports_images, not both",
        )

    llm_info_responses = await generate_llm_info_responses(
        db=db,
        user_dto=user_dto,
        conversation_uuid=conversation_uuid,
        agent_uuid=agent_uuid,
        supports_audio=supports_audio,
        supports_images=supports_images,
    )
    return LLMInfoListResponse(items=llm_info_responses)


@router.get("/{llm_model_id}", response_model_exclude_none=True)
async def get_llm_info_by_id(user_dto: LoggedInUser, llm_model_id: str) -> LLMInfo:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting llm model info for llm model id {llm_model_id}")
    try:
        llm_class = llm_client_registry.get_class(llm_model_id)
    except KeyError:
        raise HTTPException(
            status.HTTP_404_NOT_FOUND, detail=f"LLM info not found for model id {llm_model_id}"
        ) from None

    return llm_class.get_llm_info(provider_image_url_template=get_static_image_url_template())


--- Start of backend/src/app/apis/endpoints/message.py ---

from uuid import UUID

from fastapi import APIRouter, BackgroundTasks, HTTPException, Request, status
from sse_starlette.sse import EventSourceResponse
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes, tracer

from src.app.apis.models.message import MessageCreate, MessageReadResponse, MessageUpdate
from src.app.handlers.agent import build_agent_request, create_assets_from_output_files, get_agent_for_conversation
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.conversation import maybe_generate_and_update_conversation_name_in_background
from src.app.handlers.message import (
    get_and_prepare_conversation_before_regeneration,
    get_and_prepare_conversation_before_user_message_update,
    get_conversation_before_send_message,
)
from src.app.handlers.message_sse import sse_message_generator
from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.search.update.message import update_message_search_index
from src.settings import global_settings


log = root_logger.getChild(__name__)
trace = tracer.get_tracer(__name__)
router = APIRouter(prefix="/api/message", tags=["Message"])
streaming_endpoint_description = (
    "SSE Event Stream of MessageReadResponse objects where the content "
    "and/or status fields are updated with each message"
    f"({rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit)})"
)


@router.post(
    "",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.message_post_rate_limit)
async def send_message_and_receive_generated_response(
    request: Request,
    background_tasks: BackgroundTasks,
    db: DBSession,
    user_dto: LoggedInUser,
    message_create: MessageCreate,
    conversation_uuid: UUID | None = None,
) -> MessageReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    conversation_dto = await get_conversation_before_send_message(
        db=db, user_dto=user_dto, conversation_uuid=conversation_uuid
    )
    set_trace_attributes(session_uuid=conversation_uuid)
    conversation_dto = await crud.message.add_user_message_to_conversation(
        db=db,
        conversation_dto=conversation_dto,
        user_uuid=user_dto.uuid,
        content=message_create.content,
        asset_uuids=message_create.asset_uuids,
    )

    agent = await get_agent_for_conversation(
        db=db, conversation_dto=conversation_dto, agent_config_uuid=message_create.agent_config_uuid
    )
    agent_request = await build_agent_request(conversation_dto=conversation_dto)

    with trace.start_as_current_span(
        "agent_response",
        attributes={
            "agent_name": agent.name,
            "agent_uuid": str(agent.uuid),
            "agent_config_uuid": str(agent.config.uuid),
        },
    ):
        agent_response = await agent.respond(agent_request=agent_request)

    agent_message_dto = await crud.message.create_agent_message(
        db=db,
        conversation_uuid=conversation_dto.uuid,
        agent_uuid=agent.uuid,
        agent_config_uuid=agent.config.uuid,
        user_uuid=user_dto.uuid,
        agent_response=agent_response,
    )
    if agent_response.tool_use_response:
        await create_assets_from_output_files(
            db=db,
            tool_use_response=agent_response.tool_use_response,
            user_uuid=user_dto.uuid,
            agent_uuid=agent.uuid,
            conversation_uuid=conversation_dto.uuid,
            message_uuid=agent_message_dto.uuid,
        )

    conversation_name = await maybe_generate_and_update_conversation_name_in_background(
        conversation_dto=conversation_dto, background_tasks=background_tasks
    )

    return MessageReadResponse(
        **agent_message_dto.model_dump(exclude={"tool_use_response"}),
        author_name=agent.name,
        conversation_name_updated_streaming=conversation_name,
        tool_use_response=agent_response.tool_use_response,
    )


@router.post(
    "/streaming",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit),
    responses={200: {"content": {"text/event-stream": {}}, "description": streaming_endpoint_description}},
)
@rate_limiter.limit(global_settings.app.message_post_rate_limit)
async def send_message_and_receive_generated_agent_response_streaming(
    request: Request,
    background_tasks: BackgroundTasks,
    db: DBSession,
    user_dto: LoggedInUser,
    message_create: MessageCreate,
    conversation_uuid: UUID | None = None,
) -> EventSourceResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    with trace.start_as_current_span("data_preparation"):
        conversation_dto = await get_conversation_before_send_message(
            db=db, user_dto=user_dto, conversation_uuid=conversation_uuid
        )
        set_trace_attributes(session_uuid=conversation_uuid)
        conversation_dto = await crud.message.add_user_message_to_conversation(
            db=db,
            conversation_dto=conversation_dto,
            user_uuid=user_dto.uuid,
            content=message_create.content,
            asset_uuids=message_create.asset_uuids,
        )

        agent = await get_agent_for_conversation(
            db=db, conversation_dto=conversation_dto, agent_config_uuid=message_create.agent_config_uuid
        )

        agent_message_dto = await crud.message.create_agent_message(
            db=db,
            conversation_uuid=conversation_dto.uuid,
            agent_uuid=agent.uuid,
            agent_config_uuid=agent.config.uuid,
            user_uuid=user_dto.uuid,
        )
        await update_message_search_index(messages_dto=[agent_message_dto], user_uuid=user_dto.uuid)
        message_response = MessageReadResponse(**agent_message_dto.model_dump(), author_name=agent.name)
        agent_request = await build_agent_request(conversation_dto=conversation_dto)

    agent_response_stream = agent.respond_streaming(agent_request=agent_request)
    sse_generator = sse_message_generator(
        db=db,
        background_tasks=background_tasks,
        request=request,
        agent_response_generator=agent_response_stream,
        message_response=message_response,
        message_dto=agent_message_dto,
        conversation_dto=conversation_dto,
        user_uuid=user_dto.uuid,
    )
    return EventSourceResponse(content=sse_generator, send_timeout=10)


@router.get(
    "/regenerate",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.message_post_rate_limit)
async def regenerate_agent_message(
    request: Request,
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID,
    message_uuid: UUID | None = None,
) -> MessageReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    with trace.start_as_current_span("data_preparation"):
        conversation_dto = await get_and_prepare_conversation_before_regeneration(
            db=db, user_dto=user_dto, conversation_uuid=conversation_uuid, message_uuid=message_uuid
        )
        set_trace_attributes(session_uuid=conversation_uuid)
        if conversation_dto.user_uuid != user_dto.uuid:
            raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not have permission to edit this message")

        agent = await get_agent_for_conversation(db=db, conversation_dto=conversation_dto, caching=False)
        agent_request = await build_agent_request(conversation_dto=conversation_dto)

    with trace.start_as_current_span(
        "agent_response",
        attributes={
            "agent_name": agent.name,
            "agent_uuid": str(agent.uuid),
            "agent_config_uuid": str(agent.config.uuid),
        },
    ):
        agent_response = await agent.respond(agent_request=agent_request)

    with trace.start_as_current_span("data_persistence"):
        agent_message_dto = await crud.message.create_agent_message(
            db=db,
            conversation_uuid=conversation_uuid,
            agent_uuid=agent.uuid,
            agent_config_uuid=agent.config.uuid,
            user_uuid=user_dto.uuid,
            agent_response=agent_response,
        )
        if agent_response.tool_use_response:
            await create_assets_from_output_files(
                db=db,
                tool_use_response=agent_response.tool_use_response,
                user_uuid=user_dto.uuid,
                agent_uuid=agent.uuid,
                conversation_uuid=conversation_dto.uuid,
                message_uuid=agent_message_dto.uuid,
            )
        await update_message_search_index(messages_dto=[agent_message_dto], user_uuid=user_dto.uuid)

    return MessageReadResponse(
        **agent_message_dto.model_dump(exclude={"tool_use_response"}),
        author_name=agent.name,
        tool_use_response=agent_response.tool_use_response,
    )


@router.get(
    "/regenerate/streaming",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit),
    responses={200: {"content": {"text/event-stream": {}}, "description": streaming_endpoint_description}},
)
@rate_limiter.limit(global_settings.app.message_post_rate_limit)
async def regenerate_agent_message_streaming(
    request: Request,
    background_tasks: BackgroundTasks,
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID,
    message_uuid: UUID | None = None,
) -> EventSourceResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    with trace.start_as_current_span("data_preparation"):
        conversation_dto = await get_and_prepare_conversation_before_regeneration(
            db=db, user_dto=user_dto, conversation_uuid=conversation_uuid, message_uuid=message_uuid
        )
        set_trace_attributes(session_uuid=conversation_uuid)

        agent = await get_agent_for_conversation(db=db, conversation_dto=conversation_dto, caching=False)

        message_dto = await crud.message.create_agent_message(
            db=db,
            conversation_uuid=conversation_uuid,
            agent_uuid=agent.uuid,
            agent_config_uuid=agent.config.uuid,
            user_uuid=user_dto.uuid,
        )
        message_response = MessageReadResponse(**message_dto.model_dump(), author_name=agent.name)

        agent_request = await build_agent_request(conversation_dto=conversation_dto)

    agent_response_stream = agent.respond_streaming(agent_request=agent_request)
    sse_generator = sse_message_generator(
        db=db,
        background_tasks=background_tasks,
        request=request,
        agent_response_generator=agent_response_stream,
        message_response=message_response,
        message_dto=message_dto,
        conversation_dto=conversation_dto,
        user_uuid=user_dto.uuid,
    )
    return EventSourceResponse(content=sse_generator, send_timeout=10)


@router.patch(
    "/{message_uuid}",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.message_post_rate_limit)
async def patch_user_message(
    request: Request,
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID,
    message_uuid: UUID,
    message_update: MessageUpdate,
) -> MessageReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    with trace.start_as_current_span("data_preparation"):
        conversation_dto = await get_and_prepare_conversation_before_user_message_update(
            db=db,
            user_dto=user_dto,
            conversation_uuid=conversation_uuid,
            message_uuid=message_uuid,
            message_update=message_update,
        )
        if conversation_dto.user_uuid != user_dto.uuid:
            raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not have permission to edit this message")

        set_trace_attributes(session_uuid=conversation_uuid)

        agent = await get_agent_for_conversation(db=db, conversation_dto=conversation_dto)
        agent_request = await build_agent_request(conversation_dto=conversation_dto)

    with trace.start_as_current_span(
        "agent_response",
        attributes={
            "agent_name": agent.name,
            "agent_uuid": str(agent.uuid),
            "agent_config_uuid": str(agent.config.uuid),
        },
    ):
        agent_response = await agent.respond(agent_request=agent_request)

    with trace.start_as_current_span("data_persistence"):
        agent_message_dto = await crud.message.create_agent_message(
            db=db,
            conversation_uuid=conversation_uuid,
            agent_uuid=agent.uuid,
            agent_config_uuid=agent.config.uuid,
            user_uuid=user_dto.uuid,
            agent_response=agent_response,
        )
        if agent_response.tool_use_response:
            await create_assets_from_output_files(
                db=db,
                tool_use_response=agent_response.tool_use_response,
                user_uuid=user_dto.uuid,
                agent_uuid=agent.uuid,
                conversation_uuid=conversation_dto.uuid,
                message_uuid=agent_message_dto.uuid,
            )

        await update_message_search_index(messages_dto=[agent_message_dto], user_uuid=user_dto.uuid)

    return MessageReadResponse(
        **agent_message_dto.model_dump(exclude={"tool_use_response"}),
        author_name=agent.name,
        tool_use_response=agent_response.tool_use_response,
    )


@router.patch(
    "/{message_uuid}/streaming",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.message_post_rate_limit),
    responses={200: {"content": {"text/event-stream": {}}, "description": streaming_endpoint_description}},
)
@rate_limiter.limit(global_settings.app.message_post_rate_limit)
async def patch_user_message_streaming(
    request: Request,
    background_tasks: BackgroundTasks,
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID,
    message_uuid: UUID,
    message_update: MessageUpdate,
) -> EventSourceResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    with trace.start_as_current_span("data_preparation"):
        conversation_dto = await get_and_prepare_conversation_before_user_message_update(
            db=db,
            user_dto=user_dto,
            conversation_uuid=conversation_uuid,
            message_uuid=message_uuid,
            message_update=message_update,
        )
        if conversation_dto.user_uuid != user_dto.uuid:
            raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not have permission to edit this message")

        set_trace_attributes(session_uuid=conversation_uuid)

        agent = await get_agent_for_conversation(db=db, conversation_dto=conversation_dto)

        message_dto = await crud.message.create_agent_message(
            db=db,
            conversation_uuid=conversation_uuid,
            agent_uuid=agent.uuid,
            agent_config_uuid=agent.config.uuid,
            user_uuid=user_dto.uuid,
        )
        message_response = MessageReadResponse(**message_dto.model_dump(), author_name=agent.name)

        agent_request = await build_agent_request(conversation_dto=conversation_dto)

    agent_response_stream = agent.respond_streaming(agent_request=agent_request)
    sse_generator = sse_message_generator(
        db=db,
        background_tasks=background_tasks,
        request=request,
        agent_response_generator=agent_response_stream,
        message_response=message_response,
        message_dto=message_dto,
        conversation_dto=conversation_dto,
        user_uuid=user_dto.uuid,
    )
    return EventSourceResponse(content=sse_generator, send_timeout=10)


--- Start of backend/src/app/apis/endpoints/agent.py ---

from uuid import UUID

from fastapi import APIRouter, HTTPException, Request, status
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.agent import AgentCreate, AgentReadResponse, AgentsListResponse, AgentUpdate
from src.app.apis.models.agent_config import (
    AgentConfigCreate,
    AgentConfigCreateFromExisting,
    AgentConfigDTO,
    AgentConfigReadResponse,
    AgentConfigsListResponse,
)
from src.app.apis.models.asset import AssetReadResponse
from src.app.handlers.agent import (
    create_agent,
    create_agent_config_from_existing_or_update,
    create_agent_from_existing_agent,
)
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.tool import validate_tool_options
from src.db import crud
from src.db.connect import DBSession
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AgentConfigStatus
from src.settings import global_settings


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/agent", tags=["Agent"])


@router.get("", response_model_exclude_none=True)
async def get_all_agents(db: DBSession, user_dto: LoggedInUser) -> AgentsListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting all agents for user {user_dto.username}")
    agents_dto = await crud.agent.get_all(db=db)
    agents_dto = [a for a in agents_dto if a.is_public or a.owner_uuid == user_dto.uuid]
    return AgentsListResponse(items=[AgentReadResponse(**c.model_dump()) for c in agents_dto])


@router.get("/{agent_uuid}", response_model_exclude_none=True)
async def get_agent_by_uuid(db: DBSession, user_dto: LoggedInUser, agent_uuid: UUID) -> AgentReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting agent {agent_uuid} for user {user_dto.username}")
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    if not agent_dto.is_public and agent_dto.owner_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Agent is not public and user does not own this agent")

    return AgentReadResponse(**agent_dto.model_dump())


@router.post("", response_model_exclude_none=True)
async def create_new_agent(db: DBSession, user_dto: LoggedInUser, agent_create: AgentCreate) -> AgentReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Creating agent for user {user_dto.username}")
    agent_dto = await create_agent(db=db, user_dto=user_dto, agent_create=agent_create)
    return AgentReadResponse(**agent_dto.model_dump())


@router.post(
    "/{agent_uuid}/clone",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def create_agent_from_existing(
    request: Request, db: DBSession, user_dto: LoggedInUser, agent_uuid: UUID
) -> AgentReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    new_agent_dto = await create_agent_from_existing_agent(db=db, user_dto=user_dto, agent_dto=agent_dto)
    return AgentReadResponse(**new_agent_dto.model_dump())


@router.patch(
    "/{agent_uuid}",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def update_agent_by_uuid(
    request: Request,
    db: DBSession,
    user_dto: LoggedInUser,
    agent_uuid: UUID,
    agent_patch_request: AgentUpdate,
) -> AgentReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Updating agent {agent_uuid} for user {user_dto.username}")
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    if agent_dto.owner_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not own this agent")

    updated_fields = agent_patch_request.model_dump(mode="json", exclude_unset=True)
    updated_agent = await crud.agent.patch(db=db, uuid=agent_uuid, fields=updated_fields)
    assets = [AssetReadResponse(**a.model_dump()) for a in updated_agent.assets]
    return AgentReadResponse(**updated_agent.model_dump(exclude={"assets"}), assets=assets)


@router.delete(
    "/{agent_uuid}",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def delete_agent_by_uuid(request: Request, db: DBSession, user_dto: LoggedInUser, agent_uuid: UUID) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Deleting agent {agent_uuid} for user {user_dto.username}")
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    if agent_dto.owner_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not own this agent")

    if agent_uuid == global_settings.agents.default_agent_uuid:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Cannot delete global default agent")

    await crud.agent.delete(db=db, uuid=agent_uuid)
    if user_dto.default_conversation_settings.agent_uuid == agent_uuid:
        user_dto.default_conversation_settings.agent_uuid = global_settings.agents.default_agent_uuid
        await crud.user.patch(
            db=db,
            uuid=user_dto.uuid,
            fields={"default_conversation_settings": user_dto.default_conversation_settings.model_dump(mode="json")},
        )


@router.get("/{agent_uuid}/config", response_model_exclude_none=True)
async def get_all_agent_configs(db: DBSession, user_dto: LoggedInUser, agent_uuid: UUID) -> AgentConfigsListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting all agent configs for agent {agent_uuid} for user {user_dto.username}")
    agent_configs_dto = await crud.agent_config.get_all_by_agent_uuid(db=db, agent_uuid=agent_uuid)
    return AgentConfigsListResponse(items=[AgentConfigReadResponse(**c.model_dump()) for c in agent_configs_dto])


@router.get("/{agent_uuid}/config/{config_uuid}", response_model_exclude_none=True)
async def get_agent_config_by_uuid(
    db: DBSession, user_dto: LoggedInUser, agent_uuid: UUID, config_uuid: UUID
) -> AgentConfigReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Getting agent config {config_uuid} for agent {agent_uuid} for user {user_dto.username}")
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    if not agent_dto.is_public or agent_dto.owner_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Agent is not public and user does not own this agent")

    agent_config_dto = await crud.agent_config.get_by_uuid_and_agent_uuid(
        db=db, uuid=config_uuid, agent_uuid=agent_uuid
    )
    if not agent_config_dto:
        raise NotFoundError(entity="agent_config", by=["uuid", "agent_uuid"])

    return AgentConfigReadResponse(**agent_config_dto.model_dump())


@router.post(
    "/{agent_uuid}/config",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def create_agent_config(
    request: Request,
    db: DBSession,
    user_dto: LoggedInUser,
    agent_uuid: UUID,
    agent_config: AgentConfigCreate,
) -> AgentConfigReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(f"Creating agent config for agent {agent_uuid} for user {user_dto.username}")
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    if agent_dto.owner_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not own this agent")

    if agent_config.tools:
        try:
            validate_tool_options(agent_config.tools)
        except Exception as e:
            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Invalid tool options") from e

    should_make_active = agent_config.is_active
    agent_config_dto = AgentConfigDTO(
        **agent_config.model_dump(exclude_unset=True, exclude={"is_active"}),
        status=AgentConfigStatus.ACTIVE if should_make_active else AgentConfigStatus.INACTIVE,
        # NOTE: version is set to correct (autoincremented) value in the .add_new_config method
        version=1,
        agent_uuid=agent_uuid,
        agent_class="ToolUserAgent",
    )

    agent_config_dto = await crud.agent_config.create(db=db, agent_config_dto=agent_config_dto)
    agent_dto.add_new_config(agent_config_dto)
    if should_make_active:
        agent_dto.set_active_config(agent_config_dto.uuid)

    await crud.agent.update(db=db, agent_dto=agent_dto)

    return AgentConfigReadResponse(**agent_config_dto.model_dump())


@router.put(
    "/{agent_uuid}/config/{agent_config_uuid}",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def create_agent_config_from_existing(
    request: Request,
    db: DBSession,
    user_dto: LoggedInUser,
    agent_uuid: UUID,
    agent_config_uuid: UUID,
    agent_config_values: AgentConfigCreateFromExisting,
) -> AgentConfigReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info(
        f"Creating or updating agent config for agent {agent_uuid} with config {agent_config_uuid} for user {user_dto.username}"
    )
    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
    if not agent_dto:
        raise NotFoundError(entity="agent", by=["uuid"])

    existing_agent_config_dto = next((c for c in agent_dto.agent_configs if c.uuid == agent_config_uuid), None)
    if not existing_agent_config_dto:
        log.error(f"No existing agent config found for config {agent_config_uuid}")
        raise NotFoundError(entity="agent_config", by=["uuid", "agent_uuid"])

    if agent_config_values.tools:
        try:
            validate_tool_options(agent_config_values.tools)
        except Exception as e:
            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Invalid tool options") from e

    updated_agent_config_dto = await create_agent_config_from_existing_or_update(
        db=db,
        agent_dto=agent_dto,
        existing_agent_config_dto=existing_agent_config_dto,
        agent_config_values=agent_config_values,
    )
    return AgentConfigReadResponse(**updated_agent_config_dto.model_dump())


--- Start of backend/src/app/apis/endpoints/search.py ---

from fastapi import APIRouter, HTTPException, Query, Request
from tribe_ai.common.app.utils.rate_limiter import rate_limited_api_description, rate_limiter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.search import (
    SearchHistoryResponse,
    SearchRequest,
    SearchResultsResponse,
)
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.search import execute_search_query, rebuild_search_indices_from_db, store_search_query
from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/search", tags=["Search"])


@router.post("", response_model_exclude_none=True)
async def search(db: DBSession, user_dto: LoggedInUser, search_request: SearchRequest) -> SearchResultsResponse:
    await store_search_query(db=db, user_dto=user_dto, query=search_request.query)
    return await execute_search_query(db=db, user_dto=user_dto, search_request=search_request)


@router.get(
    "/history",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def get_search_history(
    request: Request,
    user_dto: LoggedInUser,
    prefix: str | None = Query(None, min_length=1),
    page: int = Query(1, ge=1),
    page_size: int = Query(10, ge=1),
) -> SearchHistoryResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    query_logs = user_dto.search_history
    if prefix:
        query_logs = [query_log for query_log in query_logs if query_log.query.startswith(prefix)]

    query_logs = query_logs[(page - 1) * page_size : page * page_size]
    return SearchHistoryResponse(queries=[log.query for log in query_logs])


@router.delete(
    "/history",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def delete_query_from_search_history(request: Request, db: DBSession, user_dto: LoggedInUser, query: str) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.debug(f"Deleting search query for user {user_dto.uuid}")
    user_dto.search_history = [log for log in user_dto.search_history if log.query != query]
    await crud.user.update(db=db, user_dto=user_dto)


@router.post("/rebuild-index", response_model_exclude_none=True)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def rebuild_search_indices(
    request: Request, db: DBSession, user_dto: LoggedInUser, index_name: str | None = None
) -> None:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    if not user_dto.is_admin:
        raise HTTPException(status_code=403, detail="Only admins can rebuild search indices")

    log.info(f"Rebuilding search index for user {user_dto.uuid}")
    await rebuild_search_indices_from_db(db=db, index_name=index_name)


--- Start of backend/src/app/apis/endpoints/tool.py ---

from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Any
from uuid import UUID

from fastapi import APIRouter, HTTPException, Request
from pydantic import ValidationError
from tribe_ai.clients.llm import ToolCall
from tribe_ai.common.app.utils.rate_limiter import (
    rate_limited_api_description,
    rate_limiter,
)
from tribe_ai.common.tracing import set_trace_attributes
from tribe_ai.services.agents.tools import ToolOutputFormatting, ToolUseInfo, ToolUseRequest, tool_registry

from src.agents.tools.rag.document import DocumentRAG
from src.app.apis.models.tool import ToolReadResponse, ToolsListResponse
from src.app.handlers.auth import LoggedInUser
from src.app.handlers.tool import generate_tool_responses
from src.db import crud
from src.db.connect import DBSession
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/tool", tags=["Tool"])


@router.get("", response_model_exclude_none=True)
async def get_all_tools(user_dto: LoggedInUser) -> ToolsListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    log.info("Getting all tools available")
    return ToolsListResponse(items=generate_tool_responses())


@router.get("/{tool_registry_id}", response_model_exclude_none=True)
async def get_tool_by_id(user_dto: LoggedInUser, tool_registry_id: str) -> ToolReadResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, code_path=__file__)
    tool_response = generate_tool_responses(tool_ids=[tool_registry_id])
    if not tool_response:
        raise NotFoundError(entity="tool", by=["tool_registry_id"])

    return tool_response[0]


# TODO: make run_tool endpoint better
@router.post(
    "/{tool_registry_id}",
    description=rate_limited_api_description.format(rate_limit=global_settings.app.default_rate_limit),
    response_model_exclude_none=True,
)
@rate_limiter.limit(global_settings.app.default_rate_limit)
async def run_tool(
    request: Request,
    db: DBSession,
    user_dto: LoggedInUser,
    tool_registry_id: str,
    tool_inputs: dict[str, Any],
    tool_options: dict[str, Any] | None = None,
    agent_uuid: UUID | None = None,
    conversation_uuid: UUID | None = None,
) -> dict:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    tool_class = tool_registry.get_class(tool_registry_id)
    options = None
    if tool_options and tool_class.options_class:
        try:
            options = tool_class.options_class(**tool_options)
        except ValidationError as e:
            raise HTTPException(status_code=422, detail=e.errors()) from None

    try:
        tool = tool_registry.create_instance(tool_registry_id, **({"options": options} if options else {}))
    except KeyError:
        raise NotFoundError(entity="tool", by=["tool_registry_id"]) from None

    if isinstance(tool, DocumentRAG):
        agent_dto = None
        conversation_dto = None
        if agent_uuid:
            agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)

        if conversation_uuid:
            conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)

        if agent_uuid or conversation_uuid:
            tool.update_instructions_with_available_assets(agent_dto=agent_dto, conversation_dto=conversation_dto)

    log.info(f"Running tool {tool_registry_id} for user {user_dto.username} with inputs: {tool_inputs}")
    try:
        inputs = tool.inputs_class(**tool_inputs)
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=e.errors()) from None

    mock_tool_use_info = ToolUseInfo(
        name=tool.name,
        display_name=tool.display_name,
        description=tool.description,
        instructions=tool.tool_instructions,
        inputs=inputs.model_dump(mode="json"),
    )
    with TemporaryDirectory() as temp_context_dir:
        temp_context_dir_path = Path(temp_context_dir)
        mock_tool_use_request = ToolUseRequest(
            tool_calls=[ToolCall(id="test", name=tool.name, inputs_json=inputs.model_dump_json())],
            context_dir=temp_context_dir_path,
        )
        tool_outputs, tool_use_info = await tool.use(
            inputs=inputs, tool_use_info=mock_tool_use_info, tool_use_request=mock_tool_use_request
        )
        if tool_outputs:
            tool_use_info.output_text = tool_outputs.display_to_llm(
                # TODO: should be updated to ToolOutputFormatting.CUSTOM when all tools implement the custom render
                tool_name=tool.display_name,
                inputs=inputs,
                formatting=ToolOutputFormatting.JSON,
            )

    tool_use_info.outputs = tool_outputs.model_dump(mode="json") if tool_outputs else None
    return tool_use_info.model_dump(mode="json")


--- Start of backend/src/app/apis/endpoints/audit_log.py ---

from uuid import UUID

from fastapi import APIRouter
from tribe_ai.common.tracing import set_trace_attributes

from src.app.apis.models.audit_log import AuditLogReadResponse, AuditLogsListResponse
from src.app.handlers.auth import LoggedInUser
from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger


log = root_logger.getChild(__name__)
router = APIRouter(prefix="/api/audit_log", tags=["AuditLog"])


@router.get("", response_model_exclude_none=True)
async def get_all_audit_logs(
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID | None = None,
    asset_uuid: UUID | None = None,
    message_uuid: UUID | None = None,
) -> AuditLogsListResponse:
    set_trace_attributes(user_uuid=user_dto.uuid, session_uuid=conversation_uuid, code_path=__file__)
    filters = {}
    if asset_uuid:
        filters["asset_uuid"] = asset_uuid

    if conversation_uuid:
        filters["conversation_uuid"] = conversation_uuid

    if message_uuid:
        filters["message_uuid"] = message_uuid

    audit_logs_dto = await crud.audit_log.get_all(db=db, user_uuid=user_dto.uuid, filters=filters)
    return AuditLogsListResponse(items=[AuditLogReadResponse(**c.model_dump()) for c in audit_logs_dto])


--- Start of backend/src/app/apis/models/auth.py ---

from pydantic import BaseModel, EmailStr, SecretStr
from tribe_ai.clients.authentication.models import SessionToken


class SessionTokenResponse(SessionToken):
    email: EmailStr


class LoginRequest(BaseModel):
    email: EmailStr
    password: SecretStr


class RefreshTokenRequest(BaseModel):
    email: EmailStr
    token: str


--- Start of backend/src/app/apis/models/user.py ---

from uuid import UUID

from pydantic import BaseModel, ConfigDict, EmailStr, Field, SecretStr, field_validator

from src.logger import root_logger
from src.models import DefaultConversationSettings, UserAppSettings
from src.settings import global_settings


log = root_logger.getChild(__name__)


class AvailableResponse(BaseModel):
    available: bool


class UserRegistrationRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_-]{3,50}$", examples=["user_name"])
    email: EmailStr
    password: SecretStr = Field(..., min_length=8)

    given_name: str | None = None
    family_name: str | None = None
    description: str | None = None
    image_url: str | None = None

    country: str | None = None
    locale: str | None = None
    timezone: str | None = None
    language_code: str | None = None

    @field_validator("email", mode="before")
    @classmethod
    def validate_email(cls, v: str) -> str:
        if not any(v.endswith(domain) for domain in global_settings.auth.allowed_email_domains):
            raise ValueError("Email domain is not allowed")

        return v

    # NOTE: these password strength validation rules require lookaheads in the regex
    #       which are not allowed in pydantic at the moment, hence not set in the Field(pattern=...)
    @field_validator("password", mode="before")
    @classmethod
    def validate_password(cls, v: str) -> str:
        if global_settings.auth.disable_password_strength_validation:
            log.warning("Password validation is disabled, not checking password strength")
            return v

        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")

        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain at least one uppercase letter")

        if not any(c.islower() for c in v):
            raise ValueError("Password must contain at least one lowercase letter")

        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain at least one number")

        return v


class UserProfile(BaseModel):
    uuid: UUID

    username: str
    email: EmailStr

    given_name: str | None = None
    family_name: str | None = None
    description: str | None = None
    image_url: str | None = None

    country: str | None = None
    locale: str | None = None
    timezone: str | None = None
    language_code: str | None = None

    app_settings: UserAppSettings = UserAppSettings()
    default_conversation_settings: DefaultConversationSettings = DefaultConversationSettings()

    model_config = ConfigDict(extra="ignore")


class PatchUserRequest(BaseModel):
    given_name: str | None = None
    family_name: str | None = None
    description: str | None = None
    image_url: str | None = None

    country: str | None = None
    locale: str | None = None
    timezone: str | None = None
    language_code: str | None = None

    app_settings: UserAppSettings | None = None
    default_conversation_settings: DefaultConversationSettings | None = None


--- Start of backend/src/app/apis/models/asset.py ---

from typing import Self
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, ConfigDict, model_validator
from tribe_ai.services.ingestion import IngestionErrorLog, IngestionMetadata, IngestionStatus, IngestionStepLog

from src.models import AssetType
from src.settings import global_settings


def get_source_url_for_asset(uuid: UUID) -> str | None:
    host_url = str(global_settings.app.host_url).rstrip("/")
    return f"{host_url}/api/asset/download/{uuid}"


class AssetReadResponse(BaseModel):
    uuid: UUID
    created_at: AwareDatetime
    type: AssetType
    name: str
    description: str | None = None

    # file metadata
    original_filename: str
    source_url: str | None = None

    # ingestion
    ingestion_status: IngestionStatus | None = None
    ingestion_error_log: IngestionErrorLog | None = None
    ingestion_metadata: IngestionMetadata | None = None
    ingestion_step_logs: list[IngestionStepLog] | None = None

    # foreign keys
    agent_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID

    model_config = ConfigDict(extra="ignore")

    @model_validator(mode="after")
    def set_source_url(self) -> Self:
        if not self.source_url:
            self.source_url = get_source_url_for_asset(self.uuid)

        return self


class AssetsListResponse(BaseModel):
    items: list[AssetReadResponse]


class AssetCreateError(BaseModel):
    original_filename: str
    error: str
    error_log: str | None = None


class AssetsCreateResponse(BaseModel):
    items: list[AssetReadResponse]
    errors: list[AssetCreateError]


class SupportedFileExtensionsResponse(BaseModel):
    all: list[str]
    audio: list[str]
    document: list[str]
    image: list[str]
    text: list[str]


--- Start of backend/src/app/apis/models/conversation.py ---

from uuid import UUID

from pydantic import AwareDatetime, BaseModel
from tribe_ai.services.llm_functions import ConversationStarter

from src.app.apis.models.message import MessageReadResponse


class ConversationReadResponse(BaseModel):
    uuid: UUID
    name: str
    created_at: AwareDatetime
    updated_at: AwareDatetime | None = None

    model_config = {"extra": "allow"}


class ConversationPatchRequest(BaseModel):
    name: str | None = None


class ConversationListResponse(BaseModel):
    items: list[ConversationReadResponse]


class ConversationStarterListResponse(BaseModel):
    items: list[ConversationStarter]


class ConversationHistoryResponse(BaseModel):
    items: list[MessageReadResponse]


--- Start of backend/src/app/apis/models/feedback.py ---

from typing import Self
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, Field, model_validator

from src.models import FeedbackRating, FeedbackTarget, FeedbackType


class FeedbackCreate(BaseModel):
    feedback: str = Field(..., min_length=1)
    target: FeedbackTarget
    type: FeedbackType
    url: str | None = Field(None, description="Required for application feedback, optional for all others")
    rating: FeedbackRating | None = None
    user_uuid: UUID
    target_uuid: UUID | None = Field(None, description="Optional for application feedback, required for all others")

    @model_validator(mode="after")
    def check_url(self) -> Self:
        if self.target == FeedbackTarget.APPLICATION and self.url is None:
            raise ValueError("url is required for application feedback")

        return self

    @model_validator(mode="after")
    def check_target_uuid(self) -> Self:
        if self.target != FeedbackTarget.APPLICATION and self.target_uuid is None:
            raise ValueError("target_uuid is required for all feedback types except application")

        return self


class FeedbackResponse(BaseModel):
    uuid: UUID
    created_at: AwareDatetime
    updated_at: AwareDatetime | None = None

    feedback: str
    target: FeedbackTarget
    type: FeedbackType
    url: str | None = None
    rating: FeedbackRating | None = None

    user_uuid: UUID
    agent_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    asset_uuid: UUID | None = None

    model_config = {"extra": "allow"}


--- Start of backend/src/app/apis/models/__init__.py ---



--- Start of backend/src/app/apis/models/llm.py ---

from enum import StrEnum

from pydantic import BaseModel
from tribe_ai.clients.llm.models.info import LLMInfo


class LLMNotSelectableReason(StrEnum):
    AUDIO_NOT_SUPPORTED = "audio_not_supported"
    IMAGES_NOT_SUPPORTED = "images_not_supported"
    BOTH_AUDIO_AND_IMAGES_NOT_SUPPORTED = "both_audio_and_images_not_supported"


class LLMInfoResponse(LLMInfo):
    selected: bool = False
    selectable: bool = True
    not_selectable_reason: LLMNotSelectableReason | None = None


class LLMInfoListResponse(BaseModel):
    items: list[LLMInfoResponse]


--- Start of backend/src/app/apis/models/message.py ---

from typing import Self
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, Field, computed_field, model_validator
from tribe_ai.clients.llm import GenerationMetadata
from tribe_ai.services.agents.tools.models.use import ToolUseResponse

from src.app.apis.models.asset import AssetReadResponse
from src.logger import root_logger
from src.models import MessageRole, MessageStatus, MessageType


log = root_logger.getChild(__name__)


class MessageCreate(BaseModel):
    content: str = Field(..., min_length=1, examples=["Hello, world!"])
    asset_uuids: list[UUID] | None = None
    agent_config_uuid: UUID | None = Field(None, description="If not passed, the currently active config will be used")


class MessageReadResponse(BaseModel):
    uuid: UUID
    created_at: AwareDatetime
    updated_at: AwareDatetime | None = None

    content: str
    type: MessageType
    role: MessageRole
    status: MessageStatus
    author_name: str

    agent_config_version: int | None = None
    llm_model_id: str | None = None

    conversation_name_updated_streaming: str | None = Field(
        default=None,
        description="When streaming messages, this field is used to update the conversation name at the end of the stream",
    )
    conversation_uuid: UUID

    assets: list[AssetReadResponse] | None = None

    reasoning: str | None = None
    tool_use_response: ToolUseResponse | None = None
    generation_metadata: GenerationMetadata | None = None

    @computed_field  # type: ignore[prop-decorator]
    @property
    def total_cost_usd(self) -> float:
        total_cost = 0.0
        if self.generation_metadata:
            total_cost += self.generation_metadata.cost_usd or 0.0

        if self.tool_use_response and self.tool_use_response.tool_use_infos:
            total_cost += sum(tool_use_info.cost_usd for tool_use_info in self.tool_use_response.tool_use_infos)

        return total_cost


class MessageUpdate(BaseModel):
    content: str | None = Field(None, min_length=1, description="New message content")
    asset_uuids: list[UUID] | None = Field(
        None, description="UUIDs for assets attached to message. Set to [] to remove all assets."
    )

    @model_validator(mode="after")
    def validate_content_or_assets(self) -> Self:
        if not self.content and not self.asset_uuids:
            raise ValueError("Either content or assets must be provided")

        return self


# NOTE: we have to customize the response schema for the streaming endpoint, not properly supported by OpenAPI yet
message_streaming_response_model = MessageReadResponse.model_json_schema(ref_template="#/components/schemas/{model}")
message_streaming_response_model.pop("$defs")
message_streaming_response_schema = {
    "content": {
        "text/event-stream": {
            "schema": {"type": "array", "format": "event-stream", "items": message_streaming_response_model}
        }
    }
}


--- Start of backend/src/app/apis/models/agent_config.py ---

from typing import Self

from pydantic import BaseModel, Field, model_validator
from tribe_ai.clients.llm import PromptTemplate
from tribe_ai.services.agents import Tool
from tribe_ai.services.agents.config import AgentStockResponses, ToolUsePromptTemplateSections

from src.app.apis.models.tool import ToolReadResponse
from src.app.handlers.tool import generate_tool_responses
from src.logger import root_logger
from src.models import AgentConfigDTO


log = root_logger.getChild(__name__)


class AgentConfigCreate(BaseModel):
    name: str
    notes: str | None = None
    prompt_template: PromptTemplate
    tool_use_section_templates: ToolUsePromptTemplateSections | None = None
    stock_responses: AgentStockResponses
    is_active: bool
    tools: list[Tool] = Field(default_factory=list)


class AgentConfigCreateFromExisting(BaseModel):
    name: str | None = None
    notes: str | None = None
    prompt_template: PromptTemplate | None = None
    stock_responses: AgentStockResponses = AgentStockResponses()
    is_active: bool | None = None
    tools: list[Tool] = Field(default_factory=list)


class AgentConfigReadResponse(AgentConfigDTO):
    name: str
    tool_definitions: list[ToolReadResponse] = Field(default_factory=list)

    # TODO: make sure this gets set on creation
    is_editable: bool = False

    @model_validator(mode="after")
    def generate_tool_schema_responses(self) -> Self:
        tool_registry_ids = [tool.registry_id for tool in self.tools] if self.tools else []
        self.tool_definitions = generate_tool_responses(tool_registry_ids)
        return self


class AgentConfigsListResponse(BaseModel):
    items: list[AgentConfigReadResponse]


--- Start of backend/src/app/apis/models/agent.py ---

from uuid import UUID

from pydantic import BaseModel
from tribe_ai.services.agents import AgentType

from src.app.apis.models.agent_config import AgentConfigReadResponse
from src.app.apis.models.asset import AssetReadResponse


class AgentReadResponse(BaseModel):
    uuid: UUID
    type: AgentType
    name: str
    description: str | None = None
    is_public: bool
    llm_model_id: str

    active_config: AgentConfigReadResponse
    agent_configs: list[AgentConfigReadResponse]

    assets: list[AssetReadResponse] | None = None
    owner_uuid: UUID | None = None
    owner_username: str | None = None


class AgentsListResponse(BaseModel):
    items: list[AgentReadResponse]


class AgentUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    is_public: bool | None = None
    llm_model_id: str | None = None

    asset_uuids: list[UUID] | None = None


class AgentCreate(BaseModel):
    name: str
    description: str | None = None
    llm_model_id: str
    baseline_config_uuid: UUID | None = None


--- Start of backend/src/app/apis/models/search.py ---

from typing import Self
from uuid import UUID

from pydantic import BaseModel, model_validator
from tribe_ai.clients.search import SearchDocumentResult, SearchIndexResults
from tribe_ai.logger import lib_logger
from tribe_ai.services.ingestion import IngestionStatus

from src.models import MessageRole, MessageStatus, MessageType


log = lib_logger.getChild(__name__)


class SearchRequest(BaseModel):
    query: str

    query_asset_index: bool = True
    query_conversation_index: bool = True
    query_message_index: bool = True

    conversation_uuid_filter: UUID | None = None
    message_type_filter: MessageType | None = None
    message_role_filter: MessageRole | None = None

    limit: int = 20
    offset: int = 0

    truncate_text_fields_to_length: int | None = None

    @model_validator(mode="after")
    def validate_index_selection(self) -> Self:
        if not any(
            [
                self.query_asset_index,
                self.query_conversation_index,
                self.query_message_index,
            ]
        ):
            raise ValueError("At least one index must be selected")

        return self


class AssetSearchResult(SearchDocumentResult):
    name: str
    description: str | None = None
    type: str
    ingestion_status: IngestionStatus | None = None

    content: str | None = None
    summary: str | None = None

    # file metadata
    original_filename: str
    content_hash: str | None = None
    size_bytes: int

    # enriched fields
    conversation_name: str | None = None

    # foreign keys
    agent_uuid: UUID | None = None
    conversation_uuid: UUID
    message_uuid: UUID | None = None
    user_uuid: UUID


class AssetIndexResults(SearchIndexResults):
    index_name: str = "asset"
    hits: list[AssetSearchResult]  # type: ignore[assignment]


class ConversationSearchResult(SearchDocumentResult):
    name: str


class ConversationIndexResults(SearchIndexResults):
    index_name: str = "conversation"
    hits: list[ConversationSearchResult]  # type: ignore[assignment]


class MessageSearchResult(SearchDocumentResult):
    type: MessageType
    role: MessageRole
    status: MessageStatus

    content: str

    # enriched fields
    author_name: str
    author_image_url: str | None = None
    llm_model_id: str | None = None
    conversation_name: str

    # foreign keys
    agent_uuid: UUID | None = None
    conversation_uuid: UUID
    user_uuid: UUID | None = None


class MessageIndexResults(SearchIndexResults):
    index_name: str = "message"
    hits: list[MessageSearchResult]  # type: ignore[assignment]


class SearchResultsResponse(BaseModel):
    asset: AssetIndexResults | None = None
    conversation: ConversationIndexResults | None = None
    message: MessageIndexResults | None = None


class SearchQueryLogRequest(BaseModel):
    query: str


class SearchHistoryResponse(BaseModel):
    queries: list[str]


--- Start of backend/src/app/apis/models/tool.py ---

from pydantic import BaseModel


class ToolReadResponse(BaseModel):
    tool_registry_id: str
    name: str
    description: str
    inputs_schema: dict
    outputs_schema: dict
    options_schema: dict | None = None


class ToolsListResponse(BaseModel):
    items: list[ToolReadResponse]


--- Start of backend/src/app/apis/models/audit_log.py ---

from uuid import UUID

from pydantic import AwareDatetime, BaseModel

from src.models import AuditActionType


class AuditLogReadResponse(BaseModel):
    uuid: UUID
    created_at: AwareDatetime

    action_type: AuditActionType
    entity: str | None = None
    entity_uuid: UUID | None = None
    changes: dict | None = None
    context: dict | None = None

    asset_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID


class AuditLogsListResponse(BaseModel):
    items: list[AuditLogReadResponse]


--- Start of backend/src/app/utils/__init__.py ---



--- Start of backend/src/app/utils/error_analytics.py ---

from tribe_ai.clients.analytics import analytics_client_registry

from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def initialize_error_analytics() -> None:
    """
    Initialize the error analytics client.

    Automatically instruments a number of modules (e.g. FastAPI, SQLAlchemy), so using the client directly is optional.

    We don't want to raise an exception if the client fails to initialize, to keep analytics out of the critical path.
    """
    log.info("Initializing error analytics client")
    global_settings.analytics.error.version = global_settings.app.version
    try:
        analytics_client_registry.get_or_create_instance(name="error", config=global_settings.analytics)
        log.info("Error analytics client initialized")
    except Exception:
        log.exception("Error initializing error analytics client")


--- Start of backend/src/app/utils/static_files.py ---

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles

from src.settings import global_settings


def mount_static_file_router(app: FastAPI) -> None:
    static_files_router = StaticFiles(directory=global_settings.app.static_dir)
    app.mount(global_settings.app.static_image_endpoint_path, static_files_router, name="static")


# TODO: refactor get_icon_url_template
#       - there's probably a cleaner way to do this
#       - should cleanly handle other files than icons
#       - may be a better name for the template variable
#       - fine to leave as is for now and see how it evolves based on usage
def get_static_image_url_template() -> str:
    host_url = str(global_settings.app.host_url).strip("/")
    if "localhost" in host_url:
        host_url = host_url.replace("3000", "8000")

    static_endpoint_path = global_settings.app.static_image_endpoint_path.strip("/")
    return f"{host_url}/{static_endpoint_path}/icons/{{provider}}.png"


--- Start of backend/src/app/handlers/auth.py ---

import warnings
from datetime import timedelta
from typing import Annotated, Literal

from fastapi import Depends, HTTPException, Request, status
from fastapi.security import APIKeyCookie, OAuth2PasswordRequestForm
from fastapi_sso import GoogleSSO, SSOBase
from tribe_ai.clients.authentication import AuthenticationError, SessionToken, auth_client_registry

from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.models import UserDTO
from src.settings import global_settings


# TODO: keep track of passlib updates and remove this once it's no longer needed
#       passlib uses 'crypt', which is deprecated in Python 3.13. See here for more details:
#       https://foss.heptapod.net/python-libs/passlib/-/issues/148
#       once this reimplementation is done we could use that: https://github.com/ThirVondukr/passlib
with warnings.catch_warnings():
    warnings.simplefilter("ignore", DeprecationWarning)
    from passlib.context import CryptContext
    from passlib.exc import UnknownHashError


log = root_logger.getChild(__name__)
google_sso: GoogleSSO | None = None


api_key_cookie = APIKeyCookie(name="session_token", auto_error=False)
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def generate_token(username: str) -> SessionToken:
    log.debug(f"Generating access token for {username=}")
    auth_client = auth_client_registry.get_or_create_instance(name=global_settings.provider.auth)
    expires_delta = timedelta(seconds=global_settings.auth.session_token_expiration_seconds)
    return auth_client.generate_token(data={"sub": username}, expires_delta=expires_delta)


async def get_user_from_cookie(token: Annotated[str, Depends(api_key_cookie)]) -> UserDTO:
    log.debug(f"Getting user from cookie {token=}")
    if not token:
        raise AuthenticationError("Missing token in cookie")

    auth_client = auth_client_registry.get_or_create_instance(name=global_settings.provider.auth)
    payload = auth_client.get_payload_from_token(token)
    username = payload.get("sub")
    if not username:
        log.debug(f"'sub' claim not found in token payload {payload=}")
        raise AuthenticationError("Invalid token")

    user = await crud.user.get_by_username(username)
    if not user:
        log.debug(f"User not found for username {username=}")
        raise AuthenticationError("Invalid token")

    log.debug(f"User {user.username} authenticated")
    return user


async def get_or_create_user_from_sso(db: DBSession, request: Request) -> UserDTO:
    sso = get_sso_provider("google")
    if not sso:
        raise HTTPException(status.HTTP_501_NOT_IMPLEMENTED, detail="SSO not configured")

    with sso:
        open_id_profile = await sso.verify_and_process(request)
        if not open_id_profile:
            msg = "SSO authentication failed"
            log.info(msg)
            raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=msg)

    if not open_id_profile.email:
        msg = "SSO profile missing email"
        log.info(msg)
        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=msg)

    log.debug(f"SSO authenticated user {open_id_profile.email}")
    user_dto = await crud.user.get_by_email(db=db, email=open_id_profile.email)
    if not user_dto:
        log.info(f"Creating new user for {open_id_profile.email}")
        username = open_id_profile.email.split("@")[0]
        count = 0
        while await crud.user.get_by_username(username=username):
            username = f"{username}_{count}"
            count += 1

        log.debug(f"OpenID profile: {open_id_profile}")
        user_dto = UserDTO(
            email=open_id_profile.email,
            username=username,
            email_verified=True,
            given_name=getattr(open_id_profile, "given_name", None),
            family_name=getattr(open_id_profile, "family_name", None),
            image_url=getattr(open_id_profile, "picture", None),
        )
        user_dto = await crud.user.create(db=db, user_dto=user_dto)

    return user_dto


def hash_secret(secret: str) -> str:
    return pwd_context.hash(secret)


def verify_hashed_secret(plain: str, hashed: str) -> bool:
    try:
        return pwd_context.verify(secret=plain, hash=hashed)
    except UnknownHashError:
        return False


def get_sso_provider(provider: Literal["google", "microsoft"]) -> SSOBase:
    if provider == "google":
        if not global_settings.auth.google_sso:
            raise ValueError("Google SSO not configured")

        if not global_settings.auth.google_sso.client_secret:
            raise ValueError("Google SSO client secret not configured")

        global google_sso
        if not google_sso:
            if not global_settings.auth.google_sso.client_id:
                raise ValueError("Google SSO client ID not configured")

            if not global_settings.auth.google_sso.redirect_uri:
                raise ValueError("Google SSO redirect URI not configured")

            google_sso = GoogleSSO(
                client_id=global_settings.auth.google_sso.client_id,
                client_secret=global_settings.auth.google_sso.client_secret.get_secret_value(),
                redirect_uri=str(global_settings.auth.google_sso.redirect_uri),
                allow_insecure_http=global_settings.auth.google_sso.allow_insecure_http,
            )
        return google_sso

    raise ValueError(f"Unsupported SSO provider: {provider}")


LoggedInUser = Annotated[UserDTO, Depends(get_user_from_cookie)]
LoginRequestForm = Annotated[OAuth2PasswordRequestForm, Depends()]


--- Start of backend/src/app/handlers/asset.py ---

import mimetypes
from collections.abc import AsyncGenerator
from hashlib import blake2b
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import BinaryIO
from uuid import UUID, uuid4

import aiofiles
from fastapi import BackgroundTasks, UploadFile
from fastapi.responses import FileResponse, StreamingResponse
from tribe_ai.clients.object_storage import object_storage_client_registry
from tribe_ai.services.ingestion import (
    IngestionDocumentSource,
    IngestionDocumentType,
    IngestionRequest,
    IngestionResponse,
    IngestionStatus,
)

from src.app.apis.models.asset import AssetCreateError, AssetReadResponse
from src.app.handlers.asset_file_extensions import TEXT_FILETYPES
from src.db import crud
from src.db.connect import AsyncSessionMaker, DBSession
from src.ingestion.pipeline import get_or_create_ingestion_pipeline
from src.logger import root_logger
from src.models import AssetDTO, AssetType, UserDTO
from src.search.update.asset import update_asset_search_index
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def create_asset(
    file: UploadFile,
    user_dto: UserDTO,
    conversation_uuid: UUID | None = None,
) -> AssetReadResponse | AssetCreateError:
    log.info(f"Uploading asset for user {user_dto.username} and conversation {conversation_uuid}")
    asset_dto = await _build_asset_dto_from_upload_file(
        user_dto=user_dto, conversation_uuid=conversation_uuid, file=file
    )

    temp_path = await _save_file_to_temp_path(file=file, asset_dto=asset_dto)

    try:
        await _upload_asset_to_object_storage(asset_dto, temp_path)
    except Exception as e:
        log.exception("Error uploading asset to object storage")
        return AssetCreateError(
            original_filename=asset_dto.original_filename,
            error="Error uploading asset to object storage",
            error_log=str(e),
        )

    try:
        async with AsyncSessionMaker() as db:  # type: ignore
            asset_dto = await crud.asset.create(db=db, asset_dto=asset_dto)
    except Exception as e:
        log.exception("Error creating asset")
        return AssetCreateError(
            original_filename=asset_dto.original_filename,
            error="Error creating asset",
            error_log=str(e),
        )

    # TODO: resize images and videos (do we store original?)
    if _ingestion_supported_for_asset(asset_dto):
        asset_dto, ingestion_response = await _ingest_asset(db=db, asset_dto=asset_dto, temp_path=temp_path)
        await _update_search_index(asset_dto=asset_dto, ingestion_response=ingestion_response)
    else:
        asset_dto.ingestion_status = IngestionStatus.UNSUPPORTED

    return AssetReadResponse(**asset_dto.model_dump())


async def _build_asset_dto_from_upload_file(
    user_dto: UserDTO, conversation_uuid: UUID | None, file: UploadFile
) -> AssetDTO:
    asset_uuid = uuid4()

    original_filename = file.filename
    if not original_filename:
        raise ValueError("No original filename provided, cannot determine asset type")

    extension = Path(original_filename).suffix
    internal_filename = f"{asset_uuid}{extension}"

    asset_type = determine_asset_type(filename=original_filename, content_type=file.content_type)
    content_hash = await get_content_hash_from_upload_file(upload_file=file)
    bucket_key = global_settings.asset.bucket_key_template.format(
        user_uuid=user_dto.uuid, asset_uuid=asset_uuid, filename=internal_filename
    )

    return AssetDTO(
        uuid=asset_uuid,
        type=asset_type,
        name=original_filename,
        internal_filename=internal_filename,
        original_filename=original_filename,
        bucket_key=bucket_key,
        size_bytes=file.size or 0,
        mime_type=file.content_type,
        content_hash=content_hash,
        user_uuid=user_dto.uuid,
        conversation_uuid=conversation_uuid,
    )


async def build_asset_dto_from_output_file(
    user_uuid: UUID, agent_uuid: UUID, conversation_uuid: UUID, message_uuid: UUID, file_path: Path
) -> AssetDTO:
    asset_uuid = uuid4()
    original_filename = file_path.name
    if not original_filename:
        raise ValueError("No original filename provided, cannot determine asset type")

    extension = Path(original_filename).suffix
    internal_filename = f"{asset_uuid}{extension}"

    asset_type = determine_asset_type(filename=original_filename)
    content_hash = await get_content_hash_from_file_path(file_path=file_path)
    bucket_key = global_settings.asset.bucket_key_template.format(
        user_uuid=user_uuid, conversation_uuid=conversation_uuid, asset_uuid=asset_uuid, filename=internal_filename
    )

    return AssetDTO(
        uuid=asset_uuid,
        type=asset_type,
        name=original_filename,
        internal_filename=internal_filename,
        original_filename=original_filename,
        bucket_key=bucket_key,
        size_bytes=file_path.stat().st_size,
        mime_type=mimetypes.guess_type(original_filename)[0],
        content_hash=content_hash,
        agent_uuid=agent_uuid,
        user_uuid=user_uuid,
        conversation_uuid=conversation_uuid,
        message_uuid=message_uuid,
    )


async def _save_file_to_temp_path(file: UploadFile, asset_dto: AssetDTO) -> Path:
    temp_file = NamedTemporaryFile()
    temp_path = Path(temp_file.name)
    temp_path = temp_path.rename(temp_path.with_name(asset_dto.internal_filename))
    async with aiofiles.open(temp_path, "wb") as f:
        await f.write(await file.read())
    return temp_path


async def _upload_asset_to_object_storage(asset_dto: AssetDTO, temp_path: Path) -> None:
    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.object_storage.bucket_name,
    )
    # NOTE: writing to disk and then uploading is inefficient, but then so is uploading files directly to the server
    #       S3 client does not support uploading from bytes, only from file paths
    #       we leave this path inefficient for now, for performance we'll use signed upload URLs
    await object_storage_client.upload(local_path=temp_path, key=asset_dto.bucket_key)


def _ingestion_supported_for_asset(asset_dto: AssetDTO) -> bool:
    ingestion_pipeline = get_or_create_ingestion_pipeline()
    file_extension = Path(asset_dto.original_filename).suffix
    supported = file_extension in ingestion_pipeline.supported_file_extensions
    if not supported:
        log.info(f"Unsupported file extension '{file_extension}' for ingestion")

    return supported


async def _ingest_asset(db: DBSession, asset_dto: AssetDTO, temp_path: Path) -> tuple[AssetDTO, IngestionResponse]:
    ingestion_pipeline = get_or_create_ingestion_pipeline()
    ingestion_request = build_ingestion_request(asset_dto=asset_dto, local_path=temp_path)

    log.debug(f"Ingesting asset {asset_dto.uuid} with request {ingestion_request}")
    ingestion_response = await ingestion_pipeline.ingest(ingestion_request=ingestion_request)

    log.info(f"Ingested asset {asset_dto.uuid}")
    log.debug(f"Ingestion response: {ingestion_response}")
    asset_dto = await crud.asset.update_from_ingestion_response(
        db=db, asset_dto=asset_dto, ingestion_response=ingestion_response
    )

    return asset_dto, ingestion_response


async def _update_search_index(asset_dto: AssetDTO, ingestion_response: IngestionResponse) -> None:
    content = ingestion_response.document.content_processed if ingestion_response.document else None
    await update_asset_search_index(
        assets_dto=[asset_dto], ingestion_statuses=[ingestion_response.status], content_values=[content]
    )


async def get_file_response(asset_dto: AssetDTO, background_tasks: BackgroundTasks) -> FileResponse:
    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.object_storage.bucket_name,
    )
    temp_file = NamedTemporaryFile()
    temp_path = Path(temp_file.name)
    original_suffix = Path(asset_dto.original_filename).suffix
    temp_path = temp_path.rename(temp_path.with_suffix(original_suffix))
    await object_storage_client.download(key=asset_dto.bucket_key, local_path=temp_path)

    log.info(f"Serving image {asset_dto.uuid} from {temp_path}")
    background_tasks.add_task(delete_file_after_response_with_delay, temp_path)
    return FileResponse(path=str(temp_path), background=background_tasks)


async def stream_video_file(asset_dto: AssetDTO, background_tasks: BackgroundTasks) -> StreamingResponse:
    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.object_storage.bucket_name,
    )
    temp_file = NamedTemporaryFile()
    video_path = Path(temp_file.name)
    await object_storage_client.download(key=asset_dto.bucket_key, local_path=video_path)

    log.info(f"Serving video {asset_dto.uuid} from {video_path}")

    async def stream_video_file() -> AsyncGenerator[bytes, None]:
        async with aiofiles.open(video_path, "rb") as file_like:
            while chunk := await file_like.read(8192):
                yield chunk

    background_tasks.add_task(delete_file_after_response_with_delay, video_path)
    return StreamingResponse(stream_video_file(), media_type="video/mp4", background=background_tasks)


def determine_asset_type(filename: str, content_type: str | None = None) -> AssetType:
    guessed_mime_type = mimetypes.guess_type(filename)[0]
    if guessed_mime_type is None:
        suffix = Path(filename).suffix
        if suffix in TEXT_FILETYPES:
            log.debug(f"Guessed text type for {filename} with suffix {suffix}")
            return AssetType.TEXT

        log.debug(f"Could not guess MIME type for {filename}")
        return AssetType.OTHER

    mime_type_mapping = {
        "image": AssetType.IMAGE,
        "video": AssetType.VIDEO,
        "audio": AssetType.AUDIO,
        "pdf": AssetType.PDF,
    }

    for mime_type, asset_type in mime_type_mapping.items():
        if mime_type in guessed_mime_type:
            log.debug(f"Guessed {asset_type} type for {filename} with MIME type {guessed_mime_type}")
            return asset_type

    if guessed_mime_type == content_type and "/text" in guessed_mime_type:
        log.debug(f"Guessed text type for {filename} with content type {content_type}")
        return AssetType.TEXT

    return AssetType.OTHER


async def get_content_hash_from_file_path(file_path: Path) -> str:
    async with aiofiles.open(file_path, "rb") as f:
        return await get_content_hash_from_aiofiles_handle(f)


async def get_content_hash_from_upload_file(upload_file: UploadFile) -> str:
    file_hash = blake2b()
    await upload_file.seek(0)
    while chunk := await upload_file.read(8192):
        file_hash.update(chunk)
    await upload_file.seek(0)
    return file_hash.hexdigest()


async def get_content_hash_from_aiofiles_handle(file_handle: aiofiles.threadpool.binary.AsyncBufferedReader) -> str:
    file_hash = blake2b()
    await file_handle.seek(0)
    while chunk := await file_handle.read(8192):
        file_hash.update(chunk)

    await file_handle.seek(0)
    return file_hash.hexdigest()


async def get_content_hash_from_bytesio(file_handle: BinaryIO) -> str:
    file_hash = blake2b()
    file_handle.seek(0)
    while chunk := file_handle.read(8192):
        file_hash.update(chunk)
    file_handle.seek(0)
    return file_hash.hexdigest()


def delete_file_after_response_with_delay(file_path: Path) -> None:
    # TODO: consider keeping a cache of files with managed deletion for better performance
    file_path.unlink(missing_ok=True)
    log.debug(f"Deleted temporary file {file_path}")


def build_ingestion_request(asset_dto: AssetDTO, local_path: Path) -> IngestionRequest:
    context = {
        "asset_uuid": str(asset_dto.uuid),
        "user_uuid": str(asset_dto.user_uuid),
    }
    if asset_dto.agent_uuid:
        context["agent_uuid"] = str(asset_dto.agent_uuid)

    if asset_dto.conversation_uuid:
        context["conversation_uuid"] = str(asset_dto.conversation_uuid)

    if asset_dto.message_uuid:
        context["message_uuid"] = str(asset_dto.message_uuid)

    return IngestionRequest(
        uuid=asset_dto.uuid,
        requested_at=asset_dto.created_at,
        source=IngestionDocumentSource.API,
        type=IngestionDocumentType(asset_dto.type),
        local_path=local_path,
        context=context,
        original_filename=asset_dto.original_filename,
    )


--- Start of backend/src/app/handlers/conversation.py ---

from uuid import UUID

from fastapi import BackgroundTasks, HTTPException, status
from tribe_ai.services.llm_functions import (
    ConversationStarter,
    GenerateConversationNameInputs,
    GenerateConversationNameTask,
    GenerateConversationStartersInputs,
    GenerateConversationStartersTask,
    LLMFunctionError,
)

from src.app.handlers.auth import LoggedInUser
from src.db import crud
from src.db.connect import DBSession
from src.llm.initialize import get_or_create_llm_functions_llm_client
from src.logger import root_logger
from src.models import ConversationDTO, ConversationStarterDTO, MessageRole
from src.search.update.conversation import update_conversation_search_index
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def generate_and_update_conversation_name(db: DBSession, conversation_dto: ConversationDTO) -> ConversationDTO:
    log.debug(f"Generating and updating conversation name for conversation {conversation_dto.uuid}")
    conversation_name = await generate_conversation_name(conversation_dto=conversation_dto)
    conversation_dto.name = conversation_name
    return await crud.conversation.update(db=db, conversation_dto=conversation_dto)


async def maybe_generate_and_update_conversation_name_in_background(
    conversation_dto: ConversationDTO, background_tasks: BackgroundTasks
) -> str:
    # NOTE: assumption here that the conversation name change on first response is the first time the conversation row is updated
    #       perhaps better to add a separate field to track if the conversation name has been updated
    if conversation_dto.updated_at:
        return conversation_dto.name

    log.debug(f"Generating and updating conversation name in background for conversation {conversation_dto.uuid}")
    conversation_name = await generate_conversation_name(conversation_dto=conversation_dto)
    await crud.conversation.update_name_in_background(
        uuid=conversation_dto.uuid, name=conversation_name, background_tasks=background_tasks
    )
    await update_conversation_search_index(conversations_dto=[conversation_dto])
    return conversation_name


async def generate_conversation_name(conversation_dto: ConversationDTO) -> str:
    log.debug(f"Generating conversation name for conversation {conversation_dto.uuid}")
    first_user_message = next((m for m in conversation_dto.messages_in_order if m.role == MessageRole.USER.value), None)
    if not first_user_message:
        log.warning(
            f"No user message found for conversation {conversation_dto.uuid} (messages: {conversation_dto.messages_in_order})"
        )
        return "New Chat"

    conversation_text = first_user_message.content
    if not conversation_text:
        first_assistant_message = next(
            (m for m in conversation_dto.messages_in_order if m.role == MessageRole.ASSISTANT.value), None
        )
        if not first_assistant_message:
            log.warning(
                f"No assistant message found for conversation {conversation_dto.uuid} (messages: {conversation_dto.messages_in_order})"
            )
            return "New Chat"

        conversation_text = first_assistant_message.content

    generate_conversation_name_llm_function = GenerateConversationNameTask(
        structured_output_llm_client=get_or_create_llm_functions_llm_client(),
    )
    try:
        task_output = await generate_conversation_name_llm_function.run(
            inputs=GenerateConversationNameInputs(conversation_text=conversation_text),
            generation_context={
                "conversation_uuid": str(conversation_dto.uuid),
                "user_uuid": str(conversation_dto.user_uuid),
            },
        )
    except LLMFunctionError:
        log.exception(f"Failed to generate conversation name for conversation {conversation_dto.uuid}")
        return "New Chat"

    return task_output.name


async def get_conversation_starters_for_user(
    db: DBSession,
    user_dto: LoggedInUser,
    num_starters: int,
    dynamic: bool = True,
) -> list[ConversationStarter]:
    log.info(f"Getting conversation starters for user {user_dto.username}")
    if not dynamic:
        return await _get_shuffled_conversation_starters(db=db, num_starters=num_starters)

    existing_starters_count = await crud.conversation_starter.get_count(db=db)
    if existing_starters_count > global_settings.app.max_dynamic_starters_to_generate:
        log.debug("Enough conversation starters already exist, sampling from existing starters")
        return await _get_shuffled_conversation_starters(db=db, num_starters=num_starters)

    log.debug("Generating new conversation starters")
    starters = await _generate_new_conversation_starters(db=db, user_dto=user_dto, num_starters=num_starters)
    return starters or await _get_shuffled_conversation_starters(db=db, num_starters=num_starters)


async def _get_shuffled_conversation_starters(db: DBSession, num_starters: int) -> list[ConversationStarter]:
    starters_dto = await crud.conversation_starter.get_many_shuffled(db=db, limit=num_starters)
    return [
        ConversationStarter(title=s.title, description=s.description, message_prefill=s.message_prefill)
        for s in starters_dto
    ]


async def _generate_new_conversation_starters(
    db: DBSession, user_dto: LoggedInUser, num_starters: int
) -> list[ConversationStarter]:
    generate_conversation_starters_llm_function = GenerateConversationStartersTask(
        structured_output_llm_client=get_or_create_llm_functions_llm_client(),
    )
    try:
        task_output = await generate_conversation_starters_llm_function.run(
            inputs=GenerateConversationStartersInputs(num_starters=num_starters),
            generation_context={"user_uuid": str(user_dto.uuid)},
        )
    except LLMFunctionError:
        log.exception(f"Failed to generate conversation starters for user {user_dto.username}")
        return []

    if task_output.starters:
        conversation_starters_dto = [
            ConversationStarterDTO(title=s.title, description=s.description, message_prefill=s.message_prefill)
            for s in task_output.starters
        ]
        await crud.conversation_starter.create_many(db=db, conversation_starters_dto=conversation_starters_dto)

    return task_output.starters[:num_starters]


async def validate_conversation_before_asset_create(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID | None = None
) -> None:
    if not conversation_uuid:
        return

    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        return

    if conversation_dto.user_uuid != user_dto.uuid:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to access this conversation"
        )


--- Start of backend/src/app/handlers/feedback.py ---

import httpx

from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.models import FeedbackDTO
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def store_feedback(db: DBSession, feedback_dto: FeedbackDTO) -> FeedbackDTO:
    """
    Store feedback in the database and optionally send it to external services.
    """
    feedback_dto = await crud.feedback.create(db=db, feedback_dto=feedback_dto)
    if global_settings.app.feedback_slack_webhook:
        await send_feedback_to_slack(feedback_dto=feedback_dto)

    return feedback_dto


async def send_feedback_to_slack(feedback_dto: FeedbackDTO) -> None:
    log.debug(f"Sending feedback to webhook {global_settings.app.feedback_slack_webhook}")
    header = f"New feedback on *{feedback_dto.target.value}* of type *{feedback_dto.type.value}* from user *{feedback_dto.user_uuid}*:\n"
    feedback_quoted = "\n".join([f"> {line}" for line in feedback_dto.feedback.splitlines()])
    message = header + feedback_quoted
    async with httpx.AsyncClient() as client:
        await client.post(str(global_settings.app.feedback_slack_webhook), json={"text": message})


--- Start of backend/src/app/handlers/__init__.py ---



--- Start of backend/src/app/handlers/llm.py ---

from uuid import UUID

from fastapi import HTTPException, status
from tribe_ai.clients.llm import llm_client_registry

from src.app.apis.models.asset import SupportedFileExtensionsResponse
from src.app.apis.models.llm import LLMInfo, LLMInfoResponse, LLMNotSelectableReason
from src.app.handlers.asset_file_extensions import AUDIO_FILETYPES, DOCUMENT_FILETYPES, IMAGE_FILETYPES, TEXT_FILETYPES
from src.app.handlers.auth import LoggedInUser
from src.app.utils.static_files import get_static_image_url_template
from src.db import crud
from src.db.connect import DBSession
from src.exceptions import NotFoundError
from src.ingestion.pipeline import get_or_create_ingestion_pipeline
from src.logger import root_logger


log = root_logger.getChild(__name__)


async def generate_llm_info_responses(
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID | None = None,
    agent_uuid: UUID | None = None,
    supports_audio: bool | None = None,
    supports_images: bool | None = None,
) -> list[LLMInfoResponse]:
    log.info(f"Getting all available llm model ids for user {user_dto.username}")
    selected_llm_model_id = await _get_selected_llm_model_id(db=db, agent_uuid=agent_uuid)
    has_audio, has_images = await _get_conversation_media_constraints(
        db=db, user_dto=user_dto, conversation_uuid=conversation_uuid
    )

    must_support_audio = supports_audio if supports_audio is not None else has_audio
    must_support_images = supports_images if supports_images is not None else has_images
    return _build_llm_info_responses(
        selected_llm_model_id=selected_llm_model_id,
        must_support_audio=must_support_audio,
        must_support_images=must_support_images,
    )


async def get_supported_extensions_for_entity(
    db: DBSession,
    user_dto: LoggedInUser,
    agent_uuid: UUID | None = None,
    conversation_uuid: UUID | None = None,
    llm_model_id: str | None = None,
) -> SupportedFileExtensionsResponse:
    if not agent_uuid and not conversation_uuid and not llm_model_id:
        raise ValueError("One of agent_uuid, conversation_uuid, or llm_model_id must be provided")

    if sum(bool(x) for x in [agent_uuid, conversation_uuid, llm_model_id]) > 1:
        raise ValueError("Only one of agent_uuid, conversation_uuid, or llm_model_id can be provided")

    audio_extensions = []
    document_extensions = []
    image_extensions = []
    text_extensions = []

    if agent_uuid:
        # Only ingestion supported file extensions are supported
        ingestion_supported_file_extensions = get_or_create_ingestion_pipeline().supported_file_extensions
        audio_extensions = [e for e in ingestion_supported_file_extensions if e in AUDIO_FILETYPES]
        document_extensions = [e for e in ingestion_supported_file_extensions if e in DOCUMENT_FILETYPES]
        image_extensions = [e for e in ingestion_supported_file_extensions if e in IMAGE_FILETYPES]
        text_extensions = [e for e in ingestion_supported_file_extensions if e in TEXT_FILETYPES]

    elif conversation_uuid:
        # Both LLM supported file extensions and ingestion supported file extensions are supported
        conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
        if not conversation_dto:
            raise NotFoundError(entity="conversation", by=["uuid"])

        if not conversation_dto.user_uuid == user_dto.uuid:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to access this conversation"
            )

        llm_model_ids = list({a.llm_model_id for a in conversation_dto.agents})
        llm_classes = [llm_client_registry.get_class(llm_model_id) for llm_model_id in llm_model_ids]
        llm_infos = [
            llm.get_llm_info(provider_image_url_template=get_static_image_url_template()) for llm in llm_classes
        ]

        audio_extensions = AUDIO_FILETYPES if any(llm_info.supports_audio for llm_info in llm_infos) else []
        image_extensions = IMAGE_FILETYPES if any(llm_info.supports_images for llm_info in llm_infos) else []

        ingestion_supported_file_extensions = get_or_create_ingestion_pipeline().supported_file_extensions
        audio_extensions.extend(e for e in ingestion_supported_file_extensions if e in AUDIO_FILETYPES)
        document_extensions = [e for e in ingestion_supported_file_extensions if e in DOCUMENT_FILETYPES]
        image_extensions.extend(e for e in ingestion_supported_file_extensions if e in IMAGE_FILETYPES)
        text_extensions = [e for e in ingestion_supported_file_extensions if e in TEXT_FILETYPES]

    elif llm_model_id:
        # Only LLM supported file extensions are supported
        log.debug(f"Getting supported extensions for LLM model id {llm_model_id}")
        try:
            llm_class = llm_client_registry.get_class(llm_model_id)
        except KeyError:
            raise HTTPException(status.HTTP_404_NOT_FOUND, detail=f"LLM model id not found: {llm_model_id}") from None

        llm_info = llm_class.get_llm_info(provider_image_url_template=get_static_image_url_template())
        audio_extensions = AUDIO_FILETYPES if llm_info.supports_audio else []
        document_extensions = []
        image_extensions = IMAGE_FILETYPES if llm_info.supports_images else []
        text_extensions = []

    all_extensions = list(set(audio_extensions + document_extensions + image_extensions + text_extensions))
    return SupportedFileExtensionsResponse(
        all=all_extensions,
        audio=audio_extensions,
        document=document_extensions,
        image=image_extensions,
        text=text_extensions,
    )


async def _get_selected_llm_model_id(db: DBSession, agent_uuid: UUID | None) -> str | None:
    selected_llm_model_id = None
    if agent_uuid:
        agent_dto = await crud.agent.get_by_uuid(db=db, uuid=agent_uuid)
        if not agent_dto:
            raise NotFoundError(entity="agent", by="uuid")

        selected_llm_model_id = agent_dto.llm_model_id
    return selected_llm_model_id


async def _get_conversation_media_constraints(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID | None = None
) -> tuple[bool, bool]:
    has_audio = False
    has_images = False
    if conversation_uuid:
        conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
        if not conversation_dto:
            raise HTTPException(
                status.HTTP_404_NOT_FOUND, detail=f"Conversation not found for uuid {conversation_uuid}"
            )

        if conversation_dto.user_uuid != user_dto.uuid:
            raise HTTPException(
                status.HTTP_403_FORBIDDEN,
                detail=f"Conversation {conversation_uuid} does not belong to user {user_dto.uuid}",
            )

        has_audio = conversation_dto.has_audio()
        has_images = conversation_dto.has_images()

    return has_audio, has_images


def _build_llm_info_responses(
    selected_llm_model_id: str | None, must_support_audio: bool, must_support_images: bool
) -> list[LLMInfoResponse]:
    url_template = get_static_image_url_template()
    llm_classes = llm_client_registry.get_classes()
    llm_infos = [llm.get_llm_info(provider_image_url_template=url_template) for llm in llm_classes.values()]
    llm_info_responses = []
    for llm_info in llm_infos:
        selected = llm_info.llm_model_id == selected_llm_model_id
        selectable, not_selectable_reason = _determine_llm_selectability(
            llm_info=llm_info,
            must_support_audio=must_support_audio,
            must_support_images=must_support_images,
        )
        llm_info_responses.append(
            LLMInfoResponse(
                selected=selected,
                selectable=selectable,
                not_selectable_reason=not_selectable_reason,
                **llm_info.model_dump(),
            )
        )

    return llm_info_responses


def _determine_llm_selectability(
    llm_info: LLMInfo, must_support_audio: bool, must_support_images: bool
) -> tuple[bool, LLMNotSelectableReason | None]:
    if must_support_audio and must_support_images and not llm_info.supports_audio and not llm_info.supports_images:
        return False, LLMNotSelectableReason.BOTH_AUDIO_AND_IMAGES_NOT_SUPPORTED

    if must_support_audio and not llm_info.supports_audio:
        return False, LLMNotSelectableReason.AUDIO_NOT_SUPPORTED

    if must_support_images and not llm_info.supports_images:
        return False, LLMNotSelectableReason.IMAGES_NOT_SUPPORTED

    return True, None


--- Start of backend/src/app/handlers/message.py ---

from uuid import UUID

from fastapi import HTTPException, status

from src.app.apis.models.asset import AssetReadResponse
from src.app.apis.models.message import MessageReadResponse, MessageUpdate
from src.app.handlers.auth import LoggedInUser
from src.db import crud
from src.db.connect import DBSession
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AgentDTO, ConversationDTO, MessageDTO, MessageRole, MessageStatus
from src.search.update.message import delete_from_message_search_index


log = root_logger.getChild(__name__)


async def get_conversation_before_send_message(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID | None
) -> ConversationDTO:
    log.info(f"Getting conversation {conversation_uuid} for user {user_dto.username}")
    if not conversation_uuid:
        return await crud.conversation.create(db=db, user_dto=user_dto, conversation_uuid=conversation_uuid)

    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        return await crud.conversation.create(db=db, user_dto=user_dto, conversation_uuid=conversation_uuid)

    if conversation_dto.user_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "User does not have permission to access this conversation")

    latest_message = conversation_dto.messages_in_order[-1] if conversation_dto.messages else None
    if latest_message and latest_message.user_uuid == user_dto.uuid:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Cannot send multiple user messages in a row")

    return conversation_dto


async def get_and_prepare_conversation_before_regeneration(
    db: DBSession,
    user_dto: LoggedInUser,
    conversation_uuid: UUID,
    message_uuid: UUID | None = None,
) -> ConversationDTO:
    conversation_dto, message_dto = await _get_conversation_and_message(
        db=db, user_dto=user_dto, message_uuid=message_uuid, conversation_uuid=conversation_uuid
    )
    if not message_dto:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Message not found")

    if message_dto.role == "user":
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Cannot regenerate user message")

    if message_dto:
        conversation_dto = await delete_subsequent_messages(
            db=db, message_dto=message_dto, conversation_dto=conversation_dto
        )
        await crud.message.delete(db=db, uuid=message_dto.uuid)
        conversation_dto.messages = [m for m in conversation_dto.messages if m.uuid != message_dto.uuid]

    return conversation_dto


async def get_and_prepare_conversation_before_user_message_update(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID, message_uuid: UUID, message_update: MessageUpdate
) -> ConversationDTO:
    conversation_dto, message_dto = await _get_conversation_and_message(
        db=db, user_dto=user_dto, message_uuid=message_uuid, conversation_uuid=conversation_uuid
    )
    if not message_dto:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Message not found")

    conversation_dto = await delete_subsequent_messages(
        db=db, message_dto=message_dto, conversation_dto=conversation_dto
    )
    message_dto.status = MessageStatus.EDITED
    message_dto.content = message_update.content or message_dto.content

    asset_uuids = None
    if "asset_uuids" in message_update.model_fields_set:
        # if the frontend sets asset_uuids to [] or None, we want to remove all assets
        asset_uuids = message_update.asset_uuids or []

    message_dto = await crud.message.update(db=db, message_dto=message_dto, asset_uuids=asset_uuids)
    conversation_dto.messages = [m for m in conversation_dto.messages if m.uuid != message_dto.uuid]
    conversation_dto.messages.append(message_dto)

    return conversation_dto


async def delete_subsequent_messages(
    db: DBSession, message_dto: MessageDTO, conversation_dto: ConversationDTO
) -> ConversationDTO:
    log.debug(f"Deleting messages after message {message_dto.uuid} for conversation {conversation_dto.uuid}")
    messages_dto = await crud.message.get_all_by_conversation_and_user_uuid(
        db=db, conversation_uuid=conversation_dto.uuid, user_uuid=conversation_dto.user_uuid
    )
    subsequent_messages_dto = [m for m in messages_dto if m.created_at > message_dto.created_at]
    if not subsequent_messages_dto:
        log.debug(f"No subsequent messages for conversation {conversation_dto.uuid} and message {message_dto.uuid}")
        return conversation_dto

    log.debug(f"Deleting {len(subsequent_messages_dto)} subsequent messages for conversation {conversation_dto.uuid}")
    conversation_dto = await crud.message.delete_all_after_datetime_for_conversation(
        db=db, conversation_dto=conversation_dto, after_datetime=message_dto.created_at
    )

    subsequent_message_uuids = [m.uuid for m in subsequent_messages_dto]
    await delete_from_message_search_index(message_uuids=subsequent_message_uuids)

    return conversation_dto


async def cast_message_dtos_to_read_response(
    db: DBSession, user_dto: LoggedInUser, messages_dto: list[MessageDTO]
) -> list[MessageReadResponse]:
    message_responses = []
    agents_by_uuid: dict[UUID, AgentDTO] = {}
    config_version_by_config_uuid: dict[UUID, int | None] = {}
    config_version = None
    for message_dto in messages_dto:
        if message_dto.role == MessageRole.USER:
            author_name = user_dto.username

        elif message_dto.role == MessageRole.ASSISTANT:
            author_name = await resolve_agent_name(db=db, agents_by_uuid=agents_by_uuid, message_dto=message_dto)
            config_version = await resolve_agent_config_version(
                db=db, config_version_by_config_uuid=config_version_by_config_uuid, message_dto=message_dto
            )

        else:
            raise SystemError(f"Unknown message role {message_dto.role}")

        assets = [AssetReadResponse(**a.model_dump()) for a in message_dto.assets] if message_dto.assets else []
        message_responses.append(
            MessageReadResponse(
                **message_dto.model_dump(exclude={"assets"}),
                author_name=author_name,
                assets=assets,
                agent_config_version=config_version,
            )
        )

    return message_responses


async def resolve_agent_name(db: DBSession, agents_by_uuid: dict[UUID, AgentDTO], message_dto: MessageDTO) -> str:
    if not message_dto.agent_uuid:
        return "Unknown Agent (possibly deleted)"

    if message_dto.agent_uuid not in agents_by_uuid:
        agent_dto = await crud.agent.get_by_uuid(db=db, uuid=message_dto.agent_uuid)
        if not agent_dto:
            return "Unknown Agent (possibly deleted)"

        agents_by_uuid[message_dto.agent_uuid] = agent_dto

    return agents_by_uuid[message_dto.agent_uuid].name


async def resolve_agent_config_version(
    db: DBSession, config_version_by_config_uuid: dict[UUID, int | None], message_dto: MessageDTO
) -> int | None:
    if message_dto.agent_config_uuid and message_dto.agent_config_uuid in config_version_by_config_uuid:
        return config_version_by_config_uuid[message_dto.agent_config_uuid]

    if not message_dto.agent_uuid or not message_dto.agent_config_uuid:
        return None

    agent_config = await crud.agent_config.get_by_uuid_and_agent_uuid(
        db=db, uuid=message_dto.agent_config_uuid, agent_uuid=message_dto.agent_uuid
    )
    agent_config_version = agent_config.version if agent_config else None
    config_version_by_config_uuid[message_dto.agent_config_uuid] = agent_config_version
    return agent_config_version


async def _get_conversation_and_message(
    db: DBSession, user_dto: LoggedInUser, conversation_uuid: UUID, message_uuid: UUID | None = None
) -> tuple[ConversationDTO, MessageDTO | None]:
    message_dto = None
    if message_uuid:
        message_dto = await crud.message.get_by_uuid(db=db, uuid=message_uuid)
        if not message_dto:
            raise NotFoundError(entity="message", by=[f"uuid:{message_uuid}"])

        if message_dto.conversation_uuid != conversation_uuid:
            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Conversation UUID does not match message")

    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=conversation_uuid)
    if not conversation_dto:
        raise NotFoundError(entity="conversation", by=[f"uuid:{conversation_uuid}"])

    if conversation_dto.user_uuid != user_dto.uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, detail="User does not have permission to regenerate message")

    # if message_uuid is not provided, this is to generate a new message (when agent message generation previously failed)
    if not message_dto:
        message_dto = conversation_dto.messages_in_order[-1] if conversation_dto.messages else None
        if message_dto and message_dto.role == MessageRole.USER.value:
            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Cannot regenerate user message")

    return conversation_dto, message_dto


--- Start of backend/src/app/handlers/agent.py ---

import shutil
from datetime import UTC, datetime
from pathlib import Path
from tempfile import TemporaryDirectory
from uuid import UUID, uuid4

from fastapi import HTTPException
from tribe_ai.clients.llm import (
    ContentBlockSubclassList,
    ImageContentBlock,
    LLMMessageRole,
    MultimodalLLMMessage,
    TextContentBlock,
    TextLLMMessage,
    ToolCallContentBlock,
    ToolResultContentBlock,
    ToolResultMessage,
)
from tribe_ai.clients.object_storage import object_storage_client_registry
from tribe_ai.services.agents import (
    AgentRequest,
    AgentType,
    AssetInfo,
    BaseAgent,
    ConversationContext,
    UserContext,
    agent_class_registry,
)
from tribe_ai.services.agents.tools import ToolUseResponse, ToolUseStatus
from tribe_ai.utils.timing import log_timing_async

from src.agents.build_tools import build_tools_for_agent
from src.app.apis.models.agent import AgentCreate
from src.app.apis.models.agent_config import AgentConfigCreateFromExisting
from src.app.handlers.asset import build_asset_dto_from_output_file
from src.app.handlers.auth import LoggedInUser
from src.db import crud
from src.db.connect import DBSession
from src.db.models import AssetDB
from src.llm.initialize import get_or_create_llm_client
from src.logger import root_logger
from src.models import (
    AGENT_CONFIG_INITIAL_VERSION,
    AgentConfigDTO,
    AgentDTO,
    AssetType,
    ConversationDTO,
    MessageDTO,
    MessageStatus,
)
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def get_agent_for_conversation(
    db: DBSession, conversation_dto: ConversationDTO, agent_config_uuid: UUID | None = None, caching: bool = True
) -> BaseAgent:
    agent_dto = await get_agent_dto_for_conversation(db=db, conversation_dto=conversation_dto)
    agent_config = agent_dto.active_config
    if agent_config_uuid is not None:
        log.debug(f"Getting agent {agent_dto.uuid} with config version {agent_config_uuid}")
        chosen_agent_config = next((c for c in agent_dto.agent_configs if c.uuid == agent_config_uuid), None)
        if not chosen_agent_config:
            raise HTTPException(
                status_code=404,
                detail=f"Agent {agent_dto.uuid} does not have a config with version {agent_config_uuid}",
            )

        agent_config = chosen_agent_config

    if agent_config.stock_responses.initial_message and len(conversation_dto.messages) == 0:
        initial_message_dto = await crud.message.create_agent_message(
            db=db,
            user_uuid=conversation_dto.user.uuid,
            conversation_uuid=conversation_dto.uuid,
            agent_uuid=agent_dto.uuid,
            agent_config_uuid=agent_config.uuid,
            content=agent_config.stock_responses.initial_message,
            message_status=MessageStatus.COMPLETED,
        )
        conversation_dto.messages.append(initial_message_dto)

    agent_metadata = agent_dto.get_metadata()
    llm_client = get_or_create_llm_client(name=agent_dto.llm_model_id, caching=caching)
    tools = build_tools_for_agent(agent_dto=agent_dto, conversation_dto=conversation_dto)
    return agent_class_registry.get_or_create_instance(
        agent_config.agent_class,
        llm_client=llm_client,
        config=agent_config,
        metadata=agent_metadata,
        tools=tools,
    )


async def get_agent_dto_for_conversation(db: DBSession, conversation_dto: ConversationDTO) -> AgentDTO:
    log.debug(f"Getting agent for conversation {conversation_dto.uuid}")
    if not conversation_dto.agents:
        # NOTE: this should really never happen as an agent is always added to a conversation when it is created
        agent_uuid = global_settings.agents.default_agent_uuid
        log.warning(f"No agents associated with conversation {conversation_dto.uuid}, adding: {agent_uuid}")
        agent_dto = await crud.agent.get_agent_by_uuid(db=db, uuid=agent_uuid)
        await crud.conversation.add_agent(db=db, conversation_dto=conversation_dto, agent_dto=agent_dto)
        return agent_dto

    # TODO: this assumes one agent per conversation, update to handle multiple agents in the future
    return conversation_dto.agents[-1]


async def create_agent(db: DBSession, user_dto: LoggedInUser, agent_create: AgentCreate) -> AgentDTO:
    log.info(f"Creating new agent for user {user_dto.username}")

    baseline_config = await crud.agent_config.get_db_by_uuid(
        db=db, uuid=agent_create.baseline_config_uuid or global_settings.agents.default_agent_config_uuid
    )
    if not baseline_config:
        raise HTTPException(
            status_code=404,
            detail=f"Baseline config {agent_create.baseline_config_uuid} not found",
        )
    baseline_config_dto = baseline_config.to_dto()
    agent_config = baseline_config_dto.model_copy(deep=True)
    agent_config.uuid = uuid4()
    agent_config.version = AGENT_CONFIG_INITIAL_VERSION

    agent_dto = AgentDTO(
        **agent_create.model_dump(),
        owner_uuid=user_dto.uuid,
        type=AgentType.AI,
        is_public=False,
        agent_configs=[agent_config],
    )
    return await crud.agent.create(db=db, agent_dto=agent_dto)


async def create_agent_from_existing_agent(db: DBSession, user_dto: LoggedInUser, agent_dto: AgentDTO) -> AgentDTO:
    log.info(f"Creating new agent from existing agent {agent_dto.uuid} for user {user_dto.username}")
    agent_config = agent_dto.active_config.model_copy(deep=True)
    agent_config.uuid = uuid4()
    agent_config.version = AGENT_CONFIG_INITIAL_VERSION

    new_agent_name = f"{agent_dto.name} (cloned)"
    new_agent_dto = AgentDTO(
        **agent_dto.model_dump(
            exclude={
                "uuid",
                "created_at",
                "updated_at",
                "active_config",
                "agent_configs",
                "assets",
                "is_public",
                "name",
                "owner_uuid",
                "owner_username",
            }
        ),
        name=new_agent_name,
        is_public=False,
        owner_uuid=user_dto.uuid,
        agent_configs=[agent_config],
        # NOTE: we don't set assets as we don't support sharing assets between agents
        #       technically we could, but it makes life easier when it comes to deletion and authorization
    )
    return await crud.agent.create(db=db, agent_dto=new_agent_dto)


async def build_agent_request(conversation_dto: ConversationDTO) -> AgentRequest:
    asset_infos = await _cast_assets_to_asset_infos(conversation_dto=conversation_dto)
    llm_messages = await _cast_app_messages_to_llm_messages(conversation_dto=conversation_dto)
    context_dir = build_conversation_context_dir_local_path(
        user_uuid=conversation_dto.user.uuid, conversation_uuid=conversation_dto.uuid
    )
    # TODO: sync conversation context from object storage when we want tools that access previous context
    #       add the line: await sync_conversation_context_dir_from_object_storage(conversation_dto=conversation_dto)
    conversation_context = ConversationContext(
        uuid=conversation_dto.uuid,
        created_at=conversation_dto.created_at or datetime.now(UTC),
        name=conversation_dto.name,
        asset_infos=asset_infos,
        context_dir=context_dir,
    )
    user_context = UserContext(uuid=conversation_dto.user.uuid, username=conversation_dto.user.username)
    return AgentRequest(conversation=conversation_context, llm_messages=llm_messages, user=user_context)


def build_conversation_context_dir_local_path(user_uuid: UUID, conversation_uuid: UUID) -> Path:
    """
    Builds the local path to the conversation context directory.
    We don't enforce that the directory exists, as it may not be needed if no assets are present or tools require it.
    """
    relative_path = build_conversation_context_dir_relative_path(
        user_uuid=user_uuid, conversation_uuid=conversation_uuid
    )
    return global_settings.agents.conversation_context_local_dir / relative_path


def build_conversation_context_dir_relative_path(user_uuid: UUID, conversation_uuid: UUID) -> str:
    """
    Builds the relative path to the conversation context directory.
    """
    template = global_settings.agents.conversation_context_bucket_key_prefix_template
    return template.format(user_uuid=user_uuid, conversation_uuid=conversation_uuid)


@log_timing_async
async def sync_conversation_context_dir_from_object_storage(conversation_dto: ConversationDTO) -> None:
    log.debug(f"Syncing conversation context directory from object storage for conversation {conversation_dto.uuid}")
    conversation_context_dir_local_path = build_conversation_context_dir_local_path(
        user_uuid=conversation_dto.user.uuid, conversation_uuid=conversation_dto.uuid
    )
    relative_path = build_conversation_context_dir_relative_path(
        user_uuid=conversation_dto.user.uuid, conversation_uuid=conversation_dto.uuid
    )
    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.object_storage.bucket_name,
    )
    if await object_storage_client.prefix_has_keys(key_prefix=relative_path):
        log.debug(f"Syncing conversation context directory {conversation_context_dir_local_path} from object storage")
        await object_storage_client.sync_to_local(
            key_prefix=relative_path, local_dir=conversation_context_dir_local_path
        )


@log_timing_async
async def create_assets_from_output_files(
    db: DBSession,
    tool_use_response: ToolUseResponse,
    user_uuid: UUID,
    agent_uuid: UUID,
    conversation_uuid: UUID,
    message_uuid: UUID,
) -> list[AssetDB]:
    log.debug(f"Syncing conversation context directory to object storage for conversation {conversation_uuid}")
    conversation_context_dir_local_path = build_conversation_context_dir_local_path(
        user_uuid=user_uuid, conversation_uuid=conversation_uuid
    )
    if not conversation_context_dir_local_path.exists():
        log.debug(f"Conversation context directory {conversation_context_dir_local_path} does not exist, skipping sync")
        return []

    tool_use_infos_with_output_files = [t for t in tool_use_response.tool_use_infos if t.output_files]
    if not tool_use_infos_with_output_files:
        log.debug("No output files to create assets from")
        return []

    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.object_storage.bucket_name,
    )

    created_assets_db = []
    for tool_use_info in tool_use_infos_with_output_files:
        for output_file in tool_use_info.output_files:
            if not output_file.local_path or not output_file.local_path.exists():
                log.warning(f"Output file {output_file.local_path} does not exist, skipping")
                continue

            asset_dto = await build_asset_dto_from_output_file(
                agent_uuid=agent_uuid,
                user_uuid=user_uuid,
                conversation_uuid=conversation_uuid,
                message_uuid=message_uuid,
                file_path=output_file.local_path,
            )
            log.debug(f"Uploading asset {asset_dto.uuid} to object storage")
            await object_storage_client.upload(local_path=output_file.local_path, key=asset_dto.bucket_key)
            log.debug(f"Creating asset {asset_dto.uuid} in database")
            created_assets_db.append(await crud.asset.create_db(db=db, asset_dto=asset_dto))

    if global_settings.agents.conversation_context_cleanup_local_dir_after_sync:
        conversation_context_dir_local_path = build_conversation_context_dir_local_path(
            user_uuid=conversation_uuid, conversation_uuid=conversation_uuid
        )
        log.debug(f"Cleaning up conversation context directory {conversation_context_dir_local_path}")
        shutil.rmtree(conversation_context_dir_local_path, ignore_errors=True)

    return created_assets_db


async def create_agent_config_from_existing_or_update(
    db: DBSession,
    agent_dto: AgentDTO,
    existing_agent_config_dto: AgentConfigDTO,
    agent_config_values: AgentConfigCreateFromExisting,
) -> AgentConfigDTO:
    if agent_config_values.model_fields_set.issubset({"notes", "is_active"}):
        return await _update_existing_agent_config(
            db=db,
            agent_dto=agent_dto,
            existing_agent_config_dto=existing_agent_config_dto,
            agent_config_values=agent_config_values,
        )

    updated_agent_config_values = {
        **existing_agent_config_dto.model_dump(exclude={"created_at", "updated_at", "uuid"}),
        **agent_config_values.model_dump(exclude_unset=True, exclude={"is_active"}),
        # NOTE: version is set to correct (autoincremented) value in the .add_new_config method
        "version": 1,
    }
    updated_agent_config = AgentConfigDTO(**updated_agent_config_values)
    updated_agent_config_dto = await crud.agent_config.create(db=db, agent_config_dto=updated_agent_config)

    agent_dto.add_new_config(updated_agent_config_dto)
    if agent_config_values.is_active:
        agent_dto.set_active_config(updated_agent_config_dto.uuid)

    await crud.agent.update(db=db, agent_dto=agent_dto)
    return updated_agent_config_dto


async def _update_existing_agent_config(
    db: DBSession,
    agent_dto: AgentDTO,
    existing_agent_config_dto: AgentConfigDTO,
    agent_config_values: AgentConfigCreateFromExisting,
) -> AgentConfigDTO:
    if agent_config_values.is_active is False:
        raise ValueError("Cannot set an existing config to inactive, set another config to active instead")

    if "notes" in agent_config_values.model_fields_set:
        existing_agent_config_dto.notes = agent_config_values.notes

    if "is_active" in agent_config_values.model_fields_set and agent_config_values.is_active:
        agent_dto.set_active_config(existing_agent_config_dto.uuid)

    await crud.agent.update(db=db, agent_dto=agent_dto)
    return existing_agent_config_dto


async def _cast_assets_to_asset_infos(
    conversation_dto: ConversationDTO,
) -> list[AssetInfo]:
    return [
        AssetInfo(
            uuid=asset_dto.uuid,
            created_at=asset_dto.created_at or datetime.now(UTC),
            filename=asset_dto.original_filename,
            name=asset_dto.name,
            description=asset_dto.description,
            size_bytes=asset_dto.size_bytes,
        )
        for asset_dto in conversation_dto.assets
    ]


async def _cast_app_messages_to_llm_messages(
    conversation_dto: ConversationDTO,
) -> ContentBlockSubclassList:
    if not conversation_dto.messages:
        return []

    if not any(message.assets for message in conversation_dto.messages_in_order):
        return [
            TextLLMMessage(
                uuid=message.uuid,
                created_at=message.created_at or datetime.now(UTC),
                content=message.content,
                role=LLMMessageRole(message.role.value),
            )
            for message in conversation_dto.messages_in_order
        ]

    llm_messages: ContentBlockSubclassList = []
    for message in conversation_dto.messages_in_order:
        if not message.assets and not message.tool_use_response:
            llm_messages.append(
                TextLLMMessage(
                    uuid=message.uuid,
                    created_at=message.created_at or datetime.now(UTC),
                    content=message.content,
                    role=LLMMessageRole(message.role.value),
                )
            )
            continue

        content_blocks: ContentBlockSubclassList = [TextContentBlock(content=message.content)]
        content_blocks = await _process_message_assets(message=message, content_blocks=content_blocks)
        content_blocks, tool_result_blocks = _process_tool_use(message=message, content_blocks=content_blocks)
        multimodal_message = MultimodalLLMMessage(content=content_blocks, role=LLMMessageRole(message.role.value))
        llm_messages.append(multimodal_message)
        if tool_result_blocks:
            tool_result_message = ToolResultMessage(content=tool_result_blocks, role=LLMMessageRole.USER)
            llm_messages.append(tool_result_message)

    return llm_messages


async def _process_message_assets(
    message: MessageDTO, content_blocks: ContentBlockSubclassList
) -> ContentBlockSubclassList:
    if not message.assets:
        return content_blocks

    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage,
        config=global_settings.object_storage,
        bucket_name=global_settings.object_storage.bucket_name,
    )
    for asset in message.assets:
        if asset.type != AssetType.IMAGE:
            log.debug(f"Asset type {asset.type} found in message {message.uuid}. Skipping.")
            continue

        supported_extensions = [".png", ".jpg", ".jpeg"]
        if Path(asset.internal_filename).suffix.lower() not in supported_extensions:
            log.debug(
                f"Asset {asset.uuid} is not a supported image type "
                f"(supported: {supported_extensions}, got: {asset.internal_filename}). Skipping."
            )
            continue

        log.debug(f"Converting asset {asset.uuid} to content block")
        with TemporaryDirectory() as temp_dir:
            local_path = Path(temp_dir) / asset.internal_filename
            await object_storage_client.download(key=asset.bucket_key, local_path=local_path)
            image_block = await ImageContentBlock.from_path(image_path=local_path)
            content_blocks.append(image_block)

    return content_blocks


def _process_tool_use(
    message: MessageDTO, content_blocks: ContentBlockSubclassList
) -> tuple[ContentBlockSubclassList, ContentBlockSubclassList]:
    if not message.tool_use_response:
        return content_blocks, []

    tool_result_blocks = []
    for tool_use_info in message.tool_use_response.tool_use_infos:
        tool_call_block = ToolCallContentBlock(
            tool_use_id=tool_use_info.id,
            tool_name=tool_use_info.name,
            inputs_json=tool_use_info.input_text,
        )
        content_blocks.append(tool_call_block)

        tool_result_block = ToolResultContentBlock(
            tool_use_id=tool_use_info.id,
            content=tool_use_info.output_text,
            is_error=tool_use_info.status == ToolUseStatus.FAILED,
        )
        tool_result_blocks.append(tool_result_block)

    return content_blocks, tool_result_blocks


--- Start of backend/src/app/handlers/search.py ---

from collections.abc import Callable
from typing import cast
from uuid import UUID

from fastapi import HTTPException
from tribe_ai.clients.llm import llm_client_registry
from tribe_ai.clients.search import IndexableSearchDocument, SearchIndexResults, SearchQuery, SearchQueryLog
from tribe_ai.common.db.models.base import BaseDTO

from src.app.apis.models.search import (
    AssetIndexResults,
    AssetSearchResult,
    ConversationIndexResults,
    ConversationSearchResult,
    MessageIndexResults,
    MessageSearchResult,
    SearchRequest,
    SearchResultsResponse,
)
from src.app.handlers.auth import LoggedInUser
from src.app.utils.static_files import get_static_image_url_template
from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.models import AgentDTO, MessageRole, UserDTO
from src.search.connect import get_hybrid_search_client


log = root_logger.getChild(__name__)


async def execute_search_query(
    db: DBSession, user_dto: LoggedInUser, search_request: SearchRequest
) -> SearchResultsResponse:
    log.debug(f"Full text search query for user {user_dto.uuid}")
    queries = _build_search_queries(user=user_dto, search_request=search_request)
    hybrid_search_client = get_hybrid_search_client()
    search_index_results = await hybrid_search_client.multi_query(queries=queries)
    return await _process_search_results(
        db=db, search_request=search_request, search_index_results=search_index_results
    )


async def store_search_query(db: DBSession, user_dto: LoggedInUser, query: str) -> None:
    log.debug(f"Storing search query for user {user_dto.uuid}")
    try:
        user_dto.search_history.append(SearchQueryLog(query=query))
        await crud.user.update(db=db, user_dto=user_dto)
    except Exception:
        log.exception(f"Failed to store search query for user {user_dto.uuid}")
        return


async def rebuild_search_indices_from_db(db: DBSession, index_name: str | None = None) -> None:
    hybrid_search_client = get_hybrid_search_client()
    search_index_schemas = hybrid_search_client.get_registered_index_schemas()
    index_names = [index.index_name for index in search_index_schemas]
    if index_name and index_name not in index_names:
        raise HTTPException(status_code=404, detail=f"Index {index_name} not found (available indices: {index_names})")

    search_index_schemas = [i for i in search_index_schemas if not index_name or i.index_name == index_name]
    index_to_crud_fn_map: dict[str, Callable] = {
        "asset": crud.asset.get_all,
        "conversation": crud.conversation.get_all,
        "ingestion_chunk": crud.ingestion_chunk.get_all,
        "ingestion_document": crud.ingestion_document.get_all,
        "message": crud.message.get_all,
    }
    for index in search_index_schemas:
        if index.index_name not in index_to_crud_fn_map:
            log.warning(f"Skipping search index {index.index_name} as no CRUD function is available")
            continue

        log.info(f"Rebuilding search index {index.index_name}")
        await hybrid_search_client.delete_index(index_schema=index)
        await hybrid_search_client.create_or_update_index(index_schema=index)
        crud_fn = index_to_crud_fn_map[index.index_name]
        entity_dtos: list[BaseDTO] = await crud_fn(db=db)
        if not entity_dtos:
            log.debug(f"No entities to re-index for {index.index_name}")
            continue

        entity_dicts = [index.filter_and_cast_indexable_fields(entity_dto.model_dump()) for entity_dto in entity_dtos]
        search_documents = [IndexableSearchDocument(**d) for d in entity_dicts]
        await hybrid_search_client.index_documents(documents=search_documents, index_schema=index)


def _build_search_queries(user: LoggedInUser, search_request: SearchRequest) -> list[SearchQuery]:
    queries = []
    query_params = search_request.model_dump(include={"query", "limit", "offset"})
    query_params["filters"] = {"user_uuid": str(user.uuid)}

    if search_request.query_asset_index:
        if search_request.conversation_uuid_filter:
            query_params["filters"].update({"conversation_uuid": str(search_request.conversation_uuid_filter)})

        queries.append(SearchQuery(index_name="asset", **query_params))

    if search_request.query_conversation_index:
        queries.append(SearchQuery(index_name="conversation", **query_params))

    if search_request.query_message_index:
        if search_request.conversation_uuid_filter:
            query_params["filters"].update({"conversation_uuid": str(search_request.conversation_uuid_filter)})

        if search_request.message_type_filter:
            query_params["filters"].update({"type": search_request.message_type_filter.value})

        if search_request.message_role_filter:
            query_params["filters"].update({"role": search_request.message_role_filter.value})

        queries.append(SearchQuery(index_name="message", **query_params))

    return queries


async def _process_search_results(
    db: DBSession, search_request: SearchRequest, search_index_results: list[SearchIndexResults]
) -> SearchResultsResponse:
    asset_results = None
    conversation_results = None
    message_results = None

    conversation_name_map: dict[UUID, str] = {}

    for index_results in search_index_results:
        if search_request.truncate_text_fields_to_length:
            for search_document in index_results.hits:
                search_document.truncate_text_fields(num_characters=search_request.truncate_text_fields_to_length)

        if index_results.index_name == "asset":
            log.debug(f"Found {len(index_results.hits)} asset search results")
            asset_results = await _enrich_asset_results(
                db=db, index_results=index_results, conversation_name_map=conversation_name_map
            )

        elif index_results.index_name == "conversation":
            log.debug(f"Found {len(index_results.hits)} conversation search results")
            index_results = cast(ConversationIndexResults, index_results)
            conversation_results = _enrich_conversation_results(index_results=index_results)

        elif index_results.index_name == "message":
            log.debug(f"Found {len(index_results.hits)} message search results")
            message_results = await _enrich_message_results(
                db=db, index_results=index_results, conversation_name_map=conversation_name_map
            )

    return SearchResultsResponse(asset=asset_results, conversation=conversation_results, message=message_results)


async def _enrich_asset_results(
    db: DBSession, index_results: SearchIndexResults, conversation_name_map: dict[UUID, str]
) -> AssetIndexResults:
    index_results = cast(AssetIndexResults, index_results)
    search_documents = [AssetSearchResult(**search_document.model_dump()) for search_document in index_results.hits]
    for search_document in search_documents:
        search_document.conversation_name = await _get_conversation_name(
            db=db, search_document=search_document, conversation_name_map=conversation_name_map
        )

    return AssetIndexResults(hits=search_documents, **index_results.model_dump(exclude={"hits"}))


def _enrich_conversation_results(index_results: SearchIndexResults) -> ConversationIndexResults:
    index_results = cast(ConversationIndexResults, index_results)
    search_documents = [
        ConversationSearchResult(**search_document.model_dump()) for search_document in index_results.hits
    ]
    return ConversationIndexResults(hits=search_documents, **index_results.model_dump(exclude={"hits"}))


async def _enrich_message_results(
    db: DBSession, index_results: SearchIndexResults, conversation_name_map: dict[UUID, str]
) -> MessageIndexResults:
    agents_by_uuid: dict[UUID, AgentDTO | None] = {}
    users_by_uuid: dict[UUID, UserDTO | None] = {}
    url_template = get_static_image_url_template()
    llm_classes = llm_client_registry.get_classes()

    for search_document in index_results.hits:
        search_document = cast(MessageSearchResult, search_document)
        search_document.conversation_name = await _get_conversation_name(
            db=db, search_document=search_document, conversation_name_map=conversation_name_map
        )
        if search_document.role == MessageRole.ASSISTANT:
            search_document = await _enrich_agent_message(
                db=db,
                search_document=search_document,
                agents_by_uuid=agents_by_uuid,
                url_template=url_template,
                llm_classes=llm_classes,
            )

        elif search_document.role == MessageRole.USER:
            search_document = await _enrich_user_message(
                db=db, search_document=search_document, users_by_uuid=users_by_uuid
            )

    search_documents = [MessageSearchResult(**search_document.model_dump()) for search_document in index_results.hits]
    return MessageIndexResults(hits=search_documents, **index_results.model_dump(exclude={"hits"}))


async def _get_conversation_name(
    db: DBSession, search_document: AssetSearchResult | MessageSearchResult, conversation_name_map: dict[UUID, str]
) -> str:
    if search_document.conversation_uuid in conversation_name_map:
        return conversation_name_map[search_document.conversation_uuid]

    conversation_dto = await crud.conversation.get_by_uuid(db=db, uuid=search_document.conversation_uuid)
    conversation_name = conversation_dto.name if conversation_dto else "Unknown Conversation"
    conversation_name_map[search_document.conversation_uuid] = conversation_name
    return conversation_name


async def _enrich_agent_message(
    db: DBSession,
    agents_by_uuid: dict[UUID, AgentDTO | None],
    url_template: str,
    llm_classes: dict,
    search_document: MessageSearchResult,
) -> MessageSearchResult:
    # type guard
    if not search_document.agent_uuid:
        raise SystemError(f"Found agent message in search results without agent_uuid: {search_document.uuid}")

    if not search_document.llm_model_id:
        log.warning(f"No LLM model ID found for agent message {search_document.uuid} ({search_document})")
        search_document.author_name = "Unknown Agent"
        return search_document

    llm_info = llm_classes[search_document.llm_model_id].get_llm_info(provider_image_url_template=url_template)
    search_document.author_image_url = llm_info.provider.image_url

    if search_document.agent_uuid in agents_by_uuid:
        agent_dto = agents_by_uuid[search_document.agent_uuid]
        search_document.author_name = agent_dto.name if agent_dto else "Unknown Agent"
        return search_document

    agent_dto = await crud.agent.get_by_uuid(db=db, uuid=search_document.agent_uuid)
    agents_by_uuid[search_document.agent_uuid] = agent_dto
    search_document.author_name = agent_dto.name if agent_dto else "Unknown Agent"
    return search_document


async def _enrich_user_message(
    db: DBSession, search_document: MessageSearchResult, users_by_uuid: dict[UUID, UserDTO | None]
) -> MessageSearchResult:
    # type guard
    if not search_document.user_uuid:
        raise SystemError(f"Found user message in search results without user_uuid: {search_document.uuid}")

    if search_document.user_uuid in users_by_uuid:
        user_dto = users_by_uuid[search_document.user_uuid]
        search_document.author_name = user_dto.username if user_dto else "Unknown User"
        search_document.author_image_url = user_dto.image_url if user_dto else None
        return search_document

    user_dto = await crud.user.get_by_uuid(db=db, uuid=search_document.user_uuid)
    users_by_uuid[search_document.user_uuid] = user_dto
    search_document.author_name = user_dto.username if user_dto else "Unknown User"
    search_document.author_image_url = user_dto.image_url if user_dto else None
    return search_document


--- Start of backend/src/app/handlers/tool.py ---

from tribe_ai.services.agents import Tool
from tribe_ai.services.agents.tools import tool_registry

from src.app.apis.models.tool import ToolReadResponse
from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)


def generate_tool_responses(tool_ids: list[str] | None = None) -> list[ToolReadResponse]:
    tools = tool_registry.get_classes()

    lookup_tool_ids = list(tools.keys())
    lookup_tool_ids = [t for t in lookup_tool_ids if t not in global_settings.agents.tool_registry_ids_hidden_from_api]
    if tool_ids is not None:
        lookup_tool_ids = tool_ids

    return [
        ToolReadResponse(
            tool_registry_id=tool_registry_id,
            name=t.display_name,
            description=t.description,
            inputs_schema=t.inputs_class.model_json_schema(),
            outputs_schema=t.outputs_class.model_json_schema(),
            options_schema=t.options_class.model_json_schema() if t.options_class else None,
        )
        for tool_registry_id, t in tools.items()
        if tool_registry_id in lookup_tool_ids
    ]


def validate_tool_options(tools: list[Tool]) -> None:
    for tool in tools:
        if not tool.options:
            continue

        tool_class = tool_registry.get_class(tool.registry_id)
        if not tool_class.options_class:
            raise ValueError(f"Tool options class not found for tool {tool.registry_id}")
        tool_class.options_class.model_validate(tool.options)


--- Start of backend/src/app/handlers/asset_file_extensions.py ---

AUDIO_FILETYPES: list[str] = [".mp3", ".wav"]
IMAGE_FILETYPES: list[str] = [".jpg", ".jpeg", ".png"]
DOCUMENT_FILETYPES: list[str] = [".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx"]
TEXT_FILETYPES: list[str] = [
    #
    # TEXT
    #
    ".txt",
    ".md",
    ".markdown",
    ".rst",
    #
    # LOG
    #
    ".log",
    #
    # CONFIG
    #
    ".cfg",
    ".conf",
    ".dockerfile",
    ".env",
    ".gitignore",
    ".ini",
    ".json",
    ".toml",
    ".xml",
    ".yaml",
    ".yml",
    #
    # DATA
    #
    ".csv",
    ".tsv",
    #
    # WEB
    #
    ".html",
    ".htm",
    ".css",
    #
    # CODE
    #
    ".js",
    ".ts",
    ".jsx",
    ".tsx",
    ".py",
    ".rb",
    ".php",
    ".java",
    ".c",
    ".cpp",
    ".h",
    ".hpp",
    ".cs",
    ".go",
    ".rs",
    ".swift",
    ".kt",
    ".scala",
    ".sh",
    ".bash",
    ".bat",
    ".ps1",
    ".sql",
    ".lua",
    ".pl",
    ".r",
    #
    # MARKUP
    #
    ".m",
    ".tex",
    ".bib",
]


--- Start of backend/src/app/handlers/message_sse.py ---

import asyncio
from collections.abc import AsyncGenerator
from uuid import UUID

import orjson
from fastapi import BackgroundTasks, Request
from sse_starlette import ServerSentEvent
from tribe_ai.common.tracing import tracer
from tribe_ai.services.agents import AgentResponse

from src.app.apis.models.message import MessageReadResponse
from src.app.handlers.agent import create_assets_from_output_files
from src.app.handlers.conversation import maybe_generate_and_update_conversation_name_in_background
from src.db import crud
from src.db.connect import DBSession
from src.logger import root_logger
from src.models import ConversationDTO, MessageDTO, MessageStatus


log = root_logger.getChild(__name__)
trace = tracer.get_tracer(__name__)


async def sse_message_generator(
    db: DBSession,
    background_tasks: BackgroundTasks,
    request: Request,
    agent_response_generator: AsyncGenerator[AgentResponse, None],
    message_response: MessageReadResponse,
    message_dto: MessageDTO,
    conversation_dto: ConversationDTO,
    user_uuid: UUID,
) -> AsyncGenerator[ServerSentEvent, None]:
    log.debug(f"Streaming message content for {message_dto.uuid}")
    partial_message = message_response.model_copy()
    partial_message.content = ""
    partial_message.status = MessageStatus.STARTING
    yield ServerSentEvent(data=orjson.dumps(partial_message.model_dump(mode="json", exclude_none=True)).decode("utf-8"))

    partial_message.status = MessageStatus.IN_PROGRESS
    agent_response = None
    interrupted = False
    try:
        with trace.start_as_current_span(
            "agent_response",
            attributes={
                "message_uuid": str(message_dto.uuid),
                "agent_uuid": str(message_dto.agent_uuid),
                "agent_config_uuid": str(message_dto.agent_config_uuid),
            },
        ):
            async for agent_response in agent_response_generator:
                if await request.is_disconnected():
                    log.info("Client disconnected, stopping message generation (disconnected)")
                    interrupted = True
                    break

                if agent_response.content:
                    partial_message.content = agent_response.content.strip()

                partial_message.reasoning = agent_response.reasoning
                partial_message.tool_use_response = agent_response.tool_use_response
                partial_message.generation_metadata = agent_response.generation_metadata
                data = orjson.dumps(partial_message.model_dump(mode="json", exclude_none=True)).decode("utf-8")
                yield ServerSentEvent(data=data)

            if not interrupted:
                conversation_name = await maybe_generate_and_update_conversation_name_in_background(
                    conversation_dto=conversation_dto, background_tasks=background_tasks
                )
                partial_message.conversation_name_updated_streaming = conversation_name

                log.debug(f"Streaming final message for {message_dto.uuid}")
                partial_message.status = MessageStatus.COMPLETED
                data = orjson.dumps(partial_message.model_dump(mode="json", exclude_none=True)).decode("utf-8")
                yield ServerSentEvent(data=data)

    except asyncio.CancelledError:
        log.info("Client disconnected, stopping message generation (CancelledError)")
        interrupted = True

    finally:
        with trace.start_as_current_span("data_persistence"):
            log.debug(f"Finalizing message {message_dto.uuid}")
            if agent_response and agent_response.reasoning:
                agent_response.reasoning = agent_response.reasoning.strip()

            message_dto.status = MessageStatus.INTERRUPTED if interrupted else MessageStatus.COMPLETED
            message_dto.content = partial_message.content
            message_dto.reasoning = agent_response.reasoning if agent_response else None
            message_dto.tool_use_response = agent_response.tool_use_response if agent_response else None
            message_dto.generation_metadata = agent_response.generation_metadata if agent_response else None
            if message_dto.tool_use_response:
                await create_assets_from_output_files(
                    db=db,
                    tool_use_response=message_dto.tool_use_response,
                    user_uuid=user_uuid,
                    agent_uuid=message_dto.agent_uuid,
                    conversation_uuid=message_dto.conversation_uuid,
                    message_uuid=message_dto.uuid,
                )

            await crud.message.update_message_and_close_session_after_sse(db=db, message_dto=message_dto)


--- Start of backend/src/agents/__init__.py ---

from src.agents.tools.data_analyst.sql.tool import SqlInputs, SqlOptions, SqlOutputs, SqlTool
from src.agents.tools.projects.find.tool import FindProjects, FindProjectsInputs, FindProjectsOutputs
from src.agents.tools.rag.document import DocumentRAG, DocumentRAGInputs, DocumentRAGOutputs
from src.agents.tools.sales.generate_interaction_demo import (
    GenerateInteractionDemo,
    GenerateInteractionDemoInputs,
    GenerateInteractionDemoOutputs,
)
from src.agents.tools.staffing.recommend_tribe_members.tool import (
    RecommendTribeMembers,
    RecommendTribeMembersInputs,
    RecommendTribeMembersOutputs,
)


__all__ = [
    "DocumentRAG",
    "DocumentRAGInputs",
    "DocumentRAGOutputs",
    "GenerateInteractionDemo",
    "GenerateInteractionDemoInputs",
    "GenerateInteractionDemoOutputs",
    "RecommendTribeMembers",
    "RecommendTribeMembersInputs",
    "RecommendTribeMembersOutputs",
    "FindProjects",
    "FindProjectsInputs",
    "FindProjectsOutputs",
    "SqlTool",
    "SqlInputs",
    "SqlOutputs",
    "SqlOptions",
]


--- Start of backend/src/agents/build_tools.py ---

from tribe_ai.services.agents.tools import BaseTool, tool_registry

from src.agents.tools.rag.document import DocumentRAG
from src.logger import root_logger
from src.models import AgentDTO, ConversationDTO


log = root_logger.getChild(__name__)


def build_tools_for_agent(agent_dto: AgentDTO, conversation_dto: ConversationDTO) -> list[BaseTool]:
    """
    Builds a list of tools for the given agent based on the agent's active configuration.

    Args:
        agent_dto: The agent's data transfer object.
        conversation_dto: The conversation's data transfer object.

    Returns:
        list[BaseTool]: A list of tools for the agent.
    """
    tool_registry_ids = (
        [tool.registry_id for tool in agent_dto.active_config.tools] if agent_dto.active_config.tools else []
    )

    if not tool_registry_ids:
        log.debug(f"No tools set for agent {agent_dto.uuid}")
        return []

    log.debug(f"Building tools for agent {agent_dto.uuid}")

    tools = []
    for tool_registry_id in tool_registry_ids:
        tool_class = tool_registry.get_class(tool_registry_id)
        tool_options = None
        tool_options_from_config: dict | None = next(
            (t.options for t in agent_dto.active_config.tools if t.registry_id == tool_registry_id), None
        )
        if tool_options_from_config:
            if not tool_class.options_class:
                raise ValueError(f"Tool options class not found for tool {tool_registry_id}")

            tool_options = tool_class.options_class(**tool_options_from_config)

        tools.append(tool_registry.create_instance(tool_registry_id, options=tool_options))

    for tool in tools:
        if isinstance(tool, DocumentRAG):
            tool.update_instructions_with_available_assets(agent_dto=agent_dto, conversation_dto=conversation_dto)

    return tools


--- Start of backend/src/agents/tools/__init__.py ---



--- Start of backend/src/agents/tools/data_analyst/sql/demo_schema.sql ---

CREATE TABLE customers (
	customer_id TEXT PRIMARY KEY,
	company_name TEXT,
	industry TEXT CHECK (
		industry IN (
			'Technology',
			'Financial Services',
			'Healthcare',
			'Manufacturing',
			'Retail'
		)
	),
	country TEXT,
	signup_date DATE,
	company_size TEXT CHECK (
		company_size IN (
			'10-50',
			'51-200',
			'201-500',
			'501-1000',
			'1000+'
		)
	),
	plan_type TEXT CHECK (plan_type IN ('Basic', 'Pro', 'Enterprise'))
);

CREATE TABLE subscription_events (
	event_id TEXT PRIMARY KEY,
	customer_id TEXT,
	event_type TEXT CHECK (
		event_type IN ('new', 'upgrade', 'downgrade', 'churn')
	),
	event_date DATE,
	mrr_change NUMERIC,
	new_plan_type TEXT CHECK (
		new_plan_type IN ('Basic', 'Pro', 'Enterprise', NULL)
	),
	previous_plan_type TEXT CHECK (
		previous_plan_type IN ('Basic', 'Pro', 'Enterprise', NULL)
	),
	FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE TABLE usage_stats (
	stat_id TEXT PRIMARY KEY,
	customer_id TEXT,
	month_date DATE,
	active_users INTEGER,
	total_logins INTEGER,
	storage_used_gb NUMERIC,
	api_calls INTEGER,
	FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE INDEX idx_subscription_events_customer_id ON subscription_events(customer_id);

CREATE INDEX idx_subscription_events_event_date ON subscription_events(event_date);

CREATE INDEX idx_usage_stats_customer_id ON usage_stats(customer_id);

CREATE INDEX idx_usage_stats_month_date ON usage_stats(month_date);


--- Start of backend/src/agents/tools/data_analyst/sql/__init__.py ---



--- Start of backend/src/agents/tools/data_analyst/sql/demo_schema_notes.txt ---

1. customers
   - customer_id (UUID, primary key)
   - company_name (text)
   - industry (text: Technology, Financial Services, Healthcare, Manufacturing, Retail)
   - country (text)
   - signup_date (date)
   - company_size (text: 10-50, 51-200, 201-500, 501-1000, 1000+)
   - plan_type (text: Basic, Pro, Enterprise)

2. subscription_events
   - event_id (UUID, primary key)
   - customer_id (UUID, foreign key to customers.customer_id)
   - event_type (text: new, upgrade, downgrade, churn)
   - event_date (date)
   - mrr_change (numeric)
   - new_plan_type (text: Basic, Pro, Enterprise, or NULL for churn)
   - previous_plan_type (text: Basic, Pro, Enterprise, or NULL for new)

3. usage_stats
   - stat_id (UUID, primary key)
   - customer_id (UUID, foreign key to customers.customer_id)
   - month_date (date)
   - active_users (integer)
   - total_logins (integer)
   - storage_used_gb (numeric)
   - api_calls (integer)


--- Start of backend/src/agents/tools/data_analyst/sql/tool.py ---

import csv
import sqlite3
from pathlib import Path
from typing import Any

from pydantic import Field, SecretStr
from sqlalchemy import URL, make_url, text
from sqlalchemy.engine import Result
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from src.logger import root_logger
from src.settings import global_settings
from tribe_ai.services.agents.tools import (
    BaseTool,
    ToolInputs,
    ToolOptions,
    ToolOutputs,
    ToolUseInfo,
    ToolUseRequest,
    ToolUseStatus,
    tool_registry,
)


log = root_logger.getChild(__name__)


class SqlInputs(ToolInputs):
    sql: str = Field(..., examples=["SELECT * FROM tribe_members WHERE name = 'John Doe'"])


class SqlOutputs(ToolOutputs):
    std_out: str = Field(..., examples=["output from the SQL query"])


class SqlOptions(ToolOptions):
    db_uri: SecretStr | None = Field(
        None,
        description="The database connection string, for example: 'postgresql+asyncpg://user:password@localhost/dbname'. Leave empty for interaction with a demo database.",
    )
    schema_definition: str = Field("", description="Schema of the SQL database")
    schema_notes: str = Field("", description="Additional notes about the schema, explaining the tables and columns")
    truncate_output_to_max_characters: int = Field(
        400_000, description="Truncate the query output if it exceeds this number of characters", examples=["400_000"]
    )


@tool_registry.register()
class SqlTool(BaseTool[SqlInputs, SqlOutputs]):
    display_name = "SQL"
    description = "Allows the agent to execute SQL queries against a database. "
    tool_instructions = """This tool allows you to execute SQL queries against a database.
The connection protocol is: {connection_protocol}, you can use this to determine the dialect and supported operations.
The database has the following SQL schema:

{sql_schema}

The schema is further explained in these notes:

{schema_notes}

IMPORTANT:
- Only use functions available in the database's SQL dialect.
- Do not use any DDL (Data Definition Language) statements, such as CREATE, ALTER, DROP, etc.
- Do not use any DML (Data Manipulation Language) statements, such as INSERT, UPDATE, DELETE, etc.
- Do not use any DCL (Data Control Language) statements, such as GRANT, REVOKE, etc.
- Do not use any TCL (Transaction Control Language) statements, such as COMMIT, ROLLBACK, etc.
- Do not use any functions that modify the database state.
- When calling this tool, ALWAYS encode newlines as "\\n" in your SQL queries, as newlines are not supported in the input field.
- You can only execute one statement at a time.
- If the results for some reason do not contain the necessary data to answer the question, explain that to the user.
- The SQL you execute and the results produced will be appended to your message, so DO NOT include them in your message.
- Messages you write will be rendered as Markdown.
- Always explain the results in a way that is understandable to the average user.
"""

    inputs_class = SqlInputs
    outputs_class = SqlOutputs
    options_class = SqlOptions
    options: SqlOptions

    def __init__(self, options: SqlOptions | None = None, **kwargs: Any) -> None:
        super().__init__(options=options, **kwargs)
        self._demo_db_path = global_settings.tools.data_analyst_sql_tool_demo_db_path
        self._demo_schema_definition = (Path(__file__).parent / "demo_schema.sql").read_text()
        self._demo_schema_notes = (Path(__file__).parent / "demo_schema_notes.txt").read_text()

        self.options = options or SqlOptions()  # type: ignore[call-arg]
        if not self.options.db_uri:
            self._init_demo_db()
            self.options.db_uri = SecretStr(f"sqlite:///{self._demo_db_path.resolve()}")
            self.options.schema_definition = self.options.schema_definition or self._demo_schema_definition
            self.options.schema_notes = self.options.schema_notes or self._demo_schema_notes
        else:
            self.options.schema_definition = self.options.schema_definition or "(no schema provided)"
            self.options.schema_notes = self.options.schema_notes or "(no schema notes provided)"

        self._db_uri = make_url(str(self.options.db_uri.get_secret_value()))
        self._db_uri = self._ensure_db_uri_async(self._db_uri)
        log.debug(f"Using DB URI: {self._db_uri}")

        self._connection_protocol = self._db_uri.drivername.split("+")[0]
        self._async_engine = create_async_engine(self._db_uri, echo=global_settings.db.echo)
        self._async_session_maker = sessionmaker(bind=self._async_engine, class_=AsyncSession, expire_on_commit=False)  # type: ignore[call-overload]

        self.tool_instructions = self.tool_instructions.format(
            connection_protocol=self._connection_protocol,
            sql_schema=self.options.schema_definition,
            schema_notes=self.options.schema_notes,
        )

        log.info(f"SqlTool initialized with connection string: {self._db_uri}")

    async def _use(
        self, inputs: SqlInputs, tool_use_info: ToolUseInfo, tool_use_request: ToolUseRequest
    ) -> tuple[SqlOutputs | None, ToolUseInfo]:
        if self.options is None:
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = "No options provided for the SQL tool."
            return None, tool_use_info

        try:
            self._validate_query(inputs.sql)
        except ValueError as e:
            log.exception("SQL query validation failed.")
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = f"SQL query validation failed: {e}"
            return None, tool_use_info

        try:
            async with self._async_session_maker() as session:
                result = await session.execute(text(inputs.sql))
        except Exception as e:
            log.exception("Failed to execute SQL query.")
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = f"SQL query execution failed: {e}"
            return None, tool_use_info

        results_as_table = self._format_results_as_markdown_table(result=result)
        if len(results_as_table) > self.options.truncate_output_to_max_characters:
            results_as_table = results_as_table[: self.options.truncate_output_to_max_characters] + " ... (truncated)"

        return SqlOutputs(std_out=results_as_table), tool_use_info

    def _validate_query(self, query: str) -> None:
        if not query:
            raise ValueError("SQL query cannot be empty.")

        mutating_keywords = [
            "CREATE",
            "ALTER",
            "DROP",
            "INSERT",
            "UPDATE",
            "DELETE",
            "GRANT",
            "REVOKE",
            "COMMIT",
            "ROLLBACK",
        ]
        for keyword in mutating_keywords:
            if keyword in query.upper():
                raise ValueError(f"SQL query contains a mutating keyword: {keyword}")

    def _format_results_as_markdown_table(self, result: Result) -> str:
        columns = result.keys()
        rows = result.fetchall()
        header = "| " + " | ".join(columns) + " |"
        separator = "|---" * len(columns) + "|"

        formatted_rows: list[str] = []
        for row in rows:
            formatted_row = "| " + " | ".join(map(str, row)) + " |"
            formatted_rows.append(formatted_row)

        return "\n".join([header, separator, *formatted_rows])

    def _init_demo_db(self) -> None:
        if self._demo_db_path.exists():
            return

        self._demo_db_path.parent.mkdir(parents=True, exist_ok=True)
        demo_db = sqlite3.connect(self._demo_db_path)
        demo_db.executescript(self._demo_schema_definition)
        demo_db.close()
        self._load_demo_data()
        log.info(f"Initialized demo database at {self._demo_db_path}")

    def _load_demo_data(self) -> None:
        demo_data_path = global_settings.tools.data_analyst_sql_tool_demo_data_dir
        csv_paths = list(Path(demo_data_path).glob("*.csv"))
        if not csv_paths:
            log.warning(f"No CSV files found in the demo data path: {demo_data_path}")
            return

        conn = sqlite3.connect(self._demo_db_path)
        cursor = conn.cursor()
        for csv_path in csv_paths:
            table_name = csv_path.stem
            log.info(f"Loading data from {csv_path} into table {table_name}")

            try:
                with csv_path.open("r", newline="") as csv_file:
                    csv_reader = csv.reader(csv_file)
                    headers = next(csv_reader)
                    placeholders = ", ".join(["?" for _ in headers])
                    insert_query = f"INSERT INTO {table_name} ({', '.join(headers)}) VALUES ({placeholders})"  # noqa: S608
                    for row in csv_reader:
                        if not any(row):
                            continue

                        processed_row: list[str | None] = []
                        for item in row:
                            if item == "":
                                processed_row.append(None)
                            else:
                                processed_row.append(item)

                        try:
                            cursor.execute(  # nosemgrep: python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query
                                insert_query, processed_row
                            )
                        except sqlite3.Error:
                            log.exception(f"Error inserting row {processed_row}")
                            continue

                conn.commit()
                log.info(f"Successfully loaded data from {csv_path}")

            except Exception:
                log.exception(f"Error processing {csv_path}")
                conn.rollback()

        conn.close()
        log.info("Completed loading all demo data into the database.")

    def _ensure_db_uri_async(self, db_uri: URL) -> URL:
        if db_uri.drivername == "postgresql":
            return URL(
                drivername="postgresql+asyncpg",
                username=db_uri.username,
                password=db_uri.password,
                host=db_uri.host,
                port=db_uri.port,
                database=db_uri.database,
                query=db_uri.query,
            )

        if db_uri.drivername == "sqlite":
            return URL(
                drivername="sqlite+aiosqlite",
                username=db_uri.username,
                password=db_uri.password,
                host=db_uri.host,
                port=db_uri.port,
                database=db_uri.database,
                query=db_uri.query,
            )

        return db_uri


--- Start of backend/src/agents/tools/sales/__init__.py ---



--- Start of backend/src/agents/tools/sales/generate_interaction_demo.py ---

from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import Any

from PIL import Image, ImageDraw, ImageFont
from pydantic import BaseModel, Field
from tribe_ai.clients.search.fulltext.base import BaseFulltextSearchClient
from tribe_ai.services.agents.tools import (
    BaseTool,
    ToolInputs,
    ToolOptions,
    ToolOutputFile,
    ToolOutputs,
    ToolUseInfo,
    ToolUseRequest,
    ToolUseStatus,
    tool_registry,
)

from src.logger import root_logger


log = root_logger.getChild(__name__)


class InteractionUserType(StrEnum):
    USER = "User"
    ASSISTANT = "Assistant"


class InteractionMessage(BaseModel):
    speaker: InteractionUserType
    text: str


class GenerateInteractionDemoInputs(ToolInputs):
    messages: list[InteractionMessage] = Field(
        ..., examples=[[{"speaker": "User", "text": "Hello"}, {"speaker": "Assistant", "text": "Hi"}]]
    )


class GenerateInteractionDemoOutputs(ToolOutputs):
    filename: str = Field(..., examples=["interaction_demo_20220101_000000.gif"])


@tool_registry.register()
class GenerateInteractionDemo(BaseTool[GenerateInteractionDemoInputs, GenerateInteractionDemoOutputs]):
    """
    Tool that generates a demo interaction based on a list of messages.
    """

    display_name = "Generate Interaction Demo"
    description = "Generates a demo interaction based on a list of messages."
    tool_instructions = "This tool generates a demo interaction based on a list of messages. Messages must be either from 'User' or 'Assistant'."

    inputs_class = GenerateInteractionDemoInputs
    outputs_class = GenerateInteractionDemoOutputs

    _search_client: BaseFulltextSearchClient

    def __init__(self, options: ToolOptions | None = None, **kwargs: Any) -> None:
        super().__init__(options=options, **kwargs)

        self._assets_path = Path(__file__).parent / "assets"
        self._emoji_robot_png_path = self._assets_path / "emoji_robot.png"
        self._emoji_user_png_path = self._assets_path / "emoji_user.png"
        self.font_path = Path(__file__).parent / "assets" / "Roboto-Regular.ttf"
        self.font_size = 16
        self.line_length = 100

        if not self._emoji_robot_png_path.exists():
            raise FileNotFoundError(f"Robot emoji not found: {self._emoji_robot_png_path}")

        if not self._emoji_user_png_path.exists():
            raise FileNotFoundError(f"User emoji not found: {self._emoji_user_png_path}")

        if not self.font_path.exists():
            raise FileNotFoundError(f"Font file not found: {self.font_path}")

        self.font = ImageFont.truetype(font=str(self.font_path), size=self.font_size)
        self._emoji_size = (self.font_size, self.font_size)
        self._emoji_user = self._load_png(self._emoji_user_png_path, self._emoji_size)
        self._emoji_robot = self._load_png(self._emoji_robot_png_path, self._emoji_size)

    async def _use(
        self, inputs: GenerateInteractionDemoInputs, tool_use_info: ToolUseInfo, tool_use_request: ToolUseRequest
    ) -> tuple[GenerateInteractionDemoOutputs | None, ToolUseInfo]:
        if tool_use_request.context_dir is None:
            log.error("context_dir is required but not provided, cannot save output files")
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = "context_dir is required but not provided, cannot save output files"
            return None, tool_use_info

        try:
            timestamp = datetime.now(tz=UTC).strftime("%Y%m%d_%H%M%S")
            filename = f"interaction_demo_{timestamp}.gif"
            file_path = tool_use_request.context_dir / filename
            self._generate_gif(messages=inputs.messages, output_file=file_path)
            tool_use_info.output_files.append(
                ToolOutputFile(name="Interaction Demo", description="Generated interaction demo", local_path=file_path)
            )
            return GenerateInteractionDemoOutputs(filename=str(filename)), tool_use_info

        except Exception as e:
            log.exception("Failed to generate interaction demo")
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = f"Failed to generate interaction demo: {e}"
            return None, tool_use_info

    def _generate_gif(
        self,
        messages: list[InteractionMessage],
        output_file: Path,
        width: int = 800,
        height: int = 600,
        fps: int = 3,
        inter_message_pause_duration_seconds: int = 1,
    ) -> None:
        line_height = 20
        num_lines = height // line_height - 2
        frames: list[Image.Image] = []
        all_lines: list[str] = []

        for message in messages:
            message_start_index = len(all_lines)  # Track where this message starts

            # Add speaker line
            all_lines.append(f"{message.speaker.value}:")

            # Add content lines (simple word wrap)
            words = message.text.split()
            current_line: list[str] = []
            for word in words:
                if len(" ".join([*current_line, word])) > self.line_length:
                    all_lines.append(" ".join(current_line))
                    current_line = [word]
                else:
                    current_line.append(word)

            if current_line:
                all_lines.append(" ".join(current_line))

            # Add empty line between messages
            all_lines.append("")

            # Create frames up to the end of current message
            for i in range(message_start_index, len(all_lines) + 1):
                visible_lines = all_lines[:i]
                if len(visible_lines) > num_lines:
                    visible_lines = visible_lines[-num_lines:]

                frame = self._create_frame(visible_lines, width, height)
                frames.append(frame)

            # Add pause after the message is complete by duplicating the last frame
            if frames:
                pause_frames = [frames[-1]] * int(fps * inter_message_pause_duration_seconds)
                frames.extend(pause_frames)

        if not frames:
            raise ValueError("No frames were created.")

        # Add 10 second pause at the end
        frames.extend([frames[-1]] * (10 * fps))

        frames[0].save(output_file, save_all=True, append_images=frames[1:], duration=1000 // fps, loop=1)

    def _load_png(self, png_path: Path, size: tuple[int, int]) -> Image.Image:
        return Image.open(png_path).resize(size)

    def _create_frame(self, lines: list[str], width: int, height: int) -> Image.Image:
        image = Image.new("RGB", (width, height), color="white")
        draw = ImageDraw.Draw(image)
        y_position = 10
        line_height = 20
        emoji_padding = 5

        for line in lines:
            if line.startswith("Assistant:"):
                image.paste(self._emoji_robot, (10, y_position), self._emoji_robot)
            elif line.startswith("User:"):
                image.paste(self._emoji_user, (10, y_position), self._emoji_user)

            draw.text((10 + self.font_size + emoji_padding, y_position), line, font=self.font, fill="black")
            y_position += line_height

        return image


--- Start of backend/src/agents/tools/projects/__init__.py ---



--- Start of backend/src/agents/tools/projects/find/models.py ---

import json

from pydantic import BaseModel, ConfigDict, field_validator

from src.logger import root_logger


log = root_logger.getChild(__name__)


class AirtableProject(BaseModel):
    uuid: str
    account_name: str | None = None
    opportunity_name: str | None = None
    product_type: str | None = None
    model_type: list[str] | None = None
    llm: list[str] | None = None
    cloud_provider: list[str] | None = None
    cloud_services_used: list[str] | None = None
    other_services_used: list[str] | None = None
    members_from_th_project: list[str] | None = None
    use_case: str | None = None
    pe_investor: list[str] | None = None
    last_modified: str | None = None
    embedding: list[float] | None = None
    sales_stage: str | None = None
    anticipated_business_value: str | None = None
    overview: str | None = None
    demo: str | None = None
    technical_summary: str | None = None
    record_id: str | None = None
    delivery_stage: str | None = None
    page_link: str | None = None

    @field_validator(
        "model_type",
        "llm",
        "cloud_provider",
        "cloud_services_used",
        "other_services_used",
        "members_from_th_project",
        "pe_investor",
        mode="before",
    )
    @classmethod
    def parse_stringified_list(cls, v: str | list[str] | None) -> list[str] | None:
        if not v:
            return None

        if isinstance(v, str):
            return json.loads(v)

        return v

    model_config = ConfigDict(extra="ignore")


--- Start of backend/src/agents/tools/projects/find/search_index.py ---

from tribe_ai.clients.search import SearchIndexSchema


tribe_project_search_index = SearchIndexSchema(
    index_name="tribe_project",
    indexed_fields=[
        "account_name",
        "opportunity_name",
        "product_type",
        "model_type",
        "llm",
        "cloud_provider",
        "cloud_services_used",
        "other_services_used",
        "members_from_th_project",
        "use_case",
        "pe_investor",
        "demo",
        "technical_summary",
        "overview",
        "anticipated_business_value",
        "record_id",
    ],
    filterable_fields=["sales_stage", "delivery_stage"],
    embedding_field="embedding",
    datetime_fields=["last_modified"],
    extra_fields=[],
)


--- Start of backend/src/agents/tools/projects/find/__init__.py ---



--- Start of backend/src/agents/tools/projects/find/tool.py ---

from typing import Any

from pydantic import Field
from tribe_ai.clients.embedding.config import EmbeddingConfig
from tribe_ai.clients.search import IndexableSearchDocument, SearchQuery, SearchSort
from tribe_ai.clients.search.hybrid.base import BaseHybridSearchClient
from tribe_ai.services.agents.tools import (
    BaseTool,
    ToolInputs,
    ToolOptions,
    ToolOutputFormatting,
    ToolOutputs,
    ToolUseInfo,
    ToolUseRequest,
    ToolUseStatus,
    tool_registry,
)

from src.agents.tools.projects.find.models import AirtableProject
from src.agents.tools.projects.find.search_index import tribe_project_search_index
from src.clients.airtable.client import AirtableClient
from src.ingestion.initialize import get_or_create_embedding_client
from src.logger import root_logger
from src.search.connect import get_hybrid_search_client
from src.settings import global_settings


log = root_logger.getChild(__name__)

_CLOSED_SALES_STAGE = "6 - Closed Won"


def convert_project_to_llm_format(project: AirtableProject) -> str:
    attributes = {
        "Account Name": project.account_name,
        "Opportunity Name": project.opportunity_name,
        "Product Types": project.product_type,
        "Model Types": project.model_type,
        "LLMs": project.llm,
        "Cloud Providers": project.cloud_provider,
        "Cloud Services Used": project.cloud_services_used,
        "Other Services Used": project.other_services_used,
        "Members (from TH Project)": project.members_from_th_project,
        "Use Case": project.use_case,
        "PE Investors": project.pe_investor,
        "Anticipated Business Value": project.anticipated_business_value,
        "Overview": project.overview,
        "Demo link": project.demo,
        "Technical Summary link": project.technical_summary,
        "Page Link": project.page_link,
    }

    return "\n".join(f"{label}: {value}" for label, value in attributes.items() if value is not None)


class FindProjectsOptions(ToolOptions):
    limit: int = Field(default=10, gt=0)


class FindProjectsInputs(ToolInputs):
    query: str = Field(..., examples=["provider search terms here (e.g. Python, do not use search operators like AND)"])


class FindProjectsOutputs(ToolOutputs):
    projects: list[AirtableProject] = Field(
        ...,
        examples=[
            {
                "uuid": "123",
                "account_name": "Tribe",
                "opportunity_name": "Tribe Opportunity",
                "product_type": "Python",
                "model_type": "Python",
                "llm": "Python",
                "cloud_provider": "Python",
                "cloud_services_used": "Python",
                "other_services_used": "Python",
                "members_from_th_project": "Python",
            }
        ],
    )

    def display_to_llm(
        self, tool_name: str, inputs: ToolInputs, formatting: ToolOutputFormatting = ToolOutputFormatting.JSON
    ) -> str:
        return "\n\n".join([convert_project_to_llm_format(p) for p in self.projects])


@tool_registry.register()
class FindProjects(BaseTool[FindProjectsInputs, FindProjectsOutputs]):
    """
    Tool that finds projects based on their description.
    """

    display_name = "Tribe Project Database"
    description = "Find projects based on their description and details."
    tool_instructions = "Provide a search query to find Tribe projects."

    inputs_class = FindProjectsInputs
    outputs_class = FindProjectsOutputs
    options_class = FindProjectsOptions
    options = FindProjectsOptions()

    # Note: this is a subset of the fields in the Airtable table.
    _AIRTABLE_FIELDS = [
        "Account Name",
        "Opportunity Name",
        "Use Case Details",
        "Product Type",
        "Model Type",
        "LLM",
        "Cloud Provider",
        "Cloud Services Used",
        "Other Services Used",
        "Members (from TH Project)",
        "Use Case",
        "PE Investor",
        "Sales Stage",
        "Anticipated Business Value",
        "Overview",
        "Last Modififed",
        "Demo",
        "Technical Summary",
        "Record ID",
        "Delivery Stage",
    ]

    _search_index_name: str = "tribe_project"
    _search_client: BaseHybridSearchClient

    def __init__(self, options: FindProjectsOptions | None = None, **kwargs: Any) -> None:
        super().__init__(options=options, **kwargs)
        self.options = options or FindProjectsOptions()
        self._search_index_schema = tribe_project_search_index
        self._search_client = get_hybrid_search_client()
        self._embedding_client = get_or_create_embedding_client(
            global_settings.search.embedding_model_id,
            config=EmbeddingConfig(
                api_key=global_settings.search.embedding_api_key,
                base_url=global_settings.search.embedding_base_url,
            ),
            caching=False,
        )
        self._airtable_client = AirtableClient()

    async def _use(
        self, inputs: FindProjectsInputs, tool_use_info: ToolUseInfo, tool_use_request: ToolUseRequest
    ) -> tuple[FindProjectsOutputs | None, ToolUseInfo]:
        try:
            await self._index_projects_if_needed()

            search_query = SearchQuery(
                query=inputs.query,
                index_name=self._search_index_name,
                limit=self.options.limit,
                filters={"sales_stage": _CLOSED_SALES_STAGE},
            )

            search_results = await self._search_client.query(query=search_query)

            # TODO(tomi): create ProjectSearchResult model to fix types and clean up this check
            projects = [
                AirtableProject(
                    **doc.model_dump(exclude={"uuid", "embedding"}),
                    page_link=self._airtable_client.get_project_page_link(doc.record_id)  # type: ignore[attr-defined]
                    if getattr(doc, "record_id", None)
                    else None,
                    uuid=str(doc.uuid),
                    embedding=None,
                )
                for doc in search_results.hits
                if doc.delivery_stage  # type: ignore[attr-defined]
            ]
            return FindProjectsOutputs(projects=projects), tool_use_info
        except Exception as e:
            log.exception("Failed to retrieve projects.")
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = f"Failed to retrieve projects: {e}"
            return None, tool_use_info

    async def _index_projects_if_needed(self) -> None:
        projects = await self._pull_projects()
        if not projects:
            return

        indexable_dicts = [self._search_index_schema.filter_and_cast_indexable_fields(p.model_dump()) for p in projects]
        indexable_documents = [IndexableSearchDocument(**d) for d in indexable_dicts]

        await self._search_client.index_documents(indexable_documents, self._search_index_schema)

    async def _pull_projects(self) -> list[AirtableProject]:
        last_modified_date = await self._get_last_modified_date()

        date_filter = f"LAST_MODIFIED_TIME() > '{last_modified_date}'" if last_modified_date else None

        table = self._airtable_client.get_projects_table()
        if not table:
            return []

        results = table.all(formula=date_filter, fields=self._AIRTABLE_FIELDS)

        projects = [
            AirtableProject(
                account_name=doc["fields"].get("Account Name"),
                opportunity_name=doc["fields"].get("Opportunity Name"),
                product_type=doc["fields"].get("Product Type"),
                model_type=doc["fields"].get("Model Type"),
                llm=doc["fields"].get("LLM"),
                cloud_provider=doc["fields"].get("Cloud Provider"),
                cloud_services_used=doc["fields"].get("Cloud Services Used"),
                other_services_used=doc["fields"].get("Other Services Used"),
                members_from_th_project=doc["fields"].get("Members (from TH Project)"),
                use_case=doc["fields"].get("Use Case Details"),
                pe_investor=doc["fields"].get("PE Investor"),
                last_modified=doc["fields"].get("Last Modififed"),
                uuid=str(doc["id"]),
                sales_stage=doc["fields"].get("Sales Stage"),
                anticipated_business_value=doc["fields"].get("Anticipated Business Value"),
                overview=doc["fields"].get("Overview"),
                demo=doc["fields"].get("Demo"),
                technical_summary=doc["fields"].get("Technical Summary"),
                record_id=doc["fields"].get("Record ID"),
                delivery_stage=doc["fields"].get("Delivery Stage"),
                embedding=None,
            )
            for doc in results
        ]

        embeddings = await self._embedding_client.embed_batch([convert_project_to_llm_format(p) for p in projects])

        for project, embedding in zip(projects, embeddings, strict=True):
            project.embedding = embedding.embedding

        return projects

    async def _get_last_modified_date(self) -> str | None:
        search_query = SearchQuery(
            query="", index_name=self._search_index_name, limit=1, sort=SearchSort(field="last_modified", order="desc")
        )
        search_results = await self._search_client.query(query=search_query)
        projects = [
            AirtableProject(**doc.model_dump(exclude={"uuid"}), uuid=str(doc.uuid)) for doc in search_results.hits
        ]
        if not projects:
            return None
        return projects[0].last_modified


--- Start of backend/src/agents/tools/rag/__init__.py ---



--- Start of backend/src/agents/tools/rag/document.py ---

from collections import defaultdict
from datetime import UTC, datetime, timedelta
from typing import Any, Self

import yaml
from pydantic import ConfigDict, Field, model_validator
from tribe_ai.clients.search import SearchIndexResults, SearchIndexSchema, SearchQuery
from tribe_ai.clients.search.fulltext.base import BaseFulltextSearchClient
from tribe_ai.clients.search.hybrid.base import BaseHybridSearchClient
from tribe_ai.clients.search.vector.base import BaseVectorSearchClient
from tribe_ai.services.agents.tools import (
    BaseTool,
    ToolInputs,
    ToolOptions,
    ToolOutputs,
    ToolUseInfo,
    ToolUseRequest,
    ToolUseStatus,
    tool_registry,
)

from src.logger import root_logger
from src.models import AgentDTO, AssetDTO, ConversationDTO
from src.search.connect import (
    SearchClient,
    get_fulltext_search_client,
    get_hybrid_search_client,
    get_vector_search_client,
)


log = root_logger.getChild(__name__)


class DocumentRAGOptions(ToolOptions):
    search_client: SearchClient = Field(default=SearchClient.HYBRID)

    # Note: since we use enum, we need to manually provide the schema so it does not apply
    # the default enum schema from pydantic
    model_config = ConfigDict(
        extra="forbid",
        json_schema_extra={
            "properties": {
                "search_client": {
                    "enum": [SearchClient.HYBRID, SearchClient.VECTOR, SearchClient.TEXT],
                    "title": "SearchClient",
                    "type": "string",
                    "default": SearchClient.HYBRID,
                }
            }
        },
    )


class DocumentRAGInputs(ToolInputs):
    asset_uuids: list[str] = Field(default_factory=list, examples=[["example-uuid"]])
    query: str = Field(
        default="",
        examples=[
            "If supplied, query will be used to search text in a document content, returning chunks that contain the query."
        ],
    )


class DocumentRAGOutputs(ToolOutputs):
    results: list[dict] = Field(
        default_factory=list,
        examples=[
            {
                "uuid": "example-uuid",
                "created_at": "2021-01-01T00:00:00Z",
                "summary": "This is a summary.",
                "filename": "document.pdf",
                "content_chunks": [
                    {
                        "text": "This is a chunk of text.",
                        "asset_uuid": "example-uuid",
                        "created_at": "2021-01-01T00:00:00Z",
                    },
                    {
                        "text": "This is another chunk of text.",
                        "asset_uuid": "example-uuid",
                        "created_at": "2021-01-01T00:00:00Z",
                    },
                ],
            }
        ],
    )

    @model_validator(mode="after")
    def remove_embeddings(self) -> Self:
        for result in self.results:
            if "content_chunks" in result:
                for chunk in result["content_chunks"]:
                    chunk.pop("embedding", None)

        return self

    def display_to_llm_custom(self, tool_name: str, inputs: ToolInputs) -> str:
        response: dict[str, Any] = {"results": []}

        for document in self.results:
            document_response = {
                "document": document["filename"],
                "summary": document["summary"],
                "metadata": {
                    "created_at": document["created_at"],
                },
            }
            if document["content_chunks"]:
                document_response["content_chunks"] = [
                    {
                        "text": content_chunk["content_processed"],
                    }
                    for content_chunk in document["content_chunks"]
                ]

            response["results"].append(document_response)

        documents_text = yaml.dump(response, default_flow_style=False)
        asset_names = [result["filename"] for result in self.results]
        return f"Documents found by {tool_name} with inputs {', '.join(asset_names)}:\n{documents_text}"


@tool_registry.register()
class DocumentRAG(BaseTool[DocumentRAGInputs, DocumentRAGOutputs]):
    """
    Retrieves information about uploaded files (assets) added to the conversation.
    This tool retrieves information about the document as a whole, or about specific content chunks.
    """

    display_name = "Document RAG Tool"
    description = "Queries a search index to retrieve information about files (assets) added to the conversation."
    tool_instructions = "If the users asks general questions about one or more files, this tool can be used to retrieve document-level information such as a document summary."

    inputs_class = DocumentRAGInputs
    outputs_class = DocumentRAGOutputs
    options_class = DocumentRAGOptions
    options: DocumentRAGOptions | None = None

    _search_client: BaseFulltextSearchClient | BaseHybridSearchClient | BaseVectorSearchClient

    document_index_name = "ingestion_document"
    content_index_name = "ingestion_chunk"
    index_description = "Document-level information about uploaded files"

    def update_instructions_with_available_assets(
        self, agent_dto: AgentDTO | None = None, conversation_dto: ConversationDTO | None = None
    ) -> None:
        log.debug("Updating tool instructions with available assets")
        agent_assets = agent_dto.assets if agent_dto else []
        conversation_assets = conversation_dto.assets if conversation_dto else []
        assets = agent_assets + conversation_assets
        log.debug(f"Found {len(agent_assets)} agent assets and {len(conversation_assets)} conversation assets")

        available_assets_text = self._format_available_assets(available_assets=assets)
        self.tool_instructions = f"{self.tool_instructions}\n\n{available_assets_text}"

    async def _use(
        self, inputs: DocumentRAGInputs, tool_use_info: ToolUseInfo, tool_use_request: ToolUseRequest
    ) -> tuple[DocumentRAGOutputs | None, ToolUseInfo]:
        log.debug(f"Using DocumentRAG with options: {self.options}")

        options = self.options or DocumentRAGOptions()
        self._configure_search_client(options)

        try:
            document_results, content_results = await self._search(
                inputs=inputs,
                tool_use_request=tool_use_request,
                document_search_index=self._document_search_index,
                content_search_index=self._content_search_index,
            )
            formatted_document_results = self._format_results(
                index_results=document_results, search_index=self._document_search_index
            )

            formatted_content_results: list[dict] = []
            if content_results:
                formatted_content_results = self._format_results(
                    index_results=content_results, search_index=self._content_search_index
                )
            formatted_results = self._merge_results(
                document_results=formatted_document_results, content_results=formatted_content_results
            )
        except Exception as e:
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = str(e)
            return None, tool_use_info

        return DocumentRAGOutputs(results=formatted_results), tool_use_info

    def _configure_search_client(self, options: DocumentRAGOptions) -> None:
        if options.search_client == SearchClient.VECTOR:
            self._search_client = get_vector_search_client()
        elif options.search_client == SearchClient.TEXT:
            self._search_client = get_fulltext_search_client()
        else:
            self._search_client = get_hybrid_search_client()

        document_search_index = self._search_client.get_registered_index_schema(self.document_index_name)
        content_search_index = self._search_client.get_registered_index_schema(self.content_index_name)
        if not document_search_index or not content_search_index:
            raise ValueError(f"Search index '{self.document_index_name}' or '{self.content_index_name}' not found")

        self._document_search_index = document_search_index
        self._content_search_index = content_search_index

    async def _search(
        self,
        inputs: DocumentRAGInputs,
        tool_use_request: ToolUseRequest,
        document_search_index: SearchIndexSchema,
        content_search_index: SearchIndexSchema,
    ) -> tuple[SearchIndexResults, SearchIndexResults | None]:
        document_results = await self._search_index(
            asset_uuids=inputs.asset_uuids,
            query="",
            tool_use_request=tool_use_request,
            search_index=document_search_index,
        )
        content_results: SearchIndexResults | None = None
        if inputs.query:
            content_results = await self._search_index(
                asset_uuids=inputs.asset_uuids,
                query=inputs.query,
                tool_use_request=tool_use_request,
                search_index=content_search_index,
            )

        return document_results, content_results

    async def _search_index(
        self, asset_uuids: list[str], query: str, tool_use_request: ToolUseRequest, search_index: SearchIndexSchema
    ) -> SearchIndexResults:
        filters: dict[str, str | list[str]] = {
            k: v for k, v in tool_use_request.generation_context.items() if k in search_index.filterable_fields
        }

        if asset_uuids:
            filters["asset_uuid"] = asset_uuids

        search_query = SearchQuery(
            index_name=search_index.index_name,
            query=query,
            filters=filters,
            limit=10,
        )
        return await self._search_client.query(query=search_query)

    async def _rerank(self, index_results: SearchIndexResults) -> SearchIndexResults:
        raise NotImplementedError

    def _format_results(self, index_results: SearchIndexResults, search_index: SearchIndexSchema) -> list[dict]:
        formatted_results: list[dict] = []

        for result in sorted(index_results.hits, key=lambda x: x.ranking_score, reverse=True):
            result_dict = {"created_at": result.created_at, "ranking_score": result.ranking_score}
            for field_name in search_index.get_fields():
                field_value = getattr(result, field_name, None)
                if field_value:
                    result_dict[field_name] = field_value

            formatted_results.append(result_dict)

        return formatted_results

    def _merge_results(self, document_results: list[dict], content_results: list[dict]) -> list[dict]:
        content_results_by_asset_uuid: dict[str, list[dict]] = defaultdict(list)
        for result in content_results:
            content_results_by_asset_uuid[result["asset_uuid"]].append(result)
        merged_results: list[dict] = []
        for document_result in document_results:
            merged_result = document_result.copy()
            merged_result["content_chunks"] = content_results_by_asset_uuid.get(document_result["asset_uuid"], [])
            merged_results.append(merged_result)

        return merged_results

    def _format_available_assets(self, available_assets: list[AssetDTO] | None) -> str:
        if not available_assets:
            return "The user has not uploaded any files yet."

        fields = {"uuid", "created_at", "original_filename", "type", "size_bytes", "ingestion_status"}
        asset_dicts = [asset.model_dump(include=fields, mode="json") for asset in available_assets]
        for asset_dict in asset_dicts:
            delta = datetime.now(UTC) - datetime.fromisoformat(asset_dict["created_at"])
            asset_dict["created_ago"] = self._format_timedelta(delta)
            asset_dict["filename"] = asset_dict.pop("original_filename")

        assets_text = yaml.dump(asset_dicts, default_flow_style=False)
        log.debug(f"Assets text:\n\n{assets_text}")
        return f"The user has uploaded the following files:\n\n{assets_text}"

    def _format_timedelta(self, delta: timedelta) -> str:
        seconds = delta.total_seconds()
        hours, remainder = divmod(seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{int(hours)} hours, {int(minutes)} minutes, and {int(seconds)} seconds"


--- Start of backend/src/agents/tools/staffing/__init__.py ---



--- Start of backend/src/agents/tools/staffing/recommend_tribe_members/models.py ---

from datetime import UTC, datetime
from hashlib import sha256
from typing import Any
from uuid import UUID

import orjson
from pydantic import AwareDatetime, BaseModel, field_validator, model_validator


class MemberProfile(BaseModel):
    # Identity
    uuid: UUID
    tribe_hub_id: str
    name: str | None = None
    email: str | None = None

    # Core member info
    created_at: AwareDatetime
    bio: str | None = None
    linkedin_url: str | None = None
    personal_website_url: str | None = None
    tribe_hub_url: str

    min_rate: int | None = None
    max_rate: int | None = None
    location_timezone_name: str | None = None
    location_timezone_offset: int | None = None

    # Availability
    availability_min_hours: int | None = None
    availability_max_hours: int | None = None

    # Skills and expertise
    interests: str | None = None
    skills: list[str] | None = None  # Names of skills
    industries: list[str] | None = None  # Names of industries
    roles: list[str] | None = None  # Names of roles member has had
    assigned_role: str | None = None  # Current primary role name

    # TODO: memberExperience.description

    # Experience markers
    years_of_experience: int | None = None  # Calculated from member_experience
    project_count: int  # Count of projects
    certification_count: int  # Count of certifications
    publication_count: int  # Count of publications

    # Status and activity
    status: str  # Member status (APPLIED, JOINED, etc)
    last_activity: datetime  # Using updated_at

    # Project history (recent)
    recent_project_titles: list[str] | None = None  # Last 5 projects
    recent_companies: list[str] | None = None  # Last 5 companies worked at

    @model_validator(mode="before")
    @classmethod
    def set_uuid_from_tribe_hub_id(cls, data: Any) -> Any:
        if isinstance(data, dict):
            tribe_hub_id = data["tribe_hub_id"]
            data["uuid"] = UUID(sha256(tribe_hub_id.encode("utf-8")).hexdigest()[0:32])

        return data

    @model_validator(mode="before")
    @classmethod
    def set_tribe_hub_url(cls, data: Any) -> Any:
        if isinstance(data, dict):
            tribe_hub_id = data["tribe_hub_id"]
            data["tribe_hub_url"] = f"https://hub.tribe.ai/members/{tribe_hub_id}"

        return data

    @field_validator("created_at", mode="before")
    @classmethod
    def set_timezone(cls, v: datetime) -> datetime:
        """
        Postgres returns datetime without timezone info, but it's stored in UTC.
        """
        return v.replace(tzinfo=UTC)

    @field_validator(
        "skills",
        "industries",
        "roles",
        "recent_project_titles",
        "recent_companies",
        mode="before",
    )
    @classmethod
    def cast_from_db(cls, v: str | list[str] | None) -> list[str] | None:
        if not v:
            return None

        if isinstance(v, list):
            return [x for x in v if x]

        return orjson.loads(v)


--- Start of backend/src/agents/tools/staffing/recommend_tribe_members/search_index.py ---

from tribe_ai.clients.search import SearchIndexSchema


tribe_member_search_index = SearchIndexSchema(
    index_name="tribe_member",
    indexed_fields=[
        "name",
        "email",
        "bio",
        "external_facing_bio",
        "skills",
        "industries",
        "roles",
        "assigned_role",
        "recent_project_titles",
        "recent_companies",
    ],
    filterable_fields=[
        "tribe_hub_id",
        "status",
        "min_rate",
        "max_rate",
        "availability_min_hours",
        "availability_max_hours",
        "years_of_experience",
        "project_count",
        "certification_count",
        "publication_count",
    ],
    datetime_fields=["created_at", "last_activity"],
    extra_fields=["location_timezone_name", "linkedin_url", "personal_website_url"],
)


--- Start of backend/src/agents/tools/staffing/recommend_tribe_members/__init__.py ---



--- Start of backend/src/agents/tools/staffing/recommend_tribe_members/get_member_profiles.sql ---

WITH recent_projects AS (
    SELECT
        mp."memberId" AS member_id,
        array_agg(title ORDER BY mp."createdAt" DESC) AS recent_titles
    FROM
        "MemberProject" mp
    GROUP BY
        mp."memberId"
),
recent_companies AS (
    SELECT
        me."memberId" AS member_id,
        array_agg(company ORDER BY me."startDate" DESC) AS recent_companies
    FROM
        "MemberExperience" me
    GROUP BY
        me."memberId"
),
experience_years AS (
    SELECT
        "memberId" AS member_id,
        EXTRACT(YEAR FROM MAX("endDate")) - EXTRACT(YEAR FROM MIN("startDate")) AS years
    FROM
        "MemberExperience"
    GROUP BY
        "memberId"
),
member_skills AS (
    SELECT
        m.id AS member_id,
        array_agg(DISTINCT s.name) AS skills
    FROM "Member" m
    LEFT JOIN "_MemberToSkill" ms ON m.id = ms."A"
    LEFT JOIN "Skill" s ON ms."B" = s.id
    GROUP BY m.id
),
member_industries AS (
    SELECT
        m.id AS member_id,
        array_agg(DISTINCT i.name) AS industries
    FROM "Member" m
    LEFT JOIN "_IndustryToMember" mi ON m.id = mi."A"
    LEFT JOIN "Industry" i ON mi."B" = i.id
    GROUP BY m.id
),
member_roles AS (
    SELECT
        m.id AS member_id,
        array_agg(DISTINCT r.name) AS roles
    FROM "Member" m
    LEFT JOIN "MemberRole" mr ON m.id = mr."memberId"
    LEFT JOIN "Role" r ON mr."roleId" = r.id
    GROUP BY m.id
)
SELECT
    m.id,
    u.name,
    u.email,
    m."createdAt" AS created_at,
    m.bio,
    m."linkedinUrl" AS linkedin_url,
    m."websiteUrl" AS website_url,
    m."minRate" AS min_rate,
    m."maxRate" AS max_rate,
    p."timeZoneName" AS location_timezone_name,
    p."timeZoneOffset" AS location_timezone_offset,
    a."minHoursPerWeek" AS availability_min_hours,
    a."maxHoursPerWeek" AS availability_max_hours,
    COALESCE(ms.skills, ARRAY[]::text[]) AS skills,
    COALESCE(mi.industries, ARRAY[]::text[]) AS industries,
    COALESCE(mr.roles, ARRAY[]::text[]) AS roles,
    ar.name AS assigned_role,
    ey.years AS years_of_experience,
    (SELECT COUNT(*) FROM "MemberProject" WHERE "memberId" = m.id) AS project_count,
    (SELECT COUNT(*) FROM "MemberCertification" WHERE "memberId" = m.id) AS certification_count,
    (SELECT COUNT(*) FROM "MemberPublication" WHERE "memberId" = m.id) AS publication_count,
    m.status,
    m."updatedAt" AS last_activity,
    COALESCE(rp.recent_titles, ARRAY[]::text[]) AS recent_project_titles,
    COALESCE(rc.recent_companies, ARRAY[]::text[]) AS recent_companies
FROM
    "Member" m
    LEFT JOIN "User" u ON m."userId" = u.id
    LEFT JOIN "Place" p ON m."locationId" = p.id
    LEFT JOIN "Availability" a ON m."availabilityId" = a.id
    LEFT JOIN "Role" ar ON m."assignedRoleId" = ar.id
    LEFT JOIN experience_years ey ON m.id = ey.member_id
    LEFT JOIN recent_projects rp ON m.id = rp.member_id
    LEFT JOIN recent_companies rc ON m.id = rc.member_id
    LEFT JOIN member_skills ms ON m.id = ms.member_id
    LEFT JOIN member_industries mi ON m.id = mi.member_id
    LEFT JOIN member_roles mr ON m.id = mr.member_id
WHERE
    m.deleted = FALSE
    AND m.status IN ('JOINED', 'WAITLISTED')


--- Start of backend/src/agents/tools/staffing/recommend_tribe_members/tool.py ---

from datetime import UTC, datetime
from pathlib import Path
from typing import Any, cast

from pydantic import Field
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from tribe_ai.clients.search import IndexableSearchDocument, SearchQuery
from tribe_ai.clients.search.fulltext.base import BaseFulltextSearchClient
from tribe_ai.services.agents.tools import (
    BaseTool,
    ToolInputs,
    ToolOptions,
    ToolOutputFormatting,
    ToolOutputs,
    ToolUseInfo,
    ToolUseRequest,
    ToolUseStatus,
    tool_registry,
)
from tribe_ai.utils.timing import log_timing_async

from src.agents.tools.staffing.recommend_tribe_members.models import MemberProfile
from src.agents.tools.staffing.recommend_tribe_members.search_index import tribe_member_search_index
from src.logger import root_logger
from src.search.connect import get_fulltext_search_client
from src.settings import global_settings


log = root_logger.getChild(__name__)


class RecommendTribeMembersInputs(ToolInputs):
    query: str = Field(..., examples=["provider search terms here (e.g. Python, do not use search operators like AND)"])


class RecommendTribeMembersOutputs(ToolOutputs):
    members: list[MemberProfile] = Field(..., examples=[{"id": "123", "bio": "Python"}])

    def display_to_llm(
        self, tool_name: str, inputs: ToolInputs, formatting: ToolOutputFormatting = ToolOutputFormatting.JSON
    ) -> str:
        inputs = cast(RecommendTribeMembersInputs, inputs)
        if self.members:
            return self.model_dump_json(indent=4, exclude_none=True, exclude={"min_rate", "max_rate"})

        return f"No members found by query: {inputs.query}"


@tool_registry.register()
class RecommendTribeMembers(BaseTool[RecommendTribeMembersInputs, RecommendTribeMembersOutputs]):
    """
    Tool that recommends tribe members based on their profile as stored in the tribe hub database.
    """

    display_name = "Tribe Member Database"
    description = "Recommend tribe members based on their profile."
    tool_instructions = "Provide a search query to find Tribe members. You can search on tool/technology/field names, personal names, company names, etc."

    inputs_class = RecommendTribeMembersInputs
    outputs_class = RecommendTribeMembersOutputs

    _search_client: BaseFulltextSearchClient
    _search_index_name: str = "tribe_member"
    _search_index_update_interval_seconds: int = 60 * 60  # 1 hour
    _search_index_last_updated_at: datetime | None = None
    _sql_query_path = Path(__file__).parent / "get_member_profiles.sql"

    def __init__(self, options: ToolOptions | None = None, **kwargs: Any) -> None:
        super().__init__(options=options, **kwargs)
        if not global_settings.tools.tribe_hub_db_uri:
            raise ValueError("No database URI provided for tribe hub.")

        if not self._sql_query_path.exists():
            raise FileNotFoundError(f"SQL query file not found: {self._sql_query_path}")

        self._search_index_schema = tribe_member_search_index
        self._search_client = get_fulltext_search_client()
        self._sql_query = self._sql_query_path.read_text()
        self._async_engine = create_async_engine(global_settings.tools.tribe_hub_db_uri.get_secret_value())
        self._async_session_maker = sessionmaker(self._async_engine, class_=AsyncSession)  # type: ignore[call-overload]

    async def _use(
        self, inputs: RecommendTribeMembersInputs, tool_use_info: ToolUseInfo, tool_use_request: ToolUseRequest
    ) -> tuple[RecommendTribeMembersOutputs | None, ToolUseInfo]:
        try:
            await self._update_search_index_if_needed()
            # TODO: filters, query rewriting, enrichment, etc.
            search_query = SearchQuery(query=inputs.query, index_name=self._search_index_name, limit=10)
            search_results = await self._search_client.query(query=search_query)
            member_profiles = [MemberProfile(**doc.model_dump(exclude={"uuid"})) for doc in search_results.hits]
            return RecommendTribeMembersOutputs(members=member_profiles), tool_use_info

        except Exception as e:
            log.exception("Failed to retrieve member profiles.")
            tool_use_info.status = ToolUseStatus.FAILED
            tool_use_info.output_text = f"Failed to retrieve member profiles: {e}"
            return None, tool_use_info

    async def _update_search_index_if_needed(self) -> None:
        if self._search_index_last_updated_at is None:
            log.debug(f"Initial update of search index: {self._search_index_name}")
            await self._search_client.delete_all_documents_from_index(index_schema=self._search_index_schema)
            await self._update_search_index()
            self._search_index_last_updated_at = datetime.now(tz=UTC)
            return

        time_since_last_update = datetime.now(tz=UTC) - self._search_index_last_updated_at
        if time_since_last_update.total_seconds() < self._search_index_update_interval_seconds:
            log.debug(f"Search index {self._search_index_name} is up to date.")
            return

        await self._update_search_index()

    @log_timing_async
    async def _update_search_index(self) -> None:
        log.debug(f"Updating search index: {self._search_index_name}")
        await self._search_client.create_or_update_index(index_schema=self._search_index_schema)
        member_profiles = await self._fetch_member_profiles()
        indexable_dicts = [
            self._search_index_schema.filter_and_cast_indexable_fields(m.model_dump()) for m in member_profiles
        ]
        indexable_documents = [IndexableSearchDocument(**d) for d in indexable_dicts]

        log.debug(f"Indexing {len(indexable_documents)} documents in search index: {self._search_index_name}")
        await self._search_client.index_documents(documents=indexable_documents, index_schema=self._search_index_schema)
        self._search_index_last_updated_at = datetime.now(tz=UTC)

    async def _fetch_member_profiles(self) -> list[MemberProfile]:
        log.debug("Querying database for member profiles")
        async with self._async_session_maker() as session:  # type: ignore
            result = await session.execute(text(self._sql_query))

        rows = result.fetchall()
        member_profiles = []
        for row in rows:
            # Convert row tuple to dict matching the order of SELECT statement
            member_profile_data = {
                "tribe_hub_id": row[0],
                "name": row[1],
                "email": row[2],
                "created_at": row[3],
                "bio": row[4],
                "linkedin_url": row[5],
                "personal_website_url": row[6],
                "min_rate": row[7],
                "max_rate": row[8],
                "location_timezone_name": row[9],
                "location_timezone_offset": row[10],
                "availability_min_hours": row[11],
                "availability_max_hours": row[12],
                "skills": row[13],
                "industries": row[14],
                "roles": row[15],
                "assigned_role": row[16],
                "years_of_experience": row[17],
                "project_count": row[18],
                "certification_count": row[19],
                "publication_count": row[20],
                "status": row[21],
                "last_activity": row[22],
                "recent_project_titles": row[23],
                "recent_companies": row[24],
            }
            try:
                member_profile = MemberProfile(**member_profile_data)
            except Exception:
                log.exception(f"Error creating MemberProfile for id {member_profile_data['tribe_hub_id']}")
                continue

            member_profiles.append(member_profile)

        for member_profile in member_profiles:
            if not member_profile.bio:
                continue

            member_profile.bio = member_profile.bio.replace("\n", " ")
            while "  " in member_profile.bio:
                member_profile.bio = member_profile.bio.replace("  ", " ")

        return member_profiles


--- Start of backend/src/models/user.py ---

from typing import Literal
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, field_validator
from tribe_ai.clients.search import SearchQueryLog
from tribe_ai.common.db.models.base import BaseDTO

from src.settings import global_settings


class DefaultConversationSettings(BaseModel):
    agent_uuid: UUID = global_settings.agents.default_agent_uuid

    model_config = ConfigDict(extra="ignore")


class UserAppSettings(BaseModel):
    theme: Literal["light", "dark", "system"] = "system"


class UserDTO(BaseDTO):
    username: str
    email: str
    email_verified: bool

    # password auth
    password_hash: str | None = None

    # profile
    given_name: str | None = None
    family_name: str | None = None
    image_url: str | None = None
    description: str | None = None

    # localization
    # TODO: constrain country, locale, timezone, language_code to valid values with enums
    country: str | None = None
    locale: str | None = None
    timezone: str | None = None
    language_code: str | None = None

    # settings
    app_settings: UserAppSettings = UserAppSettings()
    default_conversation_settings: DefaultConversationSettings = DefaultConversationSettings()

    # SSO
    sso_guid: str | None = None

    # authorization
    is_admin: bool = False

    # search
    search_history: list[SearchQueryLog] = Field(default_factory=list)

    @field_validator("app_settings", mode="before")
    @classmethod
    def set_default_app_settings(cls, v: dict | None) -> UserAppSettings | dict:
        if not v:
            return UserAppSettings()

        return v

    @field_validator("default_conversation_settings", mode="before")
    @classmethod
    def set_default_default_conversation_settings(cls, v: dict | None) -> DefaultConversationSettings | dict:
        if not v:
            return DefaultConversationSettings()

        return v

    @field_validator("search_history", mode="before")
    @classmethod
    def set_default_search_history(
        cls, v: list[SearchQueryLog] | list[dict] | None
    ) -> list[SearchQueryLog] | list[dict]:
        if not v:
            return []

        return v

    def get_analytics_properties(self, with_groups: bool = False) -> dict:
        properties = {
            "user_uuid": str(self.uuid),
            "email": self.email,
            "given_name": self.given_name,
            "family_name": self.family_name,
            "is_admin": self.is_admin,
        }

        optional_properties = {"country", "locale", "language_code", "timezone", "sso_guid"}
        for property_name in optional_properties:
            value = getattr(self, property_name)
            if value:
                properties[property_name] = value

        if self.app_settings:
            properties["theme"] = self.app_settings.theme

        groups: list[dict] = []
        if with_groups:
            email_domain = self.email.split("@")[1]
            groups.append({"type": "email_domain", "id": email_domain, "name": email_domain})

        analytics_properties: dict = {
            "username": self.username,
            "properties": properties,
            "immutable_properties": {"username": self.username},
        }
        if groups:
            analytics_properties["groups"] = groups

        return analytics_properties


--- Start of backend/src/models/asset.py ---

from enum import StrEnum
from uuid import UUID

from tribe_ai.common.db.models.base import BaseDTO
from tribe_ai.services.ingestion import IngestionErrorLog, IngestionMetadata, IngestionStatus, IngestionStepLog


class AssetType(StrEnum):
    AUDIO = "audio"
    IMAGE = "image"
    PDF = "pdf"
    OTHER = "other"
    TEXT = "text"
    VIDEO = "video"


class AssetDTO(BaseDTO):
    type: AssetType
    # TODO: generate both name and description using LLM on content
    name: str
    description: str | None = None

    # file metadata
    internal_filename: str
    original_filename: str
    bucket_key: str
    size_bytes: int
    mime_type: str | None = None
    content_hash: str | None = None

    # ingestion
    ingestion_status: IngestionStatus | None = None
    ingestion_error_log: IngestionErrorLog | None = None
    ingestion_metadata: IngestionMetadata | None = None
    ingestion_step_logs: list[IngestionStepLog] | None = None

    # foreign keys
    agent_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID


--- Start of backend/src/models/conversation.py ---

from uuid import UUID

from tribe_ai.common.db.models.base import BaseDTO

from src.models.agent import AgentDTO
from src.models.asset import AssetDTO
from src.models.message import MessageDTO, MessageType
from src.models.user import UserDTO


class ConversationDTO(BaseDTO):
    name: str = "New Conversation"

    # foreign keys
    user_uuid: UUID

    # relationships
    agents: list[AgentDTO] = []
    assets: list[AssetDTO] = []
    messages: list[MessageDTO] = []
    user: UserDTO

    @property
    def messages_in_order(self) -> list[MessageDTO]:
        return sorted(self.messages, key=lambda m: m.created_at)  # type: ignore

    def render_messages(self) -> str:
        return "\n".join([f"{m.role.value}: {m.content}" for m in self.messages_in_order])

    def has_audio(self) -> bool:
        return any(message.type in [MessageType.AUDIO, MessageType.MULTIMODAL] for message in self.messages)

    def has_images(self) -> bool:
        return any(message.type in [MessageType.IMAGE, MessageType.MULTIMODAL] for message in self.messages)


--- Start of backend/src/models/feedback.py ---

from enum import StrEnum
from typing import Self
from uuid import UUID

from pydantic import model_validator
from tribe_ai.common.db.models.base import BaseDTO


class FeedbackTarget(StrEnum):
    AGENT = "agent"
    APPLICATION = "application"
    CONVERSATION = "conversation"
    MESSAGE = "message"
    OUTPUT = "output"


class FeedbackType(StrEnum):
    BUG = "bug"
    FEATURE_REQUEST = "feature_request"
    IMPROVEMENT = "improvement"
    OTHER = "other"
    PERFORMANCE = "performance"
    QUALITY = "quality"
    QUESTION = "question"
    USABILITY = "usability"


class FeedbackRating(StrEnum):
    GREAT = "great"
    GOOD = "good"
    BAD = "bad"
    TERRIBLE = "terrible"


# TODO: comparison feedback type


class FeedbackDTO(BaseDTO):
    target: FeedbackTarget = FeedbackTarget.APPLICATION
    type: FeedbackType

    feedback: str
    url: str | None = None
    rating: FeedbackRating | None = None

    # foreign keys
    asset_uuid: UUID | None = None
    agent_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID

    @model_validator(mode="after")
    def validate_target(self) -> Self:
        if self.target == FeedbackTarget.AGENT and not self.agent_uuid:
            raise ValueError("agent_uuid is required for feedback target 'agent'")

        if self.target == FeedbackTarget.CONVERSATION and not self.conversation_uuid:
            raise ValueError("conversation_uuid is required for feedback target 'conversation'")

        if self.target == FeedbackTarget.MESSAGE and not self.message_uuid:
            raise ValueError("message_uuid is required for feedback target 'message'")

        if self.target == FeedbackTarget.OUTPUT and not self.asset_uuid:
            raise ValueError("asset_uuid is required for feedback target 'output'")

        return self


--- Start of backend/src/models/__init__.py ---

from src.models.agent import AgentDTO
from src.models.agent_config import AGENT_CONFIG_INITIAL_VERSION, AgentConfigDTO, AgentConfigStatus
from src.models.asset import AssetDTO, AssetType
from src.models.audit_log import AuditActionType, AuditLogDTO
from src.models.conversation import ConversationDTO
from src.models.conversation_starter import ConversationStarterDTO
from src.models.feedback import FeedbackDTO, FeedbackRating, FeedbackTarget, FeedbackType
from src.models.generation_log import GenerationContext, GenerationLogDTO
from src.models.ingestion_chunk import IngestionChunkDTO
from src.models.ingestion_document import IngestionDocumentDTO
from src.models.message import MessageDTO, MessageRole, MessageStatus, MessageType
from src.models.user import DefaultConversationSettings, UserAppSettings, UserDTO


__all__ = [
    "AGENT_CONFIG_INITIAL_VERSION",
    "AgentConfigDTO",
    "AgentConfigStatus",
    "AgentDTO",
    "AssetDTO",
    "AssetType",
    "AuditActionType",
    "AuditLogDTO",
    "ConversationDTO",
    "ConversationStarterDTO",
    "DefaultConversationSettings",
    "FeedbackDTO",
    "FeedbackRating",
    "FeedbackTarget",
    "FeedbackType",
    "GenerationContext",
    "GenerationLogDTO",
    "IngestionChunkDTO",
    "IngestionDocumentDTO",
    "MessageDTO",
    "MessageRole",
    "MessageStatus",
    "MessageType",
    "UserAppSettings",
    "UserDTO",
]


--- Start of backend/src/models/message.py ---

from enum import StrEnum
from uuid import UUID

from pydantic import Field, computed_field
from tribe_ai.clients.llm.models.generation_metadata import GenerationMetadata
from tribe_ai.common.db.models.base import BaseDTO
from tribe_ai.services.agents.tools.models.use import ToolUseResponse

from src.models import AssetDTO


class MessageRole(StrEnum):
    USER = "user"
    ASSISTANT = "assistant"


class MessageStatus(StrEnum):
    IN_PROGRESS = "in_progress"
    INTERRUPTED = "interrupted"
    COMPLETED = "completed"
    FAILED = "failed"
    EDITED = "edited"
    STARTING = "starting"


class MessageType(StrEnum):
    AUDIO = "audio"
    IMAGE = "image"
    MULTIMODAL = "multimodal"
    TEXT = "text"
    VIDEO = "video"


class MessageDTO(BaseDTO):
    content: str
    type: MessageType
    role: MessageRole
    status: MessageStatus

    reasoning: str | None = None
    tool_use_response: ToolUseResponse | None = None
    generation_metadata: GenerationMetadata | None = None

    @computed_field  # type: ignore[prop-decorator]
    @property
    def llm_model_id(self) -> str | None:
        return self.generation_metadata.llm_model_id if self.generation_metadata else None

    @computed_field  # type: ignore[prop-decorator]
    @property
    def num_tokens(self) -> int | None:
        return self.generation_metadata.num_tokens if self.generation_metadata else None

    @computed_field  # type: ignore[prop-decorator]
    @property
    def cost_usd(self) -> float | None:
        return self.generation_metadata.cost_usd if self.generation_metadata else None

    # tracing
    trace_id: UUID | None = None

    # foreign keys
    agent_uuid: UUID | None
    agent_config_uuid: UUID | None
    user_uuid: UUID | None
    conversation_uuid: UUID

    # relationships
    assets: list[AssetDTO] | None = Field(default_factory=list)  # type: ignore[arg-type]


--- Start of backend/src/models/agent_config.py ---

from enum import StrEnum
from uuid import UUID

from tribe_ai.common.db.models.base import BaseDTO
from tribe_ai.services.agents import AgentConfig


AGENT_CONFIG_INITIAL_VERSION: int = 1


class AgentConfigStatus(StrEnum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    DISABLED = "disabled"


class AgentConfigDTO(BaseDTO, AgentConfig):
    name: str
    status: AgentConfigStatus

    # foreign keys
    agent_uuid: UUID


--- Start of backend/src/models/generation_log.py ---

from uuid import UUID

from pydantic import BaseModel
from tribe_ai.clients.llm.models.generation_metadata import FinishReason
from tribe_ai.common.db.models.base import BaseDTO


class GenerationContext(BaseModel):
    asset_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID


class GenerationLogDTO(BaseDTO):
    provider: str
    llm_model_id: str
    input_token_cost_usd: float
    output_token_cost_usd: float

    template_name: str
    inputs: dict[str, str]
    input_text: str | None = None
    input_messages: list[dict] | None = None
    output_text: str
    finish_reason: FinishReason

    input_tokens: int
    output_tokens: int
    cost_usd: float

    cache_key: str

    # foreign keys
    asset_uuid: UUID | None = None
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID


--- Start of backend/src/models/ingestion_document.py ---

from typing import Any, Self
from uuid import UUID

from pydantic import model_validator
from tribe_ai.services.ingestion import IngestionDocument


class IngestionDocumentDTO(IngestionDocument):
    """
    Data Transfer Object for IngestionDocument

    Attributes:
        ingestion_document_uuid: set to the uuid of the document, set automatically and explicitly so its meaning is extra clear when set in the search index
        asset_uuid: the uuid of the asset the document is associated with. required in this application as all documents are created from assets
        conversation_uuid: the uuid of the conversation the document is associated with. optional as we can also add documents to agents as knowledge base entries
        message_uuid: the uuid of the message the document is associated with. optional as we can also add documents to agents as knowledge base entries
        user_uuid: the uuid of the user who created the document. required as all documents are created by users

    Note:
        Other attributes inherit from the IngestionDocument model
    """

    ingestion_document_uuid: UUID

    # foreign keys
    asset_uuid: UUID
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID

    @model_validator(mode="before")
    @classmethod
    def set_ingestion_document_uuid(cls, data: Any) -> Any:
        if isinstance(data, dict):
            data["ingestion_document_uuid"] = data["uuid"]

        return data

    @classmethod
    def from_library_model(cls, ingestion_document: IngestionDocument) -> Self:
        model_dict = ingestion_document.model_dump()

        context = model_dict.pop("context", {})
        asset_uuid = context.pop("asset_uuid")
        user_uuid = context.pop("user_uuid")
        conversation_uuid = context.pop("conversation_uuid", None)
        message_uuid = context.pop("message_uuid", None)

        topics = model_dict.pop("topics", [])
        questions_answered_in_text = model_dict.pop("questions_answered_in_text", [])
        summary = model_dict.pop("summary", None)
        filename = model_dict.pop("filename")
        asset_type = model_dict.pop("type")
        created_at = model_dict.pop("created_at")
        updated_at = model_dict.pop("updated_at", None)
        content_raw = model_dict.pop("content_raw")
        content_processed = model_dict.pop("content_processed")
        source = model_dict.pop("source")
        uuid = model_dict.pop("uuid")

        # type ignore: mypy does not recognize that the model itself is a Self type
        return IngestionDocumentDTO(  # type: ignore[return-value]
            uuid=uuid,
            created_at=created_at,
            updated_at=updated_at,
            filename=filename,
            summary=summary,
            questions_answered_in_text=questions_answered_in_text,
            topics=topics,
            asset_uuid=asset_uuid,
            user_uuid=user_uuid,
            conversation_uuid=conversation_uuid,
            message_uuid=message_uuid,
            type=asset_type,
            content_raw=content_raw,
            content_processed=content_processed,
            source=source,
            ingestion_document_uuid=uuid,
        )

    def to_library_model(self) -> IngestionDocument:
        return IngestionDocument(
            **self.model_dump(
                exclude={
                    "asset_uuid",
                    "conversation_uuid",
                    "context",
                    "message_uuid",
                    "user_uuid",
                    "ingestion_document_uuid",
                }
            ),
            context={
                "asset_uuid": str(self.asset_uuid),
                "conversation_uuid": str(self.conversation_uuid),
                "message_uuid": str(self.message_uuid),
                "user_uuid": str(self.user_uuid),
            },
        )


--- Start of backend/src/models/agent.py ---

from uuid import UUID

from pydantic import Field, computed_field, field_validator
from tribe_ai.common.db.models.base import BaseDTO
from tribe_ai.services.agents import AgentMetadata

from src.models.agent_config import AgentConfigDTO, AgentConfigStatus
from src.models.asset import AssetDTO


class AgentDTO(BaseDTO, AgentMetadata):
    is_public: bool
    llm_model_id: str

    # foreign keys
    owner_uuid: UUID

    # relationships
    agent_configs: list[AgentConfigDTO]
    assets: list[AssetDTO] = Field(default_factory=list)

    # enrichment
    owner_username: str | None = None

    @field_validator("is_public", mode="before")
    @classmethod
    def handle_is_public_null_value(cls, v: bool | None) -> bool:
        return v if v is not None else False

    @computed_field  # type: ignore[prop-decorator]
    @property
    def active_config(self) -> AgentConfigDTO:
        return next(c for c in self.agent_configs if c.status == AgentConfigStatus.ACTIVE)

    def get_config_by_version(self, version: int) -> AgentConfigDTO | None:
        return next((c for c in self.agent_configs if c.version == version), None)

    def set_active_config(self, config_uuid: UUID) -> None:
        active_config = next(c for c in self.agent_configs if c.uuid == config_uuid)
        active_config.status = AgentConfigStatus.ACTIVE
        for c in self.agent_configs:
            if c.uuid != config_uuid and c.status == AgentConfigStatus.ACTIVE:
                c.status = AgentConfigStatus.INACTIVE

    def add_new_config(self, config: AgentConfigDTO) -> None:
        config.status = AgentConfigStatus.INACTIVE
        config.version = max([c.version for c in self.agent_configs]) + 1
        self.agent_configs.append(config)

    def get_metadata(self) -> AgentMetadata:
        return AgentMetadata(**self.model_dump())


--- Start of backend/src/models/conversation_starter.py ---

from tribe_ai.common.db.models.base import BaseDTO


class ConversationStarterDTO(BaseDTO):
    title: str
    description: str
    message_prefill: str


--- Start of backend/src/models/ingestion_chunk.py ---

from typing import Self
from uuid import UUID

from tribe_ai.services.ingestion import IngestionChunk


class IngestionChunkDTO(IngestionChunk):
    # foreign keys
    asset_uuid: UUID
    conversation_uuid: UUID | None = None
    message_uuid: UUID | None = None
    user_uuid: UUID

    @classmethod
    def from_library_model(cls, ingestion_chunk: IngestionChunk) -> Self:
        model_dict = ingestion_chunk.model_dump()
        context = model_dict.pop("context", {})
        asset_uuid = context.pop("asset_uuid")
        conversation_uuid = context.pop("conversation_uuid", None)
        message_uuid = context.pop("message_uuid", None)
        user_uuid = context.pop("user_uuid")
        embedding = model_dict.pop("embedding", None)

        extra = model_dict.pop("extra", {})
        content_processed = model_dict.pop("content_processed", None)
        summary = model_dict.pop("summary", None)
        questions_answered_in_text = model_dict.pop("questions_answered_in_text", None)
        topics = model_dict.pop("topics", None)
        uuid = model_dict.pop("uuid")
        created_at = model_dict.pop("created_at")
        updated_at = model_dict.pop("updated_at", None)
        chunk_index = model_dict.pop("chunk_index", None)
        document_uuid = model_dict.pop("document_uuid")
        source = model_dict.pop("source")
        doc_type = model_dict.pop("type")
        filename = model_dict.pop("filename")
        content_raw = model_dict.pop("content_raw")
        section = model_dict.pop("section", None)

        # type ignore: mypy does not recognize that the model itself is a Self type
        return IngestionChunkDTO(  # type: ignore[return-value]
            uuid=uuid,
            created_at=created_at,
            updated_at=updated_at,
            asset_uuid=asset_uuid,
            conversation_uuid=conversation_uuid,
            message_uuid=message_uuid,
            user_uuid=user_uuid,
            embedding=embedding,
            content_processed=content_processed,
            summary=summary,
            questions_answered_in_text=questions_answered_in_text,
            topics=topics,
            extra=extra,
            chunk_index=chunk_index,
            document_uuid=document_uuid,
            source=source,
            type=doc_type,
            filename=filename,
            content_raw=content_raw,
            section=section,
        )


--- Start of backend/src/models/audit_log.py ---

from enum import StrEnum
from uuid import UUID

from tribe_ai.common.db.models.base import BaseDTO


class AuditActionType(StrEnum):
    CREATE = "create"
    UPDATE = "update"
    DELETE = "delete"
    LOGIN = "login"
    LOGOUT = "logout"
    FAILED_LOGIN = "failed_login"
    OTHER = "other"


class AuditLogDTO(BaseDTO):
    action_type: AuditActionType
    entity: str | None = None
    changes: dict | None = None
    context: dict | None = None

    # foreign keys
    entity_uuid: UUID | None = None
    user_uuid: UUID


--- Start of backend/src/search/initialize.py ---

from pathlib import Path
from typing import cast

import aiofiles
import yaml
from tribe_ai.clients.search import IndexableSearchDocument

from src.logger import root_logger
from src.search.connect import get_hybrid_search_client
from src.search.indexable_documents import IndexableConversation, IndexableMessage
from src.search.indices import all_search_index_schemas
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def init_search_indices() -> None:
    if not global_settings.app.init_search_indices:
        log.info("Skipping search index initialization")

    log.info("Initializing search indices")
    hybrid_search_client = get_hybrid_search_client()
    for index_schema in all_search_index_schemas:
        log.debug(f"Initializing search index: {index_schema.index_name}")
        await hybrid_search_client.create_or_update_index(index_schema=index_schema)


async def preload_search_data(db_data_path: Path | None) -> None:
    await preload_from_db_data(db_data_path=db_data_path)


async def preload_from_db_data(db_data_path: Path | None) -> None:
    if not db_data_path:
        return

    if not db_data_path.exists():
        raise FileNotFoundError(f"Search preload data file not found: {db_data_path}")

    async with aiofiles.open(db_data_path) as f:
        db_preload_data: dict[str, list[dict]] = yaml.safe_load(await f.read())

    if not db_preload_data:
        return

    for table_name, rows in db_preload_data.items():
        if table_name not in ["conversation", "message"]:
            continue

        await index_documents_for_table(table_name=table_name, rows=rows)

    log.info("Search data preloaded")


async def index_documents_for_table(table_name: str, rows: list[dict]) -> None:
    index_schema = next((idx for idx in all_search_index_schemas if idx.index_name == table_name), None)
    if not index_schema:
        raise ValueError(
            f"Search index schema not found for table: {table_name} (available: {all_search_index_schemas})"
        )

    documents: list[IndexableConversation | IndexableMessage] = []
    if table_name == "conversation":
        documents = [
            IndexableConversation(
                uuid=row["uuid"],
                name=row["name"],
                user_uuid=row["user_uuid"],
            )
            for row in rows
        ]

    elif table_name == "message":
        documents = [
            IndexableMessage(
                uuid=row["uuid"],
                content=row["content"],
                status=row["status"],
                type=row["type"],
                role=row["role"],
                conversation_uuid=row["conversation_uuid"],
                llm_model_id=row.get("llm_model_id"),
                agent_uuid=row.get("agent_uuid"),
                user_uuid=row.get("user_uuid"),
            )
            for row in rows
        ]

    log.debug(f"Indexing {len(documents)} documents for table: {table_name}")
    hybrid_search_client = get_hybrid_search_client()
    indexable_documents = cast(list[IndexableSearchDocument], documents)
    await hybrid_search_client.index_documents(documents=indexable_documents, index_schema=index_schema)


--- Start of backend/src/search/connect.py ---

from enum import StrEnum

from tribe_ai.clients.search.fulltext import BaseFulltextSearchClient, fulltext_search_client_registry
from tribe_ai.clients.search.hybrid import BaseHybridSearchClient, hybrid_search_client_registry
from tribe_ai.clients.search.vector import BaseVectorSearchClient, vector_search_client_registry

from src.search.indices import all_search_index_schemas
from src.settings import global_settings


fulltext_search_client: BaseFulltextSearchClient | None = None
vector_search_client: BaseVectorSearchClient | None = None
hybrid_search_client: BaseHybridSearchClient | None = None


class SearchClient(StrEnum):
    HYBRID = "hybrid"
    VECTOR = "vector"
    TEXT = "text"


def get_fulltext_search_client() -> BaseFulltextSearchClient:
    global fulltext_search_client
    if fulltext_search_client is None:
        fulltext_search_client = fulltext_search_client_registry.get_or_create_instance(
            global_settings.provider.search, config=global_settings.search
        )
        for search_index_schema in all_search_index_schemas:
            fulltext_search_client.register_index_schema(search_index_schema)

    return fulltext_search_client


def get_vector_search_client() -> BaseVectorSearchClient:
    global vector_search_client
    if vector_search_client is None:
        vector_search_client = vector_search_client_registry.get_or_create_instance(
            global_settings.provider.search, config=global_settings.search
        )
        for search_index_schema in all_search_index_schemas:
            vector_search_client.register_index_schema(search_index_schema)

    return vector_search_client


def get_hybrid_search_client() -> BaseHybridSearchClient:
    global hybrid_search_client
    if hybrid_search_client is None:
        hybrid_search_client = hybrid_search_client_registry.get_or_create_instance(
            global_settings.provider.search, config=global_settings.search
        )
        for search_index_schema in all_search_index_schemas:
            hybrid_search_client.register_index_schema(search_index_schema)

    return hybrid_search_client


--- Start of backend/src/search/__init__.py ---



--- Start of backend/src/search/indices.py ---

from tribe_ai.clients.search import SearchIndexSchema

from src.agents.tools.projects.find.search_index import tribe_project_search_index
from src.agents.tools.staffing.recommend_tribe_members.search_index import tribe_member_search_index
from src.ingestion.search_indices.ingestion_chunk import ingestion_chunk_search_index
from src.ingestion.search_indices.ingestion_document import ingestion_document_search_index


asset_search_index = SearchIndexSchema(
    index_name="asset",
    indexed_fields=["name", "description"],
    filterable_fields=[
        "uuid",
        "type",
        "original_filename",
        "content",
        "content_hash",
        "ingestion_status",
        "agent_uuid",
        "conversation_uuid",
        "message_uuid",
        "user_uuid",
    ],
    datetime_fields=["created_at", "updated_at"],
    extra_fields=["size_bytes"],
)


conversation_search_index = SearchIndexSchema(
    index_name="conversation",
    indexed_fields=["name"],
    filterable_fields=["user_uuid", "uuid"],
    datetime_fields=["created_at", "updated_at"],
)


message_search_index = SearchIndexSchema(
    index_name="message",
    indexed_fields=["content"],
    filterable_fields=[
        "agent_uuid",
        "agent_config_uuid",
        "conversation_uuid",
        "llm_model_id",
        "role",
        "status",
        "type",
        "user_uuid",
        "uuid",
    ],
    datetime_fields=["created_at", "updated_at"],
)


all_search_index_schemas = [
    asset_search_index,
    conversation_search_index,
    ingestion_chunk_search_index,
    ingestion_document_search_index,
    message_search_index,
    tribe_member_search_index,
    tribe_project_search_index,
]


--- Start of backend/src/search/indexable_documents.py ---

from uuid import UUID

from tribe_ai.clients.search import IndexableSearchDocument
from tribe_ai.services.ingestion import IngestionStatus

from src.models import AssetType, MessageRole, MessageStatus, MessageType


class IndexableAsset(IndexableSearchDocument):
    type: AssetType
    name: str
    description: str | None = None

    original_filename: str
    size_bytes: int
    content: str
    content_hash: str | None = None

    ingestion_status: IngestionStatus | None = None

    agent_uuid: UUID | None
    conversation_uuid: UUID | None
    message_uuid: UUID | None
    user_uuid: UUID


class IndexableConversation(IndexableSearchDocument):
    name: str

    user_uuid: UUID


class IndexableMessage(IndexableSearchDocument):
    content: str
    type: MessageType
    role: MessageRole
    status: MessageStatus

    llm_model_id: str | None

    agent_uuid: UUID | None
    conversation_uuid: UUID | None
    user_uuid: UUID | None


--- Start of backend/src/search/update/asset.py ---

from typing import cast
from uuid import UUID

from tribe_ai.clients.search import IndexableSearchDocument
from tribe_ai.services.ingestion import IngestionStatus

from src.logger import root_logger
from src.models import AssetDTO
from src.search.connect import get_hybrid_search_client
from src.search.indexable_documents import IndexableAsset


log = root_logger.getChild(__name__)

# TODO: have search update functions done in background task


async def update_asset_search_index(
    assets_dto: list[AssetDTO],
    ingestion_statuses: list[IngestionStatus | None] | None = None,
    content_values: list[str | None] | None = None,
) -> None:
    if ingestion_statuses and len(assets_dto) != len(ingestion_statuses):
        raise ValueError("Length of ingestion_statuses must match length of assets_dto")

    if content_values and len(assets_dto) != len(content_values):
        raise ValueError("Length of content must match length of assets_dto")

    hybrid_search_client = get_hybrid_search_client()
    index_schema = hybrid_search_client.get_registered_index_schema(index_name="asset")
    if not index_schema:
        raise ValueError("Search index schema not found for table: asset")

    ingestion_statuses_or_none: list[IngestionStatus | None] = ingestion_statuses or [None] * len(assets_dto)  # type: ignore[list-item]
    content_values_or_none: list[str | None] = content_values or [None] * len(assets_dto)  # type: ignore[list-item]

    search_documents = []
    for asset_dto, ingestion_status, content_value_or_none in zip(
        assets_dto, ingestion_statuses_or_none, content_values_or_none, strict=True
    ):
        log.debug(f"Updating asset search index for asset {asset_dto.uuid}")
        search_document = IndexableAsset(
            uuid=asset_dto.uuid,
            created_at=asset_dto.created_at,
            updated_at=asset_dto.updated_at,
            name=asset_dto.name,
            description=asset_dto.description,
            type=asset_dto.type,
            ingestion_status=ingestion_status,
            original_filename=asset_dto.original_filename,
            content=content_value_or_none or "",
            content_hash=asset_dto.content_hash,
            size_bytes=asset_dto.size_bytes,
            agent_uuid=asset_dto.agent_uuid,
            conversation_uuid=asset_dto.conversation_uuid,
            message_uuid=asset_dto.message_uuid,
            user_uuid=asset_dto.user_uuid,
        )
        search_documents.append(search_document)

    indexable_documents = cast(list[IndexableSearchDocument], search_documents)
    await hybrid_search_client.index_documents(documents=indexable_documents, index_schema=index_schema)


async def delete_from_asset_search_index(asset_uuids: list[UUID]) -> None:
    log.debug(f"Removing assets from search index: {asset_uuids}")
    hybrid_search_client = get_hybrid_search_client()
    index_schema = hybrid_search_client.get_registered_index_schema(index_name="asset")
    if not index_schema:
        raise ValueError("Search index schema not found for table: asset")

    await hybrid_search_client.delete_documents_by_ids(document_ids=asset_uuids, index_schema=index_schema)


--- Start of backend/src/search/update/conversation.py ---

from typing import cast
from uuid import UUID

from tribe_ai.clients.search import IndexableSearchDocument

from src.logger import root_logger
from src.models import ConversationDTO
from src.search.connect import get_hybrid_search_client
from src.search.indexable_documents import IndexableConversation


log = root_logger.getChild(__name__)

# TODO: have search update functions done in background task


async def update_conversation_search_index(conversations_dto: list[ConversationDTO]) -> None:
    hybrid_search_client = get_hybrid_search_client()
    index_schema = hybrid_search_client.get_registered_index_schema(index_name="conversation")
    if not index_schema:
        raise ValueError("Search index schema not found for table: conversation")

    search_documents = []
    for conversation_dto in conversations_dto:
        log.debug(f"Updating conversation search index for conversation {conversation_dto.uuid}")
        search_document = IndexableConversation(
            uuid=conversation_dto.uuid,
            created_at=conversation_dto.created_at,
            updated_at=conversation_dto.updated_at,
            name=conversation_dto.name,
            user_uuid=conversation_dto.user_uuid,
        )
        search_documents.append(search_document)

    indexable_documents = cast(list[IndexableSearchDocument], search_documents)
    await hybrid_search_client.index_documents(documents=indexable_documents, index_schema=index_schema)


async def delete_from_conversation_search_index(conversation_uuids: list[UUID]) -> None:
    log.debug(f"Removing conversations from search index: {conversation_uuids}")
    hybrid_search_client = get_hybrid_search_client()
    index_schema = hybrid_search_client.get_registered_index_schema(index_name="conversation")
    if not index_schema:
        raise ValueError("Search index schema not found for table: conversation")

    await hybrid_search_client.delete_documents_by_ids(document_ids=conversation_uuids, index_schema=index_schema)


--- Start of backend/src/search/update/__init__.py ---



--- Start of backend/src/search/update/message.py ---

from typing import cast
from uuid import UUID

from tribe_ai.clients.search import IndexableSearchDocument

from src.logger import root_logger
from src.models import MessageDTO
from src.search.connect import get_hybrid_search_client
from src.search.indexable_documents import IndexableMessage


log = root_logger.getChild(__name__)


async def update_message_search_index(messages_dto: list[MessageDTO], user_uuid: UUID | None = None) -> None:
    hybrid_search_client = get_hybrid_search_client()
    index_schema = hybrid_search_client.get_registered_index_schema(index_name="message")
    if not index_schema:
        raise ValueError("Search index schema not found for table: message")

    search_documents = []
    for message_dto in messages_dto:
        log.debug(f"Updating message search index for message {message_dto.uuid}")
        search_document = IndexableMessage(
            uuid=message_dto.uuid,
            created_at=message_dto.created_at,
            updated_at=message_dto.updated_at,
            content=message_dto.content,
            role=message_dto.role,
            type=message_dto.type,
            status=message_dto.status,
            llm_model_id=message_dto.llm_model_id,
            # NOTE: we set user_uuid on agent messages as well for filtering purposes
            # TODO: revisit search schema and uuid fields for filtering once we introduce projects
            user_uuid=message_dto.user_uuid or user_uuid,
            agent_uuid=message_dto.agent_uuid,
            conversation_uuid=message_dto.conversation_uuid,
        )
        search_documents.append(search_document)

    indexable_documents = cast(list[IndexableSearchDocument], search_documents)
    await hybrid_search_client.index_documents(documents=indexable_documents, index_schema=index_schema)


async def delete_from_message_search_index(message_uuids: list[UUID]) -> None:
    log.debug(f"Removing messages from search index: {message_uuids}")
    hybrid_search_client = get_hybrid_search_client()
    index_schema = hybrid_search_client.get_registered_index_schema(index_name="message")
    if not index_schema:
        raise ValueError("Search index schema not found for table: message")

    await hybrid_search_client.delete_documents_by_ids(document_ids=message_uuids, index_schema=index_schema)


--- Start of backend/src/db/initialize.py ---

from pathlib import Path

import aiofiles
import yaml
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.preload import preload_db_data_from_dict

from src.app.handlers.auth import hash_secret
from src.db.connect import AsyncSessionMaker, async_engine
from src.db.models import *  # noqa: F403
from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def init_db_tables() -> None:
    log.info("Initializing database tables")
    async with async_engine.begin() as conn:
        await conn.run_sync(BaseDB.metadata.create_all)


async def preload_db_data(data_path: Path | None) -> None:
    if not data_path:
        log.info("No preload data path specified")
        return

    if not data_path.exists():
        raise FileNotFoundError(f"Preload data file not found: {data_path}")

    async with aiofiles.open(data_path) as f:
        db_preload_data: dict[str, list[dict]] = yaml.safe_load(await f.read())

    if not db_preload_data:
        log.info("No data to preload")
        return

    column_converters = {"app_user": {"password_hash": lambda password: hash_secret(password)}}
    async with AsyncSessionMaker() as db:  # type: ignore
        await preload_db_data_from_dict(
            db=db,
            db_preload_data=db_preload_data,
            column_converters=column_converters,
            override_existing=global_settings.app.db_preload_override_existing,
        )


--- Start of backend/src/db/connect.py ---

from collections.abc import AsyncGenerator
from sqlite3 import Connection as SQLite3Connection
from typing import Annotated, Any

from fastapi import Depends
from sqlalchemy import event
from sqlalchemy.dialects.sqlite.aiosqlite import AsyncAdapt_aiosqlite_connection
from sqlalchemy.engine import Engine
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from tribe_ai.common.db.utils.sqlite import setup_sqlite_handlers

from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)


log.info(f"Connecting to database at {global_settings.db.uri}")
async_engine = create_async_engine(
    url=global_settings.db.uri, echo=global_settings.db.echo, connect_args=global_settings.db.connect_args
)
AsyncSessionMaker = sessionmaker(bind=async_engine, class_=AsyncSession, expire_on_commit=False)  # type: ignore[call-overload]


async def get_session() -> AsyncGenerator:
    log.debug("Getting database session")
    async with AsyncSessionMaker() as db:  # type: ignore
        yield db


DBSession = Annotated[AsyncSession, Depends(get_session)]


@event.listens_for(Engine, "connect")
def set_sqlite_pragma(dbapi_connection: Any, connection_record: Any) -> None:
    if isinstance(dbapi_connection, SQLite3Connection | AsyncAdapt_aiosqlite_connection):
        setup_sqlite_handlers(engine=async_engine)


--- Start of backend/src/db/__init__.py ---



--- Start of backend/src/db/migrations/script.py.mako ---

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa

${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}


--- Start of backend/src/db/migrations/env.py ---

import sys
from pathlib import Path

from alembic import context
from alembic.migration import MigrationContext
from alembic.operations import MigrationScript
from sqlalchemy import engine_from_config, pool
from sqlalchemy.exc import SQLAlchemyError


# NOTE: without this the path of this script is used as the root path
#       we insert the root path of the project as the scripts/generate_migration.sh script is run from the root path
sys.path.insert(0, str(Path(__file__).parents[3]))

from tribe_ai.common.db.models.base import BaseDB

from src.db.models import *  # noqa: F403
from src.logger import root_logger
from src.settings import global_settings


log = root_logger.getChild(__name__)


def get_db_uri() -> str:
    """
    Migrations are run in sync mode, so we need to convert the async drivers to sync drivers
    and convert the sslmode query parameter as this is used differently in asyncpg vs psycopg2,
    and remove the aiosqlite driver for SQLite as it is not supported by alembic.
    """
    db_uri = global_settings.db.uri
    async_db_uri = db_uri if isinstance(db_uri, str) else db_uri.render_as_string(hide_password=False)
    return async_db_uri.replace("asyncpg", "psycopg2").replace("+aiosqlite", "").replace("?ssl", "?sslmode")


def run_migrations_offline() -> None:
    """
    Offline mode is for generating SQL scripts using the --sql option.
    This can be used if another system is responsible for executing the migrations against the database.
    """
    context.configure(url=get_db_uri(), target_metadata=BaseDB.metadata, literal_binds=True, compare_type=True)
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """
    Online mode runs the migrations against the database.
    We use a local SQLite database for generating the migrations.
    """
    configuration = context.config.get_section(context.config.config_ini_section)
    if not configuration:
        raise ValueError("No configuration found in alembic.ini")

    configuration["sqlalchemy.url"] = get_db_uri()

    def process_revision_directives(
        _context: MigrationContext, _revision: str, directives: list[MigrationScript]
    ) -> None:
        if context.config.cmd_opts and context.config.cmd_opts.autogenerate:
            script = directives[0]
            if script.upgrade_ops is None or script.upgrade_ops.is_empty():
                directives[:] = []

    connectable = engine_from_config(configuration, prefix="sqlalchemy.", poolclass=pool.NullPool)
    try:
        with connectable.connect() as connection:
            context.configure(
                connection=connection,
                target_metadata=BaseDB.metadata,
                compare_type=True,
                process_revision_directives=process_revision_directives,  # type: ignore[arg-type]
            )
            with context.begin_transaction():
                context.run_migrations()
    except SQLAlchemyError:
        log.exception(
            "Error running migrations. Please check that the database is running "
            "and that you do not have another postgres process running."
        )
        sys.exit(1)


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


--- Start of backend/src/db/migrations/__init__.py ---



--- Start of backend/src/db/migrations/versions/version_0_8_0_1578f01e480a.py ---

"""version_0.8.0

Revision ID: 1578f01e480a
Revises: 6c46933ea606
Create Date: 2025-02-06 19:59:36.582197

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "1578f01e480a"
down_revision = "6c46933ea606"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("message", sa.Column("trace_id", tribe_ai.common.db.utils.guid.GUID(), nullable=True))
    op.create_index(op.f("ix_message_trace_id"), "message", ["trace_id"], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f("ix_message_trace_id"), table_name="message")
    op.drop_column("message", "trace_id")
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_3_5_f02a984e886d.py ---

"""version_0.3.4

Revision ID: f02a984e886d
Revises: a85454b5ab59
Create Date: 2024-12-28 23:07:17.603676

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa
from sqlalchemy.sql import table, column

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "f02a984e886d"
down_revision = "a85454b5ab59"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("agent_config", sa.Column("tools", sa.JSON(), server_default="[]", nullable=True))

    conn = op.get_bind()
    agent_config_table = table(  # noqa: ECE001
        "agent_config",
        column("uuid", tribe_ai.common.db.utils.guid.GUID()),
        column("tool_registry_ids", sa.JSON),
        column("tools", sa.JSON),
    )

    results = conn.execute(sa.select(agent_config_table.c.uuid, agent_config_table.c.tool_registry_ids))
    for row in results:
        tool_registry_ids = row.tool_registry_ids or []
        tools = [{"registry_id": str(key)} for key in tool_registry_ids]

        conn.execute(agent_config_table.update().where(agent_config_table.c.uuid == row.uuid).values(tools=tools))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("agent_config", sa.Column("tool_registry_ids", sa.JSON(), server_default="[]", nullable=True))

    conn = op.get_bind()
    agent_config_table = table(  # noqa: ECE001
        "agent_config",
        column("uuid", tribe_ai.common.db.utils.guid.GUID()),
        column("tools", sa.JSON),
        column("tool_registry_ids", sa.JSON),
    )

    results = conn.execute(sa.select(agent_config_table.c.uuid, agent_config_table.c.tools))
    for row in results:
        tools = row.tools or []
        tool_registry_ids = [tool.registry_id for tool in tools]

        conn.execute(
            agent_config_table.update()
            .where(agent_config_table.c.uuid == row.uuid)
            .values(tool_registry_ids=tool_registry_ids)
        )
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_4_0_6c46933ea606.py ---

"""version_0.4.0

Revision ID: 6c46933ea606
Revises: 97a2df72480e
Create Date: 2025-01-13 15:23:47.211516

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "6c46933ea606"
down_revision = "97a2df72480e"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # data migration: get all rows from table 'agent', all values of 'llm_model_id' that start with 'anthropic.' should be prefixed with 'us.'
    # so 'anthropic.123' should become 'us.anthropic.123'
    op.execute(
        "UPDATE agent SET llm_model_id = REPLACE(llm_model_id, 'anthropic.', 'us.anthropic.') WHERE llm_model_id LIKE 'anthropic.%'"
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # reverse data migration: get all rows from table 'agent', all values of 'llm_model_id' that start with 'us.anthropic.' should be prefixed with 'anthropic.'
    # so 'us.anthropic.123' should become 'anthropic.123'
    op.execute(
        "UPDATE agent SET llm_model_id = REPLACE(llm_model_id, 'us.anthropic.', 'anthropic.') WHERE llm_model_id LIKE 'us.anthropic.%'"
    )
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_1_6_1f66465b90cb.py ---

"""version_0.1.6

Revision ID: 1f66465b90cb
Revises:
Create Date: 2024-10-15 01:46:22.416854

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "1f66465b90cb"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "agent",
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("display_name", sa.String(), nullable=False),
        sa.Column("description", sa.String(), nullable=True),
        sa.Column("type", sa.String(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_agent_uuid"), "agent", ["uuid"], unique=False)
    op.create_table(
        "conversation_starter",
        sa.Column("title", sa.String(), nullable=False),
        sa.Column("description", sa.String(), nullable=False),
        sa.Column("message_prefill", sa.String(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_conversation_starter_uuid"), "conversation_starter", ["uuid"], unique=False)
    op.create_table(
        "prompt_template",
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("description", sa.String(), nullable=True),
        sa.Column("ai_task", sa.String(), nullable=True),
        sa.Column("completion_template", sa.JSON(), nullable=True),
        sa.Column("messages_template", sa.JSON(), nullable=True),
        sa.Column("generation_settings", sa.JSON(), nullable=True),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_prompt_template_uuid"), "prompt_template", ["uuid"], unique=False)
    op.create_table(
        "agent_config",
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("description", sa.String(), nullable=True),
        sa.Column("version", sa.Integer(), nullable=False),
        sa.Column("status", sa.String(), nullable=False),
        sa.Column("agent_class", sa.String(), nullable=False),
        sa.Column("conversation_history_config", sa.JSON(), nullable=True),
        sa.Column("prompt_templates", sa.JSON(), nullable=True),
        sa.Column("stock_responses", sa.JSON(), nullable=True),
        sa.Column("tool_registry_ids", sa.JSON(), server_default="[]", nullable=True),
        sa.Column("tool_use_config", sa.JSON(), nullable=True),
        sa.Column("agent_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["agent_uuid"], ["agent.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_agent_config_uuid"), "agent_config", ["uuid"], unique=False)
    op.create_table(
        "app_user",
        sa.Column("username", sa.String(), nullable=False),
        sa.Column("email", sa.String(), nullable=False),
        sa.Column("email_verified", sa.Boolean(), nullable=True),
        sa.Column("password_hash", sa.String(), nullable=True),
        sa.Column("given_name", sa.String(), nullable=True),
        sa.Column("family_name", sa.String(), nullable=True),
        sa.Column("image_url", sa.String(), nullable=True),
        sa.Column("description", sa.String(), nullable=True),
        sa.Column("country", sa.String(), nullable=True),
        sa.Column("locale", sa.String(), nullable=True),
        sa.Column("timezone", sa.String(), nullable=True),
        sa.Column("language_code", sa.String(), nullable=True),
        sa.Column("app_settings", sa.JSON(), server_default="{}", nullable=True),
        sa.Column("default_conversation_settings", sa.JSON(), server_default="{}", nullable=True),
        sa.Column("sso_guid", sa.String(), nullable=True),
        sa.Column("is_admin", sa.Boolean(), nullable=True),
        sa.Column("search_history", sa.JSON(), server_default="[]", nullable=True),
        sa.Column("agent_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["agent_uuid"], ["agent.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
        sa.UniqueConstraint("username"),
    )
    op.create_index(op.f("ix_app_user_uuid"), "app_user", ["uuid"], unique=False)
    op.create_table(
        "conversation",
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("settings", sa.JSON(), nullable=False),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_conversation_user_uuid"), "conversation", ["user_uuid"], unique=False)
    op.create_index(op.f("ix_conversation_uuid"), "conversation", ["uuid"], unique=False)
    op.create_table(
        "agent_to_conversation_association",
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=True
        ),
        sa.Column("agent_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.ForeignKeyConstraint(["agent_uuid"], ["agent.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="CASCADE"),
    )
    op.create_table(
        "message",
        sa.Column("content", sa.String(), nullable=True),
        sa.Column("type", sa.String(), nullable=True),
        sa.Column("role", sa.String(), nullable=True),
        sa.Column("status", sa.String(), nullable=False),
        sa.Column("tool_use_response", sa.JSON(), nullable=True),
        sa.Column("generation_metadata", sa.JSON(), nullable=True),
        sa.Column("llm_model_id", sa.String(), nullable=True),
        sa.Column("num_tokens", sa.Integer(), nullable=True),
        sa.Column("cost_usd", sa.Float(), nullable=True),
        sa.Column("agent_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(
            ["agent_uuid"],
            ["agent.uuid"],
        ),
        sa.ForeignKeyConstraint(
            ["conversation_uuid"],
            ["conversation.uuid"],
        ),
        sa.ForeignKeyConstraint(
            ["user_uuid"],
            ["app_user.uuid"],
        ),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_message_agent_uuid"), "message", ["agent_uuid"], unique=False)
    op.create_index(op.f("ix_message_conversation_uuid"), "message", ["conversation_uuid"], unique=False)
    op.create_index(op.f("ix_message_user_uuid"), "message", ["user_uuid"], unique=False)
    op.create_index(op.f("ix_message_uuid"), "message", ["uuid"], unique=False)
    op.create_table(
        "asset",
        sa.Column("type", sa.String(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("description", sa.String(), nullable=True),
        sa.Column("is_message_asset", sa.Boolean(), nullable=True),
        sa.Column("internal_filename", sa.String(), nullable=False),
        sa.Column("original_filename", sa.String(), nullable=False),
        sa.Column("bucket_key", sa.String(), nullable=False),
        sa.Column("size_bytes", sa.Integer(), nullable=False),
        sa.Column("mime_type", sa.String(), nullable=True),
        sa.Column("content_hash", sa.String(), nullable=True),
        sa.Column("ingestion_status", sa.String(), nullable=True),
        sa.Column("ingestion_error_log", sa.JSON(), server_default="{}", nullable=True),
        sa.Column("ingestion_step_logs", sa.JSON(), server_default="[]", nullable=True),
        sa.Column("ingestion_metadata", sa.JSON(), server_default="{}", nullable=True),
        sa.Column("agent_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("message_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["agent_uuid"], ["agent.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["message_uuid"], ["message.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_asset_agent_uuid"), "asset", ["agent_uuid"], unique=False)
    op.create_index(op.f("ix_asset_conversation_uuid"), "asset", ["conversation_uuid"], unique=False)
    op.create_index(op.f("ix_asset_message_uuid"), "asset", ["message_uuid"], unique=False)
    op.create_index(op.f("ix_asset_user_uuid"), "asset", ["user_uuid"], unique=False)
    op.create_index(op.f("ix_asset_uuid"), "asset", ["uuid"], unique=False)
    op.create_table(
        "audit_log",
        sa.Column("action_type", sa.String(), nullable=False),
        sa.Column("entity", sa.String(), nullable=True),
        sa.Column("entity_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("changes", sa.JSON(), nullable=True),
        sa.Column("context", sa.JSON(), nullable=True),
        sa.Column("asset_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("message_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["asset_uuid"], ["asset.uuid"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["message_uuid"], ["message.uuid"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="SET NULL"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_audit_log_uuid"), "audit_log", ["uuid"], unique=False)
    op.create_table(
        "feedback",
        sa.Column("target", sa.String(), nullable=False),
        sa.Column("type", sa.String(), nullable=False),
        sa.Column("feedback", sa.String(), nullable=False),
        sa.Column("url", sa.String(), nullable=True),
        sa.Column("rating", sa.String(), nullable=True),
        sa.Column("agent_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("asset_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("message_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["agent_uuid"], ["agent.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["asset_uuid"], ["asset.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["message_uuid"], ["message.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_feedback_agent_uuid"), "feedback", ["agent_uuid"], unique=False)
    op.create_index(op.f("ix_feedback_asset_uuid"), "feedback", ["asset_uuid"], unique=False)
    op.create_index(op.f("ix_feedback_conversation_uuid"), "feedback", ["conversation_uuid"], unique=False)
    op.create_index(op.f("ix_feedback_message_uuid"), "feedback", ["message_uuid"], unique=False)
    op.create_index(op.f("ix_feedback_user_uuid"), "feedback", ["user_uuid"], unique=False)
    op.create_index(op.f("ix_feedback_uuid"), "feedback", ["uuid"], unique=False)
    op.create_table(
        "generation_log",
        sa.Column("provider", sa.String(), nullable=False),
        sa.Column("llm_model_id", sa.String(), nullable=False),
        sa.Column("input_token_cost_usd", sa.Float(), nullable=False),
        sa.Column("output_token_cost_usd", sa.Float(), nullable=False),
        sa.Column("template_name", sa.String(), nullable=False),
        sa.Column("inputs", sa.JSON(), nullable=False),
        sa.Column("input_text", sa.String(), nullable=True),
        sa.Column("input_messages", sa.Text(), nullable=True),
        sa.Column("output_text", sa.String(), nullable=False),
        sa.Column("finish_reason", sa.String(), nullable=False),
        sa.Column("input_tokens", sa.Integer(), nullable=False),
        sa.Column("output_tokens", sa.Integer(), nullable=False),
        sa.Column("cost_usd", sa.Float(), nullable=False),
        sa.Column("cache_key", sa.String(), nullable=True),
        sa.Column("asset_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("message_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["asset_uuid"], ["asset.uuid"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["message_uuid"], ["message.uuid"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="SET NULL"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_generation_log_uuid"), "generation_log", ["uuid"], unique=False)
    op.create_table(
        "ingestion_document",
        sa.Column("source", sa.String(), nullable=True),
        sa.Column("type", sa.String(), nullable=True),
        sa.Column("filename", sa.String(), nullable=True),
        sa.Column("content_raw", sa.String(), nullable=True),
        sa.Column("content_redacted", sa.String(), nullable=True),
        sa.Column("content_processed", sa.String(), nullable=True),
        sa.Column("summary", sa.String(), nullable=True),
        sa.Column("questions_answered_in_text", sa.JSON(), nullable=True),
        sa.Column("sections", sa.JSON(), nullable=True),
        sa.Column("topics", sa.JSON(), nullable=True),
        sa.Column("extra", sa.JSON(), nullable=True),
        sa.Column("num_tokens", sa.Integer(), nullable=True),
        sa.Column("cost_usd", sa.Float(), nullable=True),
        sa.Column("asset_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("message_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["asset_uuid"], ["asset.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["message_uuid"], ["message.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_ingestion_document_asset_uuid"), "ingestion_document", ["asset_uuid"], unique=False)
    op.create_index(
        op.f("ix_ingestion_document_conversation_uuid"), "ingestion_document", ["conversation_uuid"], unique=False
    )
    op.create_index(op.f("ix_ingestion_document_message_uuid"), "ingestion_document", ["message_uuid"], unique=False)
    op.create_index(op.f("ix_ingestion_document_user_uuid"), "ingestion_document", ["user_uuid"], unique=False)
    op.create_index(op.f("ix_ingestion_document_uuid"), "ingestion_document", ["uuid"], unique=False)
    op.create_table(
        "ingestion_chunk",
        sa.Column("content_raw", sa.String(), nullable=False),
        sa.Column("content_redacted", sa.String(), nullable=True),
        sa.Column("content_processed", sa.String(), nullable=True),
        sa.Column("chunk_index", sa.Integer(), nullable=True),
        sa.Column("section", sa.String(), nullable=True),
        sa.Column("sub_section", sa.String(), nullable=True),
        sa.Column("extra_section_info", sa.JSON(), nullable=True),
        sa.Column("summary", sa.String(), nullable=True),
        sa.Column("questions_answered_in_text", sa.JSON(), nullable=True),
        sa.Column("topics", sa.JSON(), nullable=True),
        sa.Column("extra", sa.JSON(), nullable=True),
        sa.Column("num_tokens", sa.Integer(), nullable=True),
        sa.Column("cost_usd", sa.Float(), nullable=True),
        sa.Column("asset_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("conversation_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("document_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("message_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True),
        sa.Column("user_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column("uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=False),
        sa.Column(
            "created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False
        ),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["asset_uuid"], ["asset.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["conversation_uuid"], ["conversation.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(
            ["document_uuid"],
            ["ingestion_document.uuid"],
        ),
        sa.ForeignKeyConstraint(["message_uuid"], ["message.uuid"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_uuid"], ["app_user.uuid"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index(op.f("ix_ingestion_chunk_asset_uuid"), "ingestion_chunk", ["asset_uuid"], unique=False)
    op.create_index(
        op.f("ix_ingestion_chunk_conversation_uuid"), "ingestion_chunk", ["conversation_uuid"], unique=False
    )
    op.create_index(op.f("ix_ingestion_chunk_document_uuid"), "ingestion_chunk", ["document_uuid"], unique=False)
    op.create_index(op.f("ix_ingestion_chunk_message_uuid"), "ingestion_chunk", ["message_uuid"], unique=False)
    op.create_index(op.f("ix_ingestion_chunk_user_uuid"), "ingestion_chunk", ["user_uuid"], unique=False)
    op.create_index(op.f("ix_ingestion_chunk_uuid"), "ingestion_chunk", ["uuid"], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f("ix_ingestion_chunk_uuid"), table_name="ingestion_chunk")
    op.drop_index(op.f("ix_ingestion_chunk_user_uuid"), table_name="ingestion_chunk")
    op.drop_index(op.f("ix_ingestion_chunk_message_uuid"), table_name="ingestion_chunk")
    op.drop_index(op.f("ix_ingestion_chunk_document_uuid"), table_name="ingestion_chunk")
    op.drop_index(op.f("ix_ingestion_chunk_conversation_uuid"), table_name="ingestion_chunk")
    op.drop_index(op.f("ix_ingestion_chunk_asset_uuid"), table_name="ingestion_chunk")
    op.drop_table("ingestion_chunk")
    op.drop_index(op.f("ix_ingestion_document_uuid"), table_name="ingestion_document")
    op.drop_index(op.f("ix_ingestion_document_user_uuid"), table_name="ingestion_document")
    op.drop_index(op.f("ix_ingestion_document_message_uuid"), table_name="ingestion_document")
    op.drop_index(op.f("ix_ingestion_document_conversation_uuid"), table_name="ingestion_document")
    op.drop_index(op.f("ix_ingestion_document_asset_uuid"), table_name="ingestion_document")
    op.drop_table("ingestion_document")
    op.drop_index(op.f("ix_generation_log_uuid"), table_name="generation_log")
    op.drop_table("generation_log")
    op.drop_index(op.f("ix_feedback_uuid"), table_name="feedback")
    op.drop_index(op.f("ix_feedback_user_uuid"), table_name="feedback")
    op.drop_index(op.f("ix_feedback_message_uuid"), table_name="feedback")
    op.drop_index(op.f("ix_feedback_conversation_uuid"), table_name="feedback")
    op.drop_index(op.f("ix_feedback_asset_uuid"), table_name="feedback")
    op.drop_index(op.f("ix_feedback_agent_uuid"), table_name="feedback")
    op.drop_table("feedback")
    op.drop_index(op.f("ix_audit_log_uuid"), table_name="audit_log")
    op.drop_table("audit_log")
    op.drop_index(op.f("ix_asset_uuid"), table_name="asset")
    op.drop_index(op.f("ix_asset_user_uuid"), table_name="asset")
    op.drop_index(op.f("ix_asset_message_uuid"), table_name="asset")
    op.drop_index(op.f("ix_asset_conversation_uuid"), table_name="asset")
    op.drop_index(op.f("ix_asset_agent_uuid"), table_name="asset")
    op.drop_table("asset")
    op.drop_index(op.f("ix_message_uuid"), table_name="message")
    op.drop_index(op.f("ix_message_user_uuid"), table_name="message")
    op.drop_index(op.f("ix_message_conversation_uuid"), table_name="message")
    op.drop_index(op.f("ix_message_agent_uuid"), table_name="message")
    op.drop_table("message")
    op.drop_table("agent_to_conversation_association")
    op.drop_index(op.f("ix_conversation_uuid"), table_name="conversation")
    op.drop_index(op.f("ix_conversation_user_uuid"), table_name="conversation")
    op.drop_table("conversation")
    op.drop_index(op.f("ix_app_user_uuid"), table_name="app_user")
    op.drop_table("app_user")
    op.drop_index(op.f("ix_agent_config_uuid"), table_name="agent_config")
    op.drop_table("agent_config")
    op.drop_index(op.f("ix_prompt_template_uuid"), table_name="prompt_template")
    op.drop_table("prompt_template")
    op.drop_index(op.f("ix_conversation_starter_uuid"), table_name="conversation_starter")
    op.drop_table("conversation_starter")
    op.drop_index(op.f("ix_agent_uuid"), table_name="agent")
    op.drop_table("agent")
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_3_4_a85454b5ab59.py ---

"""version_0.3.4

Revision ID: a85454b5ab59
Revises: 4f5f4eb77304
Create Date: 2025-01-02 22:28:22.944684

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "a85454b5ab59"
down_revision = "4f5f4eb77304"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("asset") as batch_op:
        batch_op.alter_column("conversation_uuid", existing_type=sa.CHAR(length=32), nullable=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("asset") as batch_op:
        batch_op.alter_column("conversation_uuid", existing_type=sa.CHAR(length=32), nullable=False)
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_3_6_97a2df72480e.py ---

"""version_0.3.6

Revision ID: 97a2df72480e
Revises: f02a984e886d
Create Date: 2025-01-07 16:55:09.478257

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa

from sqlalchemy.dialects import sqlite

# revision identifiers, used by Alembic.
revision = "97a2df72480e"
down_revision = "f02a984e886d"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column("agent_config", "tool_registry_ids")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column(
        "agent_config", sa.Column("tool_registry_ids", sqlite.JSON(), server_default=sa.text("'[]'"), nullable=True)
    )
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_2_2_b7cd3fe6edf0.py ---

"""version_0.2.2

Revision ID: b7cd3fe6edf0
Revises: 351cf98653fb
Create Date: 2024-12-02 01:21:33.589291

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "b7cd3fe6edf0"
down_revision = "351cf98653fb"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("prompt_template", sa.Column("llm_function", sa.String(), nullable=True))
    op.execute("UPDATE prompt_template SET llm_function = ai_task")
    op.drop_column("prompt_template", "ai_task")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("prompt_template", sa.Column("ai_task", sa.VARCHAR(), nullable=True))
    op.execute("UPDATE prompt_template SET ai_task = llm_function")
    op.drop_column("prompt_template", "llm_function")
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_1_7_12ab8425c50e.py ---

"""version_0.1.7

Revision ID: 12ab8425c50e
Revises: 1f66465b90cb
Create Date: 2024-11-04 10:39:32.886952

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "12ab8425c50e"
down_revision = "1f66465b90cb"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("agent", sa.Column("llm_model_id", sa.String(), nullable=True))
    op.add_column("agent", sa.Column("is_public", sa.Boolean(), nullable=True))
    op.add_column("agent", sa.Column("owner_uuid", tribe_ai.common.db.utils.guid.GUID()))

    # we set default agent's owner_uuid to dev@tribe.ai user's UUID
    op.execute("UPDATE agent SET owner_uuid = '7583534c-e729-4636-8118-21db343445aa'")

    # For SQLite compatibility, use batch_alter_table instead of alter_column
    # Handle all column and constraint changes within batch_alter_table
    with op.batch_alter_table("agent") as batch_op:
        batch_op.alter_column("owner_uuid", existing_type=tribe_ai.common.db.utils.guid.GUID(), nullable=False)
        batch_op.create_index("ix_agent_owner_uuid", ["owner_uuid"], unique=False)
        batch_op.create_foreign_key(
            "fk_agent_owner_uuid_app_user", "app_user", ["owner_uuid"], ["uuid"], ondelete="CASCADE"
        )
        batch_op.drop_column("display_name")

    op.add_column("agent_config", sa.Column("notes", sa.String(), nullable=True))
    op.drop_column("agent_config", "description")

    with op.batch_alter_table("app_user") as batch_op:
        batch_op.drop_column("agent_uuid")

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("app_user", sa.Column("agent_uuid", sa.CHAR(length=32), nullable=True))
    op.create_foreign_key(None, "app_user", "agent", ["agent_uuid"], ["uuid"], ondelete="CASCADE")
    op.add_column("agent_config", sa.Column("description", sa.VARCHAR(), nullable=True))
    op.drop_column("agent_config", "notes")
    op.add_column("agent", sa.Column("display_name", sa.VARCHAR(), nullable=False))
    op.drop_index(op.f("ix_agent_owner_uuid"), table_name="agent")
    op.drop_column("agent", "owner_uuid")
    op.drop_column("agent", "is_public")
    op.drop_column("agent", "llm_model_id")
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/__init__.py ---



--- Start of backend/src/db/migrations/versions/version_0_1_8_f34400c3f9bb.py ---

"""version_0.1.8

Revision ID: f34400c3f9bb
Revises: 12ab8425c50e
Create Date: 2024-11-07 12:49:41.860583

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa

from sqlalchemy.dialects import sqlite

# revision identifiers, used by Alembic.
revision = "f34400c3f9bb"
down_revision = "12ab8425c50e"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column("conversation", "settings")
    op.add_column("message", sa.Column("agent_config_uuid", tribe_ai.common.db.utils.guid.GUID(), nullable=True))
    op.create_index(op.f("ix_message_agent_config_uuid"), "message", ["agent_config_uuid"], unique=False)

    # using batch op for SQLite compatibility
    with op.batch_alter_table("message") as batch_op:
        batch_op.create_foreign_key(
            "fk_message_agent_config_uuid_agent_config", "agent_config", ["agent_config_uuid"], ["uuid"]
        )

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint("fk_message_agent_config_uuid_agent_config", "message", type_="foreignkey")
    op.drop_index(op.f("ix_message_agent_config_uuid"), table_name="message")
    op.drop_column("message", "agent_config_uuid")
    op.add_column("conversation", sa.Column("settings", sqlite.JSON(), nullable=False))
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_2_0_105890535923.py ---

"""version_0.2.0

Revision ID: 105890535923
Revises: 489e61d9db10
Create Date: 2024-11-15 11:50:12.224312

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "105890535923"
down_revision = "489e61d9db10"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("agent_config", sa.Column("reasoning_detection", sa.JSON(), nullable=True))
    op.add_column("message", sa.Column("reasoning", sa.Text(), nullable=True))

    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("message") as batch_op:
        batch_op.alter_column("content", existing_type=sa.VARCHAR(), type_=sa.Text(), existing_nullable=True)


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("message") as batch_op:
        batch_op.alter_column("content", existing_type=sa.Text(), type_=sa.VARCHAR(), existing_nullable=True)

    op.drop_column("message", "reasoning")
    op.drop_column("agent_config", "reasoning_detection")
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_2_1_351cf98653fb.py ---

"""version_0.2.1

Revision ID: 351cf98653fb
Revises: 105890535923
Create Date: 2024-11-22 03:14:40.521444

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "351cf98653fb"
down_revision = "105890535923"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("conversation") as batch_op:
        batch_op.alter_column("user_uuid", existing_type=sa.CHAR(length=32), nullable=False)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("conversation") as batch_op:
        batch_op.alter_column("user_uuid", existing_type=sa.CHAR(length=32), nullable=True)
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_1_9_489e61d9db10.py ---

"""version_0.1.9

Revision ID: 489e61d9db10
Revises: f34400c3f9bb
Create Date: 2024-11-13 12:40:57.237018

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa

from sqlalchemy.dialects import sqlite

# revision identifiers, used by Alembic.
revision = "489e61d9db10"
down_revision = "f34400c3f9bb"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("agent_config", sa.Column("prompt_template", sa.JSON(), nullable=True))
    op.add_column("agent_config", sa.Column("tool_use_section_templates", sa.JSON(), nullable=True))
    op.drop_column("agent_config", "prompt_templates")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("agent_config", sa.Column("prompt_templates", sqlite.JSON(), nullable=True))
    op.drop_column("agent_config", "tool_use_section_templates")
    op.drop_column("agent_config", "prompt_template")
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_18_0_07bfdbda3a90.py ---

"""version_0.18.0

Revision ID: 07bfdbda3a90
Revises: 1578f01e480a
Create Date: 2025-02-27 15:17:40.108735

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa

from sqlalchemy.dialects import sqlite

# revision identifiers, used by Alembic.
revision = "07bfdbda3a90"
down_revision = "1578f01e480a"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index("ix_prompt_template_uuid", table_name="prompt_template")
    op.drop_table("prompt_template")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "prompt_template",
        sa.Column("name", sa.VARCHAR(), nullable=False),
        sa.Column("description", sa.VARCHAR(), nullable=True),
        sa.Column("completion_template", sqlite.JSON(), nullable=True),
        sa.Column("messages_template", sqlite.JSON(), nullable=True),
        sa.Column("generation_settings", sqlite.JSON(), nullable=True),
        sa.Column("uuid", sa.CHAR(length=32), nullable=False),
        sa.Column("created_at", sa.DATETIME(), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=False),
        sa.Column("updated_at", sa.DATETIME(), nullable=True),
        sa.Column("llm_function", sa.VARCHAR(), nullable=True),
        sa.PrimaryKeyConstraint("uuid"),
    )
    op.create_index("ix_prompt_template_uuid", "prompt_template", ["uuid"], unique=False)
    # ### end Alembic commands ###


--- Start of backend/src/db/migrations/versions/version_0_3_3_4f5f4eb77304.py ---

"""version_0.3.3

Revision ID: 4f5f4eb77304
Revises: b7cd3fe6edf0
Create Date: 2024-12-23 16:18:29.094764

"""

from alembic import op  # noqa
import sqlalchemy as sa  # noqa

import src  # noqa
import tribe_ai.common.db.utils.guid  # noqa


# revision identifiers, used by Alembic.
revision = "4f5f4eb77304"
down_revision = "b7cd3fe6edf0"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("ingestion_chunk", sa.Column("embedding", sa.JSON(), nullable=True))
    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("ingestion_chunk") as batch_op:
        batch_op.alter_column("document_uuid", existing_type=sa.CHAR(length=32), nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # For SQLite, we'll need to create a new table to change column type
    with op.batch_alter_table("ingestion_chunk") as batch_op:
        batch_op.alter_column("document_uuid", existing_type=sa.CHAR(length=32), nullable=True)
    op.drop_column("ingestion_chunk", "embedding")
    # ### end Alembic commands ###


--- Start of backend/src/db/models/user.py ---

from typing import Self

from sqlalchemy import JSON, Boolean, String
from sqlalchemy.orm import mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB

from src.models import UserDTO


class UserDB(BaseDB):
    # NOTE: the "user" table already exists in postgres
    __tablename__ = "app_user"

    # NOTE: we choose to include username as well as email because:
    #       - it is commonly provided by SSO providers
    #       - users can change the email address associated with their account
    username = mapped_column(String, nullable=False, unique=True)
    email = mapped_column(String, nullable=False)
    email_verified = mapped_column(Boolean, default=False)

    # password auth
    password_hash = mapped_column(String)

    # profile
    given_name = mapped_column(String)
    family_name = mapped_column(String)
    image_url = mapped_column(String)
    description = mapped_column(String)

    # localization
    country = mapped_column(String)
    locale = mapped_column(String)
    timezone = mapped_column(String)
    language_code = mapped_column(String)

    # settings
    app_settings = mapped_column(JSON, server_default=r"{}")
    default_conversation_settings = mapped_column(JSON, server_default=r"{}")

    # SSO
    sso_guid = mapped_column(String)

    # authorization
    is_admin = mapped_column(Boolean, default=False)

    # search
    search_history = mapped_column(JSON, server_default="[]")

    # relationships
    agents = relationship("AgentDB", back_populates="owner")
    audit_logs = relationship("AuditLogDB", back_populates="user")
    assets = relationship("AssetDB", back_populates="user", cascade="all, delete")
    conversations = relationship("ConversationDB", back_populates="user", cascade="all, delete")
    feedbacks = relationship("FeedbackDB", back_populates="user", cascade="all, delete")
    ingestion_chunks = relationship("IngestionChunkDB", back_populates="user", cascade="all, delete")
    ingestion_documents = relationship("IngestionDocumentDB", back_populates="user", cascade="all, delete")
    messages = relationship("MessageDB", back_populates="user", cascade="all, delete")
    generation_logs = relationship("GenerationLogDB", back_populates="user", cascade="all, delete")

    def to_dto(self) -> UserDTO:
        return UserDTO(**self.columns_to_dict())

    @classmethod
    def from_dto(cls, user: UserDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return UserDB(**user.model_dump(exclude={"created_at", "updated_at"}, mode="json"))  # type: ignore[return-value]


--- Start of backend/src/db/models/asset.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import JSON, Boolean, ForeignKey, Integer, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import AssetDTO


class AssetDB(BaseDB):
    __tablename__ = "asset"

    type = mapped_column(String, nullable=False)
    name = mapped_column(String, nullable=False)
    description = mapped_column(String)
    is_message_asset = mapped_column(Boolean, default=True)

    # file metadata
    internal_filename = mapped_column(String, nullable=False)
    original_filename = mapped_column(String, nullable=False)
    bucket_key = mapped_column(String, nullable=False)
    size_bytes = mapped_column(Integer, nullable=False)
    mime_type = mapped_column(String)
    content_hash = mapped_column(String)

    # ingestion
    ingestion_status = mapped_column(String)
    ingestion_error_log = mapped_column(JSON, server_default=r"{}")
    ingestion_step_logs = mapped_column(JSON, server_default="[]")
    ingestion_metadata = mapped_column(JSON, server_default=r"{}")

    # foreign keys
    agent_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("agent.uuid", ondelete="CASCADE"), index=True)
    conversation_uuid: Mapped[UUID | None] = mapped_column(
        GUID, ForeignKey("conversation.uuid", ondelete="CASCADE"), index=True
    )
    message_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("message.uuid", ondelete="CASCADE"), index=True)
    user_uuid: Mapped[UUID] = mapped_column(
        GUID, ForeignKey("app_user.uuid", ondelete="CASCADE"), index=True, nullable=False
    )

    # relationships
    agent = relationship("AgentDB", back_populates="assets")
    audit_logs = relationship("AuditLogDB", back_populates="asset")
    conversation = relationship("ConversationDB", back_populates="assets")
    ingestion_chunks = relationship("IngestionChunkDB", back_populates="asset")
    ingestion_documents = relationship("IngestionDocumentDB", back_populates="asset")
    feedbacks = relationship("FeedbackDB", back_populates="asset")
    message = relationship("MessageDB", back_populates="assets")
    generation_logs = relationship("GenerationLogDB", back_populates="asset")
    user = relationship("UserDB", back_populates="assets")

    def to_dto(self) -> AssetDTO:
        return AssetDTO(**self.columns_to_dict())

    @classmethod
    def from_dto(cls, asset: AssetDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return AssetDB(**asset.model_dump())  # type: ignore[return-value]


--- Start of backend/src/db/models/conversation.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import ForeignKey, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.db.models.agent import agent_to_conversation_association
from src.models import ConversationDTO


class ConversationDB(BaseDB):
    __tablename__ = "conversation"

    name = mapped_column(String, nullable=False)

    # foreign keys
    user_uuid: Mapped[UUID] = mapped_column(
        GUID, ForeignKey("app_user.uuid", ondelete="CASCADE"), index=True, nullable=False
    )

    # relationships
    agents = relationship(
        "AgentDB", back_populates="conversations", secondary=agent_to_conversation_association, lazy="joined"
    )
    audit_logs = relationship("AuditLogDB", back_populates="conversation")
    assets = relationship("AssetDB", back_populates="conversation", cascade="all, delete", lazy="joined")
    ingestion_chunks = relationship("IngestionChunkDB", back_populates="conversation", cascade="all, delete")
    ingestion_documents = relationship("IngestionDocumentDB", back_populates="conversation", cascade="all, delete")
    feedbacks = relationship("FeedbackDB", back_populates="conversation", cascade="all, delete")
    messages = relationship("MessageDB", back_populates="conversation", cascade="all, delete", lazy="joined")
    generation_logs = relationship("GenerationLogDB", back_populates="conversation", cascade="all, delete")
    user = relationship("UserDB", back_populates="conversations", lazy="joined")

    def to_dto(self) -> ConversationDTO:
        agents = [agent.to_dto() for agent in self.agents]
        assets = [asset.to_dto() for asset in self.assets]
        user = self.user.to_dto()
        messages = [message.to_dto() for message in self.messages]
        return ConversationDTO(**self.columns_to_dict(), agents=agents, assets=assets, messages=messages, user=user)

    @classmethod
    def from_dto(cls, conversation: ConversationDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return ConversationDB(**conversation.model_dump(exclude={"agents", "assets", "messages", "user"}))  # type: ignore[return-value]


--- Start of backend/src/db/models/feedback.py ---

from typing import Self

from sqlalchemy import ForeignKey, String
from sqlalchemy.orm import mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import FeedbackDTO


class FeedbackDB(BaseDB):
    __tablename__ = "feedback"

    target = mapped_column(String, nullable=False)
    type = mapped_column(String, nullable=False)
    feedback = mapped_column(String, nullable=False)
    url = mapped_column(String)
    rating = mapped_column(String)

    # foreign keys
    agent_uuid = mapped_column(GUID, ForeignKey("agent.uuid", ondelete="CASCADE"), index=True)
    asset_uuid = mapped_column(GUID, ForeignKey("asset.uuid", ondelete="CASCADE"), index=True)
    conversation_uuid = mapped_column(GUID, ForeignKey("conversation.uuid", ondelete="CASCADE"), index=True)
    message_uuid = mapped_column(GUID, ForeignKey("message.uuid", ondelete="CASCADE"), index=True)
    user_uuid = mapped_column(GUID, ForeignKey("app_user.uuid", ondelete="CASCADE"), index=True, nullable=False)

    # relationships
    asset = relationship("AssetDB", back_populates="feedbacks")
    agent = relationship("AgentDB", back_populates="feedbacks")
    conversation = relationship("ConversationDB", back_populates="feedbacks")
    message = relationship("MessageDB", back_populates="feedbacks")
    user = relationship("UserDB", back_populates="feedbacks", lazy="joined")

    # TODO: supplementary_assets = relationship("AssetDB", secondary="feedback_asset", back_populates="feedbacks")

    def to_dto(self) -> FeedbackDTO:
        return FeedbackDTO(**self.columns_to_dict(exclude_keys={"user"}))

    @classmethod
    def from_dto(cls, feedback: FeedbackDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return FeedbackDB(**feedback.model_dump())  # type: ignore[return-value]


--- Start of backend/src/db/models/__init__.py ---

from src.db.models.agent import AgentDB
from src.db.models.agent_config import AgentConfigDB
from src.db.models.asset import AssetDB
from src.db.models.audit_log import AuditLogDB
from src.db.models.conversation import ConversationDB
from src.db.models.conversation_starter import ConversationStarterDB
from src.db.models.feedback import FeedbackDB
from src.db.models.generation_log import GenerationLogDB
from src.db.models.ingestion_chunk import IngestionChunkDB
from src.db.models.ingestion_document import IngestionDocumentDB
from src.db.models.message import MessageDB
from src.db.models.user import UserDB


__all__ = [
    "AgentConfigDB",
    "AgentDB",
    "AssetDB",
    "AuditLogDB",
    "ConversationDB",
    "ConversationStarterDB",
    "FeedbackDB",
    "GenerationLogDB",
    "IngestionChunkDB",
    "IngestionDocumentDB",
    "MessageDB",
    "UserDB",
]


--- Start of backend/src/db/models/message.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import JSON, Float, ForeignKey, Integer, String, Text
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import MessageDTO


class MessageDB(BaseDB):
    __tablename__ = "message"

    content = mapped_column(Text)
    type = mapped_column(String)
    role = mapped_column(String)
    status = mapped_column(String, nullable=False)

    reasoning = mapped_column(Text)
    tool_use_response = mapped_column(JSON)
    generation_metadata = mapped_column(JSON)

    # NOTE: these fields are also stored in generation_metadata, kept here for easier db querying
    llm_model_id = mapped_column(String)
    num_tokens = mapped_column(Integer)
    cost_usd = mapped_column(Float)

    # tracing
    trace_id: Mapped[UUID | None] = mapped_column(GUID, index=True)

    # foreign keys
    agent_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("agent.uuid"), index=True)
    agent_config_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("agent_config.uuid"), index=True)
    user_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("app_user.uuid"), index=True)
    conversation_uuid: Mapped[UUID] = mapped_column(GUID, ForeignKey("conversation.uuid"), index=True, nullable=False)

    # relationships
    agent = relationship("AgentDB", back_populates="messages")
    agent_config = relationship("AgentConfigDB", back_populates="messages")
    audit_logs = relationship("AuditLogDB", back_populates="message")
    assets = relationship("AssetDB", back_populates="message", lazy="joined")
    conversation = relationship("ConversationDB", back_populates="messages")
    feedbacks = relationship("FeedbackDB", back_populates="message")
    ingestion_chunks = relationship("IngestionChunkDB", back_populates="message")
    ingestion_documents = relationship("IngestionDocumentDB", back_populates="message")
    generation_logs = relationship("GenerationLogDB", back_populates="message")
    user = relationship("UserDB", back_populates="messages")

    def to_dto(self) -> MessageDTO:
        assets = [asset.to_dto() for asset in self.assets] if self.assets else None
        return MessageDTO(assets=assets, **self.columns_to_dict())

    @classmethod
    def from_dto(cls, message: MessageDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return MessageDB(**message.model_dump())  # type: ignore[return-value]


--- Start of backend/src/db/models/agent_config.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import JSON, ForeignKey, Integer, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB

from src.models import AgentConfigDTO


class AgentConfigDB(BaseDB):
    __tablename__ = "agent_config"

    name = mapped_column(String, nullable=False)
    notes = mapped_column(String)
    version = mapped_column(Integer, nullable=False, default=1)

    status = mapped_column(String, nullable=False)

    agent_class = mapped_column(String, nullable=False)

    conversation_history_config = mapped_column(JSON)

    prompt_template = mapped_column(JSON)
    reasoning_detection = mapped_column(JSON)
    tool_use_section_templates = mapped_column(JSON)
    stock_responses = mapped_column(JSON)

    tool_use_config = mapped_column(JSON)
    tools = mapped_column(JSON, server_default="[]")

    # foreign keys
    agent_uuid: Mapped[UUID] = mapped_column(ForeignKey("agent.uuid", ondelete="CASCADE"), nullable=False)

    # relationships
    agent = relationship("AgentDB", back_populates="agent_configs", foreign_keys=[agent_uuid])
    messages = relationship("MessageDB", back_populates="agent_config")

    def to_dto(self) -> AgentConfigDTO:
        return AgentConfigDTO(**self.columns_to_dict())

    @classmethod
    def from_dto(cls, agent_config: AgentConfigDTO) -> Self:
        created_at = agent_config.created_at or None
        updated_at = agent_config.updated_at or None
        # type ignore: mypy does not recognize that the model itself is a Self type
        return AgentConfigDB(
            created_at=created_at,
            updated_at=updated_at,
            **agent_config.model_dump(exclude={"created_at", "updated_at"}, mode="json"),
        )  # type: ignore[return-value]


--- Start of backend/src/db/models/generation_log.py ---

from typing import Self
from uuid import UUID

import orjson
from sqlalchemy import JSON, Float, ForeignKey, Integer, String, Text
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import GenerationLogDTO


class GenerationLogDB(BaseDB):
    __tablename__ = "generation_log"

    provider = mapped_column(String, nullable=False)
    llm_model_id = mapped_column(String, nullable=False)
    input_token_cost_usd = mapped_column(Float, nullable=False)
    output_token_cost_usd = mapped_column(Float, nullable=False)

    template_name = mapped_column(String, nullable=False)
    inputs = mapped_column(JSON, nullable=False)
    input_text = mapped_column(String)
    # NOTE: we use a Text column instead of JSON as the input messages can be large and we don't care about querying them
    input_messages = mapped_column(Text)
    output_text = mapped_column(String, nullable=False)
    finish_reason = mapped_column(String, nullable=False)

    input_tokens = mapped_column(Integer, nullable=False)
    output_tokens = mapped_column(Integer, nullable=False)
    cost_usd = mapped_column(Float, nullable=False)

    cache_key = mapped_column(String)

    # foreign keys
    asset_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("asset.uuid", ondelete="SET NULL"))
    conversation_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("conversation.uuid", ondelete="SET NULL"))
    message_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("message.uuid", ondelete="SET NULL"))
    user_uuid: Mapped[UUID] = mapped_column(GUID, ForeignKey("app_user.uuid", ondelete="SET NULL"), nullable=False)

    # relationships
    asset = relationship("AssetDB", back_populates="generation_logs")
    conversation = relationship("ConversationDB", back_populates="generation_logs")
    message = relationship("MessageDB", back_populates="generation_logs")
    user = relationship("UserDB", back_populates="generation_logs")

    def to_dto(self) -> GenerationLogDTO:
        input_messages = orjson.loads(self.input_messages) if self.input_messages else None
        return GenerationLogDTO(input_messages=input_messages, **self.columns_to_dict(exclude_keys={"input_messages"}))

    @classmethod
    def from_dto(cls, generation_log: GenerationLogDTO) -> Self:
        input_messages = (
            orjson.dumps(generation_log.input_messages).decode(encoding="utf-8")
            if generation_log.input_messages
            else None
        )
        # type ignore: mypy does not recognize that the model itself is a Self type
        return GenerationLogDB(input_messages=input_messages, **generation_log.model_dump(exclude={"input_messages"}))  # type: ignore[return-value]


--- Start of backend/src/db/models/ingestion_document.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import JSON, Float, ForeignKey, Integer, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import IngestionDocumentDTO


class IngestionDocumentDB(BaseDB):
    __tablename__ = "ingestion_document"

    # metadata
    source = mapped_column(String)
    type = mapped_column(String)
    filename = mapped_column(String)

    # content
    content_raw = mapped_column(String)
    content_redacted = mapped_column(String)
    content_processed = mapped_column(String)

    # enrichments
    summary = mapped_column(String)
    questions_answered_in_text = mapped_column(JSON)
    sections = mapped_column(JSON)
    topics = mapped_column(JSON)
    extra = mapped_column(JSON)

    # cost/token metadata
    num_tokens = mapped_column(Integer)
    cost_usd = mapped_column(Float)

    # foreign keys
    asset_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("asset.uuid", ondelete="CASCADE"), index=True)
    conversation_uuid: Mapped[UUID | None] = mapped_column(
        GUID, ForeignKey("conversation.uuid", ondelete="CASCADE"), index=True
    )
    message_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("message.uuid", ondelete="CASCADE"), index=True)
    user_uuid: Mapped[UUID] = mapped_column(
        GUID, ForeignKey("app_user.uuid", ondelete="CASCADE"), index=True, nullable=False
    )

    # relationships
    asset = relationship("AssetDB", back_populates="ingestion_documents")
    ingestion_chunks = relationship(
        "IngestionChunkDB", back_populates="ingestion_document", cascade="all, delete-orphan"
    )
    conversation = relationship("ConversationDB", back_populates="ingestion_documents")
    message = relationship("MessageDB", back_populates="ingestion_documents")
    user = relationship("UserDB", back_populates="ingestion_documents")

    def to_dto(self) -> IngestionDocumentDTO:
        return IngestionDocumentDTO(**self.columns_to_dict())

    @classmethod
    def from_dto(cls, ingestion_document: IngestionDocumentDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return IngestionDocumentDB(  # type: ignore[return-value]
            **ingestion_document.model_dump(exclude={"chunks", "context", "ingestion_document_uuid"})
        )


--- Start of backend/src/db/models/agent.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import Boolean, Column, DateTime, ForeignKey, String, Table, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.db.models.agent_config import AgentConfigDB
from src.db.models.asset import AssetDB
from src.models import AgentDTO


agent_to_conversation_association = Table(
    "agent_to_conversation_association",
    BaseDB.metadata,
    Column("created_at", DateTime(timezone=True), server_default=func.now()),
    Column("agent_uuid", GUID, ForeignKey("agent.uuid", ondelete="CASCADE")),
    Column("conversation_uuid", GUID, ForeignKey("conversation.uuid", ondelete="CASCADE")),
)


# TODO: editing only allowed for the owner
class AgentDB(BaseDB):
    __tablename__ = "agent"

    name = mapped_column(String, nullable=False)
    description = mapped_column(String)
    type = mapped_column(String, nullable=False)
    llm_model_id = mapped_column(String)
    is_public = mapped_column(Boolean, default=False)

    # foreign keys
    owner_uuid: Mapped[UUID] = mapped_column(
        GUID, ForeignKey("app_user.uuid", ondelete="CASCADE"), index=True, nullable=False
    )

    # relationships
    agent_configs = relationship("AgentConfigDB", back_populates="agent", lazy="joined", cascade="all, delete-orphan")
    assets = relationship("AssetDB", back_populates="agent", lazy="joined")
    conversations = relationship("ConversationDB", back_populates="agents", secondary=agent_to_conversation_association)
    feedbacks = relationship("FeedbackDB", back_populates="agent")
    messages = relationship("MessageDB", back_populates="agent")
    owner = relationship("UserDB", back_populates="agents", lazy="joined")

    def to_dto(self) -> AgentDTO:
        agent_configs = [config.to_dto() for config in self.agent_configs]
        assets = [asset.to_dto() for asset in self.assets]
        return AgentDTO(
            **self.columns_to_dict(), agent_configs=agent_configs, assets=assets, owner_username=self.owner.username
        )

    @classmethod
    def from_dto(cls, agent_dto: AgentDTO) -> Self:
        agent_config_dbs = [AgentConfigDB.from_dto(config) for config in agent_dto.agent_configs]
        asset_dbs = [AssetDB.from_dto(asset) for asset in agent_dto.assets]
        # type ignore: mypy does not recognize that the model itself is a Self type
        return AgentDB(  # type: ignore[return-value]
            **agent_dto.model_dump(
                exclude={"active_config", "agent_configs", "assets", "created_at", "updated_at", "owner_username"},
                mode="json",
            ),
            agent_configs=agent_config_dbs,
            assets=asset_dbs,
        )


--- Start of backend/src/db/models/conversation_starter.py ---

from typing import Self

from sqlalchemy import String
from sqlalchemy.orm import mapped_column
from tribe_ai.common.db.models.base import BaseDB

from src.models import ConversationStarterDTO


class ConversationStarterDB(BaseDB):
    __tablename__ = "conversation_starter"

    title = mapped_column(String, nullable=False)
    description = mapped_column(String, nullable=False)
    message_prefill = mapped_column(String, nullable=False)

    def to_dto(self) -> ConversationStarterDTO:
        return ConversationStarterDTO(**self.columns_to_dict())

    @classmethod
    def from_dto(cls, conversation_starter: ConversationStarterDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return ConversationStarterDB(**conversation_starter.model_dump())  # type: ignore[return-value]


--- Start of backend/src/db/models/ingestion_chunk.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import JSON, Float, ForeignKey, Integer, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import IngestionChunkDTO


class IngestionChunkDB(BaseDB):
    __tablename__ = "ingestion_chunk"

    # content
    content_raw = mapped_column(String, nullable=False)
    content_redacted = mapped_column(String)
    content_processed = mapped_column(String)

    # chunk context
    chunk_index = mapped_column(Integer)
    section = mapped_column(String)
    sub_section = mapped_column(String)
    extra_section_info = mapped_column(JSON)

    # enrichments
    summary = mapped_column(String)
    questions_answered_in_text = mapped_column(JSON)
    topics = mapped_column(JSON)
    extra = mapped_column(JSON)

    # embeddings
    embedding = mapped_column(JSON)

    # cost/token metadata
    num_tokens = mapped_column(Integer)
    cost_usd = mapped_column(Float)

    # foreign keys
    # TODO: think more deeply about IngestionChunk and IngestionDocument deletion cascades
    asset_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("asset.uuid", ondelete="CASCADE"), index=True)
    conversation_uuid: Mapped[UUID | None] = mapped_column(
        GUID, ForeignKey("conversation.uuid", ondelete="CASCADE"), index=True
    )
    document_uuid: Mapped[UUID] = mapped_column(GUID, ForeignKey("ingestion_document.uuid"), index=True, nullable=False)
    message_uuid: Mapped[UUID | None] = mapped_column(GUID, ForeignKey("message.uuid", ondelete="CASCADE"), index=True)
    user_uuid: Mapped[UUID] = mapped_column(
        GUID, ForeignKey("app_user.uuid", ondelete="CASCADE"), index=True, nullable=False
    )

    # relationships
    asset = relationship("AssetDB", back_populates="ingestion_chunks")
    conversation = relationship("ConversationDB", back_populates="ingestion_chunks")
    ingestion_document = relationship("IngestionDocumentDB", back_populates="ingestion_chunks", lazy="joined")
    message = relationship("MessageDB", back_populates="ingestion_chunks")
    user = relationship("UserDB", back_populates="ingestion_chunks")

    def to_dto(self) -> IngestionChunkDTO:
        ingestion_document = self.ingestion_document.to_dto()
        parent_document_fields = {
            "filename": ingestion_document.filename,
            "source": ingestion_document.source,
            "type": ingestion_document.type,
        }

        return IngestionChunkDTO(**self.columns_to_dict(), **parent_document_fields)

    @classmethod
    def from_dto(cls, ingestion_chunk: IngestionChunkDTO) -> Self:
        # type ignore: mypy does not recognize that the model itself is a Self type
        return IngestionChunkDB(**ingestion_chunk.model_dump(exclude={"context", "filename", "source", "type"}))  # type: ignore[return-value]


--- Start of backend/src/db/models/audit_log.py ---

from typing import Self
from uuid import UUID

from sqlalchemy import JSON, ForeignKey, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from tribe_ai.common.db.models.base import BaseDB
from tribe_ai.common.db.utils.guid import GUID

from src.models import AuditActionType, AuditLogDTO


class AuditLogDB(BaseDB):
    __tablename__ = "audit_log"

    action_type = mapped_column(String, nullable=False)
    entity = mapped_column(String)
    entity_uuid: Mapped[UUID | None] = mapped_column(GUID)
    changes = mapped_column(JSON)
    context = mapped_column(JSON)

    # foreign keys
    asset_uuid = mapped_column(GUID, ForeignKey("asset.uuid", ondelete="SET NULL"))
    conversation_uuid = mapped_column(GUID, ForeignKey("conversation.uuid", ondelete="SET NULL"))
    message_uuid = mapped_column(GUID, ForeignKey("message.uuid", ondelete="SET NULL"))
    user_uuid = mapped_column(GUID, ForeignKey("app_user.uuid", ondelete="SET NULL"), nullable=False)

    # relationships
    asset = relationship("AssetDB", back_populates="audit_logs")
    conversation = relationship("ConversationDB", back_populates="audit_logs")
    message = relationship("MessageDB", back_populates="audit_logs")
    user = relationship("UserDB", back_populates="audit_logs")

    def to_dto(self) -> AuditLogDTO:
        return AuditLogDTO(**self.columns_to_dict())

    @classmethod
    def from_dto(cls, audit_log: AuditLogDTO) -> Self:
        values = {
            "action_type": audit_log.action_type,
            "entity": audit_log.entity,
            "entity_uuid": audit_log.entity_uuid,
            "user_uuid": audit_log.user_uuid,
            "changes": audit_log.changes,
            "context": audit_log.context,
        }
        optional_foreign_key_entities = ["asset", "conversation", "message"]
        if (
            audit_log.action_type != AuditActionType.DELETE
            and audit_log.entity
            and audit_log.entity in optional_foreign_key_entities
        ):
            values[f"{audit_log.entity}_uuid"] = audit_log.entity_uuid

        # type ignore: mypy does not recognize that the model itself is a Self type
        return AuditLogDB(**values)  # type: ignore[return-value]


--- Start of backend/src/db/crud/user.py ---

from uuid import UUID

from sqlalchemy import select
from sqlalchemy import update as update_query

from src.db import crud
from src.db.connect import AsyncSessionMaker, DBSession
from src.db.models import UserDB
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AuditActionType, AuditLogDTO, UserDTO


log = root_logger.getChild(__name__)


async def get_by_username(username: str) -> UserDTO | None:
    # NOTE: does not use DBSession because it is used in the auth handler
    query = select(UserDB).where(UserDB.username == username)
    async with AsyncSessionMaker() as db:  # type: ignore
        result = await db.execute(query)
        user_db = result.scalars().first()
        return user_db.to_dto() if user_db else None


async def get_by_email(db: DBSession, email: str) -> UserDTO | None:
    log.debug(f"Getting user by email {email}")
    query = select(UserDB).where(UserDB.email == email)
    result = await db.execute(query)
    user_db = result.scalars().first()
    return user_db.to_dto() if user_db else None


async def get_by_uuid(db: DBSession, uuid: UUID) -> UserDTO | None:
    user_db = await _get_by_uuid(db, uuid)
    return user_db.to_dto() if user_db else None


async def _get_by_uuid(db: DBSession, uuid: UUID) -> UserDB | None:
    log.debug(f"Getting user by uuid {uuid}")
    query = select(UserDB).filter(UserDB.uuid == uuid)
    result = await db.execute(query)
    return result.scalars().first()


async def create(db: DBSession, user_dto: UserDTO) -> UserDTO:
    log.debug(f"Creating user (email={user_dto.email}, username={user_dto.username})")
    user_db = UserDB.from_dto(user_dto)
    db.add(user_db)
    await db.commit()
    await db.refresh(user_db)

    audit_log_dto = AuditLogDTO(
        user_uuid=user_dto.uuid, action_type=AuditActionType.CREATE, entity="user", entity_uuid=user_dto.uuid
    )
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)

    return user_db.to_dto()


async def update(db: DBSession, user_dto: UserDTO) -> UserDTO:
    log.debug(f"Updating user {user_dto.uuid}")
    user_db = await _get_by_uuid(db=db, uuid=user_dto.uuid)
    if user_db is None:
        raise NotFoundError(entity="user", by=[f"uuid={user_dto.uuid}"])

    for key, value in user_dto.model_dump(exclude={"uuid", "created_at"}, mode="json").items():
        setattr(user_db, key, value)

    await db.commit()
    await db.refresh(user_db)
    return user_db.to_dto()


async def patch(db: DBSession, uuid: UUID, fields: dict) -> UserDTO:
    log.debug(f"Updating user {uuid} with fields {fields}")
    query = select(UserDB).filter(UserDB.uuid == uuid)
    user_db = (await db.execute(query)).unique().scalar_one_or_none()
    if user_db is None:
        raise NotFoundError(entity="user", by=[f"uuid={uuid}"])

    # TODO: validate settings.agent_name is an existing agent
    update = update_query(UserDB).where(UserDB.uuid == uuid).values(fields)
    await db.execute(update)
    await db.commit()
    await db.refresh(user_db)
    return user_db.to_dto()


async def delete(db: DBSession, uuid: UUID) -> None:
    log.debug(f"Deleting user {uuid}")
    query = select(UserDB).filter(UserDB.uuid == uuid)
    user = (await db.execute(query)).unique().scalar_one_or_none()
    if user is None:
        log.warning(f"User {uuid} not found")
        return

    await db.delete(user)
    await db.commit()

    audit_log_dto = AuditLogDTO(
        user_uuid=user.uuid, action_type=AuditActionType.DELETE, entity="user", entity_uuid=user.uuid
    )
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)


async def is_email_available(db: DBSession, email: str) -> bool:
    log.debug(f"Checking if email {email} is available")
    query = select(UserDB).where(UserDB.email == email)
    result = await db.execute(query)
    return result.scalars().first() is None


async def is_username_available(db: DBSession, username: str) -> bool:
    log.debug(f"Checking if username {username} is available")
    query = select(UserDB).where(UserDB.username == username)
    result = await db.execute(query)
    return result.scalars().first() is None


--- Start of backend/src/db/crud/asset.py ---

from uuid import UUID

from fastapi import BackgroundTasks, HTTPException, status
from sqlalchemy import delete, event, select
from sqlalchemy.orm import Session
from tribe_ai.clients.object_storage import object_storage_client_registry
from tribe_ai.services.ingestion import IngestionResponse
from tribe_ai.utils.asyncio import run_sync

from src.db import crud
from src.db.connect import DBSession
from src.db.models import AssetDB
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AssetDTO, AuditActionType, AuditLogDTO
from src.search.update.asset import delete_from_asset_search_index
from src.settings import global_settings


log = root_logger.getChild(__name__)


async def get_all_for_user(db: DBSession, user_uuid: UUID, conversation_uuid: UUID | None = None) -> list[AssetDTO]:
    log.debug(f"Getting all assets for conversation {conversation_uuid}")
    query = select(AssetDB).filter(AssetDB.user_uuid == user_uuid)
    if conversation_uuid:
        query = query.filter(AssetDB.conversation_uuid == conversation_uuid)

    result = await db.execute(query)
    assets_db = result.scalars().all()
    return [asset_db.to_dto() for asset_db in assets_db]


async def get_all(db: DBSession) -> list[AssetDTO]:
    log.debug("Getting all assets")
    query = select(AssetDB)
    result = await db.execute(query)
    assets_db = result.scalars().all()
    return [asset_db.to_dto() for asset_db in assets_db]


async def get_all_db_by_uuids(db: DBSession, asset_uuids: list[UUID]) -> list[AssetDB]:
    log.debug(f"Getting all assets by uuids {asset_uuids}")
    query = select(AssetDB).filter(AssetDB.uuid.in_(asset_uuids))
    results = (await db.execute(query)).scalars().all()
    return list(results)


async def get_by_uuid(db: DBSession, uuid: UUID) -> AssetDTO | None:
    asset_db = await _get_by_uuid(db=db, uuid=uuid)
    return asset_db.to_dto() if asset_db else None


async def _get_by_uuid(db: DBSession, uuid: UUID) -> AssetDB | None:
    log.debug(f"Getting asset by uuid {uuid}")
    query = select(AssetDB).filter(AssetDB.uuid == uuid)
    result = await db.execute(query)
    return result.scalars().first()


async def create(db: DBSession, asset_dto: AssetDTO) -> AssetDTO:
    asset_db = await create_db(db=db, asset_dto=asset_dto)
    return asset_db.to_dto()


async def create_db(db: DBSession, asset_dto: AssetDTO) -> AssetDB:
    log.debug(f"Creating asset {asset_dto.name}")
    asset_db = AssetDB.from_dto(asset_dto)
    db.add(asset_db)
    await db.commit()
    await db.refresh(asset_db)

    audit_log_dto = AuditLogDTO(
        user_uuid=asset_db.user_uuid, action_type=AuditActionType.CREATE, entity="asset", entity_uuid=asset_db.uuid
    )
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)

    return asset_db


async def update_from_ingestion_response(
    db: DBSession, asset_dto: AssetDTO, ingestion_response: IngestionResponse
) -> AssetDTO:
    log.debug(f"Updating asset {asset_dto.name} from ingestion request")
    asset_db = await _get_by_uuid(db=db, uuid=asset_dto.uuid)
    if not asset_db:
        raise NotFoundError(entity="asset", by="uuid")

    error_log = ingestion_response.error_log.model_dump(mode="json") if ingestion_response.error_log else None
    asset_db.ingestion_error_log = error_log
    asset_db.ingestion_metadata = ingestion_response.metadata.model_dump(mode="json")
    asset_db.ingestion_status = ingestion_response.status.value
    asset_db.ingestion_step_logs = [s.model_dump(mode="json") for s in ingestion_response.step_logs]

    await db.commit()
    await db.refresh(asset_db)
    return asset_db.to_dto()


async def delete_by_uuid(db: DBSession, uuid: UUID, user_uuid: UUID) -> None:
    log.debug(f"Deleting asset by uuid {uuid}")
    asset_db = await _get_by_uuid(db=db, uuid=uuid)
    if not asset_db:
        return

    if asset_db.user_uuid != user_uuid:
        raise HTTPException(status.HTTP_403_FORBIDDEN, detail="Asset does not belong to user")

    await db.delete(asset_db)
    await db.commit()

    await delete_from_asset_search_index(asset_uuids=[uuid])

    audit_log_dto = AuditLogDTO(
        user_uuid=asset_db.user_uuid, action_type=AuditActionType.DELETE, entity="asset", entity_uuid=asset_db.uuid
    )
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)


async def delete_orphaned_assets_in_background(background_tasks: BackgroundTasks) -> None:
    log.debug("Deleting orphaned message assets in background if any exist")
    background_tasks.add_task(delete_any_orphaned_message_assets)


async def delete_any_orphaned_message_assets() -> None:
    uuids_query = (
        select(AssetDB.uuid)
        .filter(AssetDB.agent_uuid == None)  # noqa: E711
        .filter(AssetDB.conversation_uuid == None)  # noqa: E711
    )
    async with DBSession() as db:
        asset_uuids = [uuid for (uuid,) in await db.execute(uuids_query)]
        if not asset_uuids:
            return

        log.debug(f"Found {len(asset_uuids)} orphaned assets")
        delete_query = delete(AssetDB).filter(AssetDB.uuid.notin_(asset_uuids))
        await db.execute(delete_query)
        await db.commit()
        await delete_from_asset_search_index(asset_uuids=asset_uuids)


@event.listens_for(AssetDB, "before_delete")
def delete_file_from_object_storage_before_delete(
    mapper: type[AssetDB],
    connection: Session,
    target: AssetDB,
) -> None:
    if not target.bucket_key:
        return

    object_storage_client = object_storage_client_registry.get_or_create_instance(
        global_settings.provider.object_storage, config=global_settings.object_storage
    )
    if run_sync(object_storage_client.key_exists(target.bucket_key)):
        try:
            run_sync(object_storage_client.delete(key=target.bucket_key))
        except Exception as e:
            log.warning(f"Failed to delete asset {target.uuid} from object storage: {e}")


--- Start of backend/src/db/crud/conversation.py ---

from uuid import UUID, uuid4

from fastapi import BackgroundTasks
from sqlalchemy import delete as delete_query
from sqlalchemy import select
from sqlalchemy import update as update_query
from sqlalchemy.orm import selectinload

from src.db import crud
from src.db.connect import AsyncSessionMaker, DBSession
from src.db.models import ConversationDB
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AgentDTO, AuditActionType, AuditLogDTO, ConversationDTO, UserDTO
from src.search.update.conversation import delete_from_conversation_search_index, update_conversation_search_index


log = root_logger.getChild(__name__)


async def get_all_for_user(db: DBSession, user_dto: UserDTO) -> list[ConversationDTO]:
    log.debug(f"Getting all conversations for user {user_dto.username}")
    query = (
        select(ConversationDB)
        .filter(ConversationDB.user_uuid == user_dto.uuid)
        .order_by(ConversationDB.created_at.desc())
        .options(
            selectinload(ConversationDB.agents),
            selectinload(ConversationDB.assets),
            selectinload(ConversationDB.messages),
            selectinload(ConversationDB.user),
        )
    )
    result = await db.execute(query)
    conversations_db = result.unique().scalars().all()
    return [conversation.to_dto() for conversation in conversations_db]


async def get_all(db: DBSession) -> list[ConversationDTO]:
    """
    Does not load relationships
    """
    log.debug("Getting all conversations")
    query = select(ConversationDB).order_by(ConversationDB.created_at.desc())
    result = await db.execute(query)
    conversations_db = result.unique().scalars().all()
    return [conversation.to_dto() for conversation in conversations_db]


async def get_by_uuid(db: DBSession, uuid: UUID) -> ConversationDTO | None:
    conversation_db = await _get_by_uuid(db=db, uuid=uuid)
    return conversation_db.to_dto() if conversation_db else None


async def _get_by_uuid(db: DBSession, uuid: UUID) -> ConversationDB | None:
    log.debug(f"Getting conversation by uuid {uuid}")
    query = (
        select(ConversationDB)
        .filter(ConversationDB.uuid == uuid)
        .options(
            selectinload(ConversationDB.agents),
            selectinload(ConversationDB.assets),
            selectinload(ConversationDB.messages),
            selectinload(ConversationDB.user),
        )
    )
    result = await db.execute(query)
    return result.scalars().first()


async def get_or_create_new(db: DBSession, user_dto: UserDTO, agent_uuid: UUID | None = None) -> ConversationDTO:
    log.debug(f"Checking for existing conversation with no messages for user {user_dto.uuid}")
    query = (
        select(ConversationDB).filter(ConversationDB.user_uuid == user_dto.uuid).filter(~ConversationDB.messages.any())
    )
    conversation_db = (await db.execute(query)).scalars().first()
    if conversation_db:
        log.debug(f"Found existing conversation with no messages for user {user_dto.uuid}")
        return conversation_db.to_dto()

    return await create(db=db, user_dto=user_dto, agent_uuid=agent_uuid)


async def create(
    db: DBSession,
    user_dto: UserDTO,
    conversation_uuid: UUID | None = None,
    agent_uuid: UUID | None = None,
) -> ConversationDTO:
    conversation_db = await _create(
        db=db,
        user_dto=user_dto,
        conversation_uuid=conversation_uuid,
        agent_uuid=agent_uuid,
    )
    return conversation_db.to_dto()


async def _create(
    db: DBSession,
    user_dto: UserDTO,
    conversation_uuid: UUID | None = None,
    agent_uuid: UUID | None = None,
) -> ConversationDB:
    if agent_uuid:
        agent_db = await crud.agent.get_agent_db_by_uuid(db=db, uuid=agent_uuid)
        if not agent_db:
            raise NotFoundError(entity="agent", by="uuid")
    else:
        agent_db = await crud.agent.get_agent_db_by_uuid(db=db, uuid=user_dto.default_conversation_settings.agent_uuid)
        if not agent_db:
            raise NotFoundError(entity="agent", by="uuid")

    log.debug(f"Creating conversation for user {user_dto.uuid} and agent {agent_db.uuid}")
    uuid = conversation_uuid or uuid4()
    conversation_dto = ConversationDTO(uuid=uuid, user_uuid=user_dto.uuid, user=user_dto)
    conversation_db = ConversationDB.from_dto(conversation_dto)
    conversation_db.agents = [agent_db]
    db.add(conversation_db)
    await db.commit()
    await db.refresh(conversation_db, attribute_names=["agents", "assets", "messages", "user"])

    await update_conversation_search_index(conversations_dto=[conversation_db.to_dto()])

    audit_log_dto = AuditLogDTO(
        user_uuid=conversation_db.user_uuid,
        action_type=AuditActionType.DELETE,
        entity="conversation",
        entity_uuid=conversation_db.uuid,
    )
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)

    return conversation_db


async def add_agent(db: DBSession, conversation_dto: ConversationDTO, agent_dto: AgentDTO) -> ConversationDTO:
    log.debug(f"Adding agent {agent_dto.uuid} to conversation {conversation_dto.uuid}")
    conversation_db = await _get_by_uuid(db=db, uuid=conversation_dto.uuid)
    if not conversation_db:
        raise NotFoundError(entity="conversation", by="uuid")

    if agent_dto.uuid not in [a.uuid for a in conversation_db.agents]:
        agent_db = await crud.agent.get_agent_db_by_uuid(db=db, uuid=agent_dto.uuid)
        if not agent_db:
            raise NotFoundError(entity="agent", by="uuid")

        conversation_db.agents.append(agent_db)
        await db.commit()
        await db.refresh(conversation_db, attribute_names=["messages"])

    return conversation_db.to_dto()


async def update(db: DBSession, conversation_dto: ConversationDTO) -> ConversationDTO:
    """
    Update the values of a conversation in the database.
    NOTE: does not update associated tables (e.g. agents, messages, user)
    """
    log.debug(f"Updating conversation by uuid {conversation_dto.uuid}")
    conversation_db = await _get_by_uuid(db=db, uuid=conversation_dto.uuid)
    if not conversation_db:
        raise NotFoundError(entity="conversation", by="uuid")

    for key, value in conversation_dto.model_dump(exclude={"uuid", "created_at"}).items():
        if key in ["assets", "agents", "messages", "user"]:
            continue

        setattr(conversation_db, key, value)

    await db.commit()
    await db.refresh(conversation_db, attribute_names=["agents", "assets", "messages", "user"])
    conversation_dto = conversation_db.to_dto()
    await update_conversation_search_index(conversations_dto=[conversation_dto])
    return conversation_dto


async def update_name_in_background(uuid: UUID, name: str, background_tasks: BackgroundTasks) -> None:
    log.debug(f"Updating conversation name in background by uuid {uuid}")
    background_tasks.add_task(_update_name, uuid=uuid, name=name)


async def _update_name(uuid: UUID, name: str) -> None:
    async with AsyncSessionMaker() as db:  # type: ignore
        query = update_query(ConversationDB).where(ConversationDB.uuid == uuid).values(name=name)
        await db.execute(query)
        await db.commit()
        conversation_dto = await get_by_uuid(db=db, uuid=uuid)
        if conversation_dto:
            await update_conversation_search_index(conversations_dto=[conversation_dto])


async def delete(db: DBSession, uuid: UUID) -> None:
    log.debug(f"Deleting conversation by uuid {uuid}")
    query = select(ConversationDB).filter(ConversationDB.uuid == uuid)
    conversation_db = (await db.execute(query)).scalars().first()
    if conversation_db is None:
        return

    await db.delete(conversation_db)
    await db.commit()

    await delete_from_conversation_search_index(conversation_uuids=[uuid])

    audit_log_dto = AuditLogDTO(
        user_uuid=conversation_db.user_uuid,
        action_type=AuditActionType.DELETE,
        entity="conversation",
        entity_uuid=conversation_db.uuid,
    )
    await crud.audit_log.create(db=db, audit_log=audit_log_dto)


async def check_if_user_owns_conversations(db: DBSession, user_uuid: UUID, conversation_uuids: list[UUID]) -> bool:
    log.debug(f"Checking if user {user_uuid} owns conversations {conversation_uuids}")
    query = (
        select(ConversationDB)
        .filter(ConversationDB.uuid.in_(conversation_uuids))
        .filter(ConversationDB.user_uuid == user_uuid)
    )
    result = await db.execute(query)
    conversations_db = result.scalars().unique().all()
    return len(conversations_db) == len(conversation_uuids)


async def delete_many(db: DBSession, uuids: list[UUID]) -> None:
    log.debug(f"Deleting conversations by uuids {uuids}")
    query = delete_query(ConversationDB).where(ConversationDB.uuid.in_(uuids))
    await db.execute(query)
    await db.commit()


--- Start of backend/src/db/crud/feedback.py ---

from src.db.connect import DBSession
from src.db.models import FeedbackDB
from src.logger import root_logger
from src.models import FeedbackDTO


log = root_logger.getChild(__name__)


async def create(db: DBSession, feedback_dto: FeedbackDTO) -> FeedbackDTO:
    log.debug(f"Creating feedback (target={feedback_dto.target}, type={feedback_dto.type})")
    feedback_db = FeedbackDB.from_dto(feedback_dto)
    db.add(feedback_db)
    await db.commit()
    await db.refresh(feedback_db, attribute_names=["user"])
    return feedback_db.to_dto()


--- Start of backend/src/db/crud/__init__.py ---

from src.db.crud import (
    agent,
    agent_config,
    asset,
    audit_log,
    conversation,
    conversation_starter,
    feedback,
    generation_log,
    ingestion_chunk,
    ingestion_document,
    message,
    user,
)


__all__ = [
    "agent_config",
    "agent",
    "asset",
    "audit_log",
    "conversation_starter",
    "conversation",
    "feedback",
    "generation_log",
    "ingestion_chunk",
    "ingestion_document",
    "message",
    "user",
]


--- Start of backend/src/db/crud/message.py ---

from uuid import UUID

from fastapi import HTTPException, status
from pydantic import AwareDatetime
from sqlalchemy import delete as delete_stmt
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from tribe_ai.common.tracing import get_current_trace_id_as_uuid
from tribe_ai.services.agents import AgentResponse

from src.db.connect import DBSession
from src.db.crud.asset import get_all_db_by_uuids as get_all_assets_db_by_uuids
from src.db.models import AssetDB, ConversationDB, MessageDB
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AssetType, ConversationDTO, MessageDTO, MessageRole, MessageStatus, MessageType
from src.search.update.message import update_message_search_index


log = root_logger.getChild(__name__)


async def get_all(db: DBSession) -> list[MessageDTO]:
    log.debug("Getting all messages")
    query = select(MessageDB)
    result = await db.execute(query)
    messages_db = result.unique().scalars().all()
    return [message.to_dto() for message in messages_db]


async def get_all_by_conversation_and_user_uuid(
    db: DBSession, conversation_uuid: UUID, user_uuid: UUID
) -> list[MessageDTO]:
    log.debug(f"Getting all messages for conversation {conversation_uuid} and user {user_uuid}")
    authz_query = select(ConversationDB).filter(
        ConversationDB.uuid == conversation_uuid, ConversationDB.user_uuid == user_uuid
    )
    authz_result = await db.execute(authz_query)
    conversation_db = authz_result.unique().scalar()
    if not conversation_db:
        raise NotFoundError(entity="conversation", by="uuid")

    query = (
        select(MessageDB).filter(MessageDB.conversation_uuid == conversation_uuid).order_by(MessageDB.created_at.asc())
    )
    result = await db.execute(query)
    messages_db = result.unique().scalars().all()
    return [message_db.to_dto() for message_db in messages_db]


async def get_all_uuids_by_conversation(
    db: DBSession, conversation_uuid: UUID, after_datetime: AwareDatetime | None = None
) -> list[UUID]:
    log.debug(f"Getting all message UUIDs for conversation {conversation_uuid}")
    query = select(MessageDB.uuid).filter(MessageDB.conversation_uuid == conversation_uuid)
    if after_datetime:
        query = query.filter(MessageDB.created_at >= after_datetime)

    result = await db.execute(query)
    return [uuid for (uuid,) in result.all()]


async def get_by_uuid(db: DBSession, uuid: UUID) -> MessageDTO | None:
    message_db = await _get_by_uuid(db=db, uuid=uuid)
    return message_db.to_dto() if message_db else None


async def _get_by_uuid(db: DBSession, uuid: UUID) -> MessageDB | None:
    log.debug(f"Getting message {uuid}")
    query = select(MessageDB).filter(MessageDB.uuid == uuid).options(selectinload(MessageDB.conversation))
    result = await db.execute(query)
    return result.unique().scalar()


async def create_agent_message(
    db: DBSession,
    conversation_uuid: UUID,
    agent_uuid: UUID,
    agent_config_uuid: UUID,
    user_uuid: UUID,
    content: str = "",
    agent_response: AgentResponse | None = None,
    type: MessageType = MessageType.TEXT,
    message_status: MessageStatus = MessageStatus.IN_PROGRESS,
) -> MessageDTO:
    log.debug(f"Creating message for conversation {conversation_uuid}")
    message_status = MessageStatus.COMPLETED if agent_response else message_status
    if agent_response and agent_response.content:
        content = agent_response.content

    reasoning = None
    tool_use_response = None
    generation_metadata = None
    llm_model_id = None
    num_tokens = None
    cost_usd = None
    if agent_response:
        reasoning = agent_response.reasoning
        if agent_response.tool_use_response:
            tool_use_response = agent_response.tool_use_response.model_dump(mode="json")

        if agent_response.generation_metadata:
            generation_metadata = agent_response.generation_metadata.model_dump(mode="json")
            llm_model_id = agent_response.generation_metadata.llm_model_id
            num_tokens = agent_response.generation_metadata.num_tokens
            cost_usd = agent_response.generation_metadata.cost_usd

    message_db = MessageDB(
        content=content,
        role=MessageRole.ASSISTANT.value,
        status=message_status.value,
        type=type.value,
        reasoning=reasoning,
        tool_use_response=tool_use_response,
        generation_metadata=generation_metadata,
        llm_model_id=llm_model_id,
        num_tokens=num_tokens,
        cost_usd=cost_usd,
        trace_id=get_current_trace_id_as_uuid(),
        agent_uuid=agent_uuid,
        agent_config_uuid=agent_config_uuid,
        conversation_uuid=conversation_uuid,
    )
    db.add(message_db)
    await db.commit()
    await db.refresh(message_db)
    message_dto = message_db.to_dto()
    await update_message_search_index(messages_dto=[message_dto], user_uuid=user_uuid)
    return message_dto


async def add_user_message_to_conversation(
    db: DBSession,
    conversation_dto: ConversationDTO,
    user_uuid: UUID,
    content: str | None = None,
    asset_uuids: list[UUID] | None = None,
) -> ConversationDTO:
    log.debug(f"Adding user message to conversation {conversation_dto.uuid}")
    assets_db = []
    if asset_uuids:
        assets_db = await get_validate_and_associate_message_assets_db(
            db=db, asset_uuids=asset_uuids, conversation_uuid=conversation_dto.uuid, user_uuid=user_uuid
        )

    message_type = convert_assets_to_message_type(assets_db)

    message_db = MessageDB(
        content=content or "",
        role=MessageRole.USER.value,
        type=message_type.value,
        status=MessageStatus.COMPLETED.value,
        user_uuid=user_uuid,
        conversation_uuid=conversation_dto.uuid,
        trace_id=get_current_trace_id_as_uuid(),
        assets=assets_db,
    )
    db.add(message_db)
    await db.commit()
    await db.refresh(message_db)
    log.debug(f"Message {message_db.uuid} created")

    message_dto = message_db.to_dto()
    await update_message_search_index(messages_dto=[message_dto])

    conversation_dto.assets.extend([asset.to_dto() for asset in assets_db])
    conversation_dto.messages.append(message_dto)
    return conversation_dto


async def update(db: DBSession, message_dto: MessageDTO, asset_uuids: list[UUID] | None = None) -> MessageDTO:
    log.debug(f"Updating message {message_dto.uuid}")
    message_db = await _get_by_uuid(db=db, uuid=message_dto.uuid)
    if not message_db:
        raise NotFoundError(entity="message", by="uuid")

    for key, value in message_dto.model_dump(
        exclude={"uuid", "created_at", "updated_at", "assets"}, mode="json"
    ).items():
        setattr(message_db, key, value)

    if asset_uuids is not None:
        uploaded_assets_db = await get_all_assets_db_by_uuids(db=db, asset_uuids=asset_uuids)
        if uploaded_assets_db:
            log.debug(f"Adding {len(uploaded_assets_db)} uploaded assets to message {message_db.uuid}")
            message_db.assets += uploaded_assets_db

    await db.commit()
    await db.refresh(message_db)
    message_dto = message_db.to_dto()

    user_uuid = message_db.user_uuid
    if not user_uuid:
        user_uuid = message_db.conversation.user_uuid

    await update_message_search_index(messages_dto=[message_dto], user_uuid=user_uuid)
    return message_dto


async def update_message_and_close_session_after_sse(db: DBSession, message_dto: MessageDTO) -> None:
    """
    Apparently sessions don't always close properly during SSE so we do it manually here
    """
    await update(db=db, message_dto=message_dto)
    log.debug("Closing db session after SSE message update")
    await db.close()


async def delete(db: DBSession, uuid: UUID) -> None:
    log.debug(f"Deleting message {uuid}")
    await db.execute(delete_stmt(MessageDB).where(MessageDB.uuid == uuid))
    await db.commit()


async def delete_by_uuid(db: DBSession, uuid: UUID, user_uuid: UUID) -> None:
    delete_query = delete_stmt(MessageDB).where(MessageDB.uuid == uuid).where(MessageDB.user_uuid == user_uuid)
    await db.execute(delete_query)
    await db.commit()


async def delete_all_after_datetime_for_conversation(
    db: DBSession, conversation_dto: ConversationDTO, after_datetime: AwareDatetime
) -> ConversationDTO:
    log.debug(f"Deleting all messages after {after_datetime} for conversation {conversation_dto.uuid}")
    delete_query = (
        delete_stmt(MessageDB)
        .where(MessageDB.conversation_uuid == conversation_dto.uuid)
        .where(MessageDB.created_at > after_datetime)
    )
    await db.execute(delete_query)
    await db.commit()
    conversation_dto.messages = [
        message for message in conversation_dto.messages if message.created_at and message.created_at <= after_datetime
    ]
    return conversation_dto


async def delete_many_by_uuids(db: DBSession, uuids: list[UUID]) -> None:
    log.debug(f"Deleting messages {uuids}")
    await db.execute(delete_stmt(MessageDB).where(MessageDB.uuid.in_(uuids)))
    await db.commit()


async def get_validate_and_associate_message_assets_db(
    db: DBSession, asset_uuids: list[UUID], conversation_uuid: UUID, user_uuid: UUID
) -> list[AssetDB]:
    """
    Get assets by UUIDs, validate that they belong to the user and are not already associated with an agent/conversation/message,
    """
    query = select(AssetDB).filter(AssetDB.uuid.in_(asset_uuids), AssetDB.user_uuid == user_uuid)
    assets = (await db.execute(query)).unique().scalars().all()  # noqa: ECE001
    if len(assets) != len(asset_uuids):
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "One or more assets do not belong to user")

    updated = False
    for asset in assets:
        if any([asset.agent_uuid, asset.conversation_uuid, asset.message_uuid]):
            raise HTTPException(
                status.HTTP_400_BAD_REQUEST,
                f"Asset {asset.uuid} is already associated with an agent/conversation/message",
            )

        asset.conversation_uuid = conversation_uuid
        updated = True

    if updated:
        await db.commit()

    return list(assets)


def convert_assets_to_message_type(assets_db: list[AssetDB]) -> MessageType:
    if len({asset.type for asset in assets_db}) > 1:
        return MessageType.MULTIMODAL

    if assets_db:
        asset = assets_db[0]
        if asset.type in [AssetType.OTHER.value, AssetType.PDF.value]:
            return MessageType.TEXT
        if asset.type in [AssetType.AUDIO.value, AssetType.VIDEO.value, AssetType.IMAGE.value]:
            return MessageType(asset.type)

        raise ValueError(f"Unsupported asset type {asset.type} for conversation message")

    return MessageType.TEXT


--- Start of backend/src/db/crud/agent_config.py ---

from uuid import UUID

from sqlalchemy import select

from src.db.connect import DBSession
from src.db.models.agent_config import AgentConfigDB
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AgentConfigDTO


log = root_logger.getChild(__name__)


async def get_all_by_agent_uuid(db: DBSession, agent_uuid: UUID) -> list[AgentConfigDTO]:
    log.debug(f"Getting all agent configs for agent {agent_uuid}")
    query = select(AgentConfigDB).filter(AgentConfigDB.agent_uuid == agent_uuid).order_by(AgentConfigDB.version.desc())
    result = await db.execute(query)
    agent_configs_db = result.scalars().all()
    return [agent_config.to_dto() for agent_config in agent_configs_db]


async def get_by_uuid_and_agent_uuid(db: DBSession, uuid: UUID, agent_uuid: UUID) -> AgentConfigDTO | None:
    agent_config_db = await get_config_db_by_agent_uuid_and_config_uuid(db=db, agent_uuid=agent_uuid, config_uuid=uuid)
    return agent_config_db.to_dto() if agent_config_db is not None else None


async def get_config_db_by_agent_uuid_and_config_uuid(
    db: DBSession, agent_uuid: UUID, config_uuid: UUID
) -> AgentConfigDB:
    log.debug(f"Getting agent config {config_uuid} for agent {agent_uuid}")
    query = select(AgentConfigDB).filter(AgentConfigDB.agent_uuid == agent_uuid, AgentConfigDB.uuid == config_uuid)
    result = await db.execute(query)
    agent_config_db = result.scalars().first()
    if agent_config_db is None:
        raise NotFoundError(entity="agent_config", by=["uuid", "agent_uuid"])

    return agent_config_db


async def create(db: DBSession, agent_config_dto: AgentConfigDTO) -> AgentConfigDTO:
    log.debug(f"Creating agent config {agent_config_dto.uuid}")
    agent_config_db = AgentConfigDB.from_dto(agent_config_dto)
    db.add(agent_config_db)
    await db.commit()
    return agent_config_db.to_dto()


async def update(db: DBSession, agent_config_dto: AgentConfigDTO) -> AgentConfigDTO:
    log.debug(f"Updating agent config {agent_config_dto.uuid}")
    agent_config_db = await get_config_db_by_agent_uuid_and_config_uuid(
        db=db, agent_uuid=agent_config_dto.agent_uuid, config_uuid=agent_config_dto.uuid
    )

    for key, value in agent_config_dto.model_dump(exclude={"uuid", "created_at", "updated_at"}, mode="json").items():
        setattr(agent_config_db, key, value)

    await db.commit()
    return agent_config_db.to_dto()


async def update_many_no_commit(db: DBSession, agent_configs_dto: list[AgentConfigDTO]) -> None:
    """
    Dedicated function for updating multiple agent configs upon agent update.
    Does not commit so that we can update both agent and agent configs in a single transaction.
    Does not need to return anything as the session object is modified.
    """
    query = select(AgentConfigDB).filter(AgentConfigDB.uuid.in_([config.uuid for config in agent_configs_dto]))
    result = await db.execute(query)
    agent_configs_db = result.scalars().all()
    if len(agent_configs_db) != len(agent_configs_dto):
        raise NotFoundError(entity="agent_config", by="uuid")

    for agent_config_dto in agent_configs_dto:
        agent_config_db = next(config for config in agent_configs_db if config.uuid == agent_config_dto.uuid)
        for key, value in agent_config_dto.model_dump(
            exclude={"uuid", "created_at", "updated_at"}, mode="json"
        ).items():
            setattr(agent_config_db, key, value)


async def get_db_by_uuid(db: DBSession, uuid: UUID) -> AgentConfigDB | None:
    log.debug(f"Getting agent config by uuid {uuid}")
    query = select(AgentConfigDB).filter(AgentConfigDB.uuid == uuid)
    result = await db.execute(query)
    return result.scalars().first() if result is not None else None


--- Start of backend/src/db/crud/generation_log.py ---

from sqlalchemy import select
from tribe_ai.clients.llm.models.generation_log import GenerationLog

from src.db.connect import AsyncSessionMaker
from src.db.models import GenerationLogDB
from src.logger import root_logger
from src.models import GenerationContext, GenerationLogDTO


log = root_logger.getChild(__name__)


async def generation_cache_get_fn(cache_key: str) -> GenerationLog | None:
    async with AsyncSessionMaker() as db:  # type: ignore
        query = select(GenerationLogDB).filter(GenerationLogDB.cache_key == cache_key)
        result = await db.execute(query)
        generation_log_db: GenerationLogDB | None = result.scalars().first()
        if not generation_log_db:
            log.debug(f"Cache miss for cache key {cache_key}")
            return None

    log.debug(f"Cache hit for cache key {cache_key}")
    generation_log_dict = generation_log_db.to_dto().model_dump()

    context_fields = GenerationContext.model_fields.keys()  # type: ignore[attr-defined]
    generation_context = {k: generation_log_dict.pop(k) for k in context_fields if k in generation_log_dict}
    generation_context = {k: str(v) for k, v in generation_context.items() if v is not None}

    return GenerationLog(generation_context=generation_context, **generation_log_dict)


async def generation_cache_put_fn(generation_log: GenerationLog) -> None:
    generation_log_dict = generation_log.model_dump(mode="json")
    context_fields = GenerationContext.model_fields.keys()  # type: ignore[attr-defined]
    context_dict = generation_log_dict.pop("generation_context", {})
    generation_context_dict = {k: context_dict.pop(k) for k in context_fields if k in context_dict}
    generation_context = GenerationContext(**generation_context_dict)
    generation_log_dto = GenerationLogDTO(**generation_log_dict, **generation_context.model_dump())
    generation_log_db = GenerationLogDB.from_dto(generation_log_dto)

    log.debug(f"Saving generation log to db: {generation_log_dto.uuid}")
    async with AsyncSessionMaker() as db:  # type: ignore
        db.add(generation_log_db)
        await db.commit()


--- Start of backend/src/db/crud/ingestion_document.py ---

from sqlalchemy import select

from src.db.connect import DBSession
from src.db.models import IngestionDocumentDB
from src.logger import root_logger
from src.models import IngestionDocumentDTO


log = root_logger.getChild(__name__)


async def get_all(db: DBSession) -> list[IngestionDocumentDTO]:
    log.debug("Getting all ingestion documents for reindexing")
    query = select(IngestionDocumentDB)
    result = await db.execute(query)
    ingestion_documents_db = result.scalars().all()
    return [ingestion_document_db.to_dto() for ingestion_document_db in ingestion_documents_db]


--- Start of backend/src/db/crud/agent.py ---

from uuid import UUID

from sqlalchemy import select
from sqlalchemy import update as update_query

from src.db import crud
from src.db.connect import DBSession
from src.db.models import AgentDB
from src.exceptions import NotFoundError
from src.logger import root_logger
from src.models import AgentConfigDTO, AgentDTO, AssetDTO


log = root_logger.getChild(__name__)


async def get_all(db: DBSession) -> list[AgentDTO]:
    log.debug("Getting all agents")
    query = select(AgentDB)
    result = await db.execute(query)
    agents_db = result.unique().scalars().all()
    return [agent.to_dto() for agent in agents_db]


async def get_by_uuid(db: DBSession, uuid: UUID) -> AgentDTO | None:
    agent = await get_db_by_uuid(db=db, uuid=uuid)
    return agent.to_dto() if agent is not None else None


async def get_db_by_uuid(db: DBSession, uuid: UUID) -> AgentDB | None:
    log.debug(f"Getting agent by uuid {uuid}")
    query = select(AgentDB).filter(AgentDB.uuid == uuid)
    result = await db.execute(query)
    return result.scalars().first() if result is not None else None


async def get_agent_by_uuid(db: DBSession, uuid: UUID) -> AgentDTO:
    agent_db = await get_agent_db_by_uuid(db=db, uuid=uuid)
    return agent_db.to_dto()


async def get_agent_db_by_uuid(db: DBSession, uuid: UUID) -> AgentDB:
    log.debug(f"Getting agent by uuid '{uuid}'")
    query = select(AgentDB).filter(AgentDB.uuid == uuid)
    agent = (await db.execute(query)).scalars().first()
    if agent is None:
        raise NotFoundError(entity="agent", by="uuid")

    return agent


async def create_or_update(db: DBSession, agent_dto: AgentDTO) -> AgentDTO:
    agent_db = await get_db_by_uuid(db=db, uuid=agent_dto.uuid)
    if agent_db is None:
        return await create(db=db, agent_dto=agent_dto)

    return await update(db=db, agent_dto=agent_dto)


async def create(db: DBSession, agent_dto: AgentDTO) -> AgentDTO:
    log.debug(f"Creating agent {agent_dto.uuid}")
    agent_db = AgentDB.from_dto(agent_dto)
    db.add(agent_db)
    await db.commit()
    await db.refresh(agent_db)
    return agent_db.to_dto()


async def update(db: DBSession, agent_dto: AgentDTO) -> AgentDTO:
    log.debug(f"Updating agent {agent_dto.uuid}")
    agent_db = await get_db_by_uuid(db=db, uuid=agent_dto.uuid)
    if agent_db is None:
        raise NotFoundError(entity="agent", by="uuid")

    for key, value in agent_dto.model_dump(exclude={"uuid", "created_at", "updated_at"}, mode="json").items():
        if key == "active_config":
            # NOTE: active_config is a computed field, the active config will be updated in the agent_configs list
            continue

        if key == "agent_configs":
            agent_config_dtos = [AgentConfigDTO(**config) for config in value]
            await crud.agent_config.update_many_no_commit(db=db, agent_configs_dto=agent_config_dtos)
            continue

        if key == "assets":
            asset_dtos = [AssetDTO(**asset) for asset in value]
            agent_db.assets = await crud.asset.get_all_db_by_uuids(
                db=db, asset_uuids=[asset.uuid for asset in asset_dtos]
            )
            continue

        setattr(agent_db, key, value)

    await db.commit()
    await db.refresh(agent_db)
    return agent_db.to_dto()


async def patch(db: DBSession, uuid: UUID, fields: dict) -> AgentDTO:
    log.debug(f"Updating agent {uuid} with fields {fields}")
    query = select(AgentDB).filter(AgentDB.uuid == uuid)
    agent_db = (await db.execute(query)).unique().scalar_one_or_none()
    if agent_db is None:
        raise NotFoundError(entity="agent", by=[f"uuid={uuid}"])

    if "asset_uuids" in fields:
        asset_uuids = fields.pop("asset_uuids")
        agent_db.assets = await crud.asset.get_all_db_by_uuids(db=db, asset_uuids=asset_uuids)

    update = update_query(AgentDB).where(AgentDB.uuid == uuid).values(fields)
    await db.execute(update)
    await db.commit()
    await db.refresh(agent_db)
    return agent_db.to_dto()


async def delete(db: DBSession, uuid: UUID) -> None:
    log.debug(f"Deleting agent {uuid}")
    agent_db = await get_db_by_uuid(db=db, uuid=uuid)
    if agent_db is None:
        log.warning(f"Agent {uuid} not found")
        return

    await db.delete(agent_db)
    await db.commit()
    return


--- Start of backend/src/db/crud/conversation_starter.py ---

from sqlalchemy import func, select

from src.db.connect import DBSession
from src.db.models import ConversationStarterDB
from src.logger import root_logger
from src.models import ConversationStarterDTO


log = root_logger.getChild(__name__)


async def get_count(db: DBSession) -> int:
    log.debug("Getting conversation starter count")
    query = select(func.count(ConversationStarterDB.uuid))
    return (await db.execute(query)).scalar() or 0


async def get_many_shuffled(db: DBSession, limit: int = 4) -> list[ConversationStarterDTO]:
    log.debug(f"Getting {limit} random conversation starters")
    query = select(ConversationStarterDB).order_by(func.random()).limit(limit)
    result = await db.execute(query)
    conversation_starters_db = result.scalars().all()
    return [s.to_dto() for s in conversation_starters_db]


async def create_many(db: DBSession, conversation_starters_dto: list[ConversationStarterDTO]) -> None:
    log.debug(f"Creating {len(conversation_starters_dto)} conversation starters in background")
    conversation_starters_db = [ConversationStarterDB.from_dto(s) for s in conversation_starters_dto]
    query = select(ConversationStarterDB).filter(
        ConversationStarterDB.description.in_([s.description for s in conversation_starters_db])
    )
    existing_starters = (await db.execute(query)).scalars().all()
    existing_starters_descriptions = {s.description for s in existing_starters}
    new_starters = [s for s in conversation_starters_db if s.description not in existing_starters_descriptions]
    if not new_starters:
        log.debug("No new conversation starters to create")
        return

    log.debug(f"Creating {len(new_starters)} new conversation starters")
    for conversation_starter_db in new_starters:
        db.add(conversation_starter_db)

    await db.commit()


--- Start of backend/src/db/crud/ingestion_chunk.py ---

from sqlalchemy import select

from src.db.connect import DBSession
from src.db.models import IngestionChunkDB
from src.logger import root_logger
from src.models import IngestionChunkDTO


log = root_logger.getChild(__name__)


async def get_all(db: DBSession) -> list[IngestionChunkDTO]:
    log.debug("Getting all ingestion chunks for reindexing")
    query = select(IngestionChunkDB)
    result = await db.execute(query)
    ingestion_chunks_db = result.scalars().all()
    return [ingestion_chunk_db.to_dto() for ingestion_chunk_db in ingestion_chunks_db]


--- Start of backend/src/db/crud/audit_log.py ---

from uuid import UUID

from sqlalchemy import select

from src.db.connect import DBSession
from src.db.models import AuditLogDB
from src.logger import root_logger
from src.models import AuditLogDTO


log = root_logger.getChild(__name__)


async def get_all(db: DBSession, user_uuid: UUID, filters: dict[str, UUID] | None = None) -> list[AuditLogDTO]:
    log.debug(f"Getting all audit logs for user {user_uuid} with filters {filters}")
    query = select(AuditLogDB).filter(AuditLogDB.user_uuid == user_uuid).order_by(AuditLogDB.created_at.desc())
    if filters:
        query = query.filter_by(**filters)

    result = await db.execute(query)
    return [audit_log_db.to_dto() for audit_log_db in result.scalars().all()]


async def create(db: DBSession, audit_log: AuditLogDTO) -> None:
    log.debug(f"Creating audit log entry ({audit_log.action_type}, {audit_log.entity}, {audit_log.entity_uuid})")
    audit_log_db = AuditLogDB.from_dto(audit_log)
    db.add(audit_log_db)
    await db.commit()


--- Start of scripts/setup.sh ---

#!/bin/bash
# shellcheck disable=SC1091

set -eo pipefail

[[ -d ./.git ]] || { echo "Script should be run from project root"; exit 1; }

setup_tools() {
  if command -v mise >/dev/null; then
    echo "Installing mise tools and activating mise for this script."
    mise trust .mise.toml
    mise install
    eval "$(mise env)"
  else
    echo "WARNING: Mise tool manager not found."
    echo 'You can install it by running "curl https://mise.run | sh" or go to https://mise.jdx.dev/getting-started.html for other installation methods.'
    echo "Setup can continue but might fail if some tools are not installed."
    echo "Are you sure you want to proceed? (y/n)"
    read -r answer
    if [ "${answer}" != "y" ] && [ "${answer}" != "Y" ]; then
      echo "Exiting..."
      exit 1
    fi
  fi
}

setup_backend() {
  echo "Setting up backend..."
  cd backend || exit 1

  echo "Creating virtual environment..."
  uv sync
}

setup_pre_commit() {
  echo "Installing pre-commit hooks..."
  uv run pre-commit install --install-hooks --overwrite
}

setup_frontend() {
  echo "Setting up frontend dependencies..."
  cd frontend || exit 1

  echo "Installing frontend dependencies..."
  npm install

  echo "Installing playwright browsers..."
  npx playwright install

  cd ..
}

setup_tools
setup_frontend
setup_backend
setup_pre_commit

echo
echo "Setup complete"
echo "To start developing, run the following command:"
echo
echo "  source ./scripts/dev.sh"
echo


--- Start of scripts/dev.sh ---

#!/bin/bash

[[ -d ./.git ]] || { echo "Script should be run from project root"; exit 1; }

CLUSTER_NAME=tribe-platform

if ! k3d cluster get "${CLUSTER_NAME}" >/dev/null; then
  echo "Cluster not found, creating..."
  ./scripts/cluster/up.sh
fi

echo "Starting in-cluster development in local k3d cluster..."
./scripts/cluster/dev.sh


--- Start of scripts/activate.sh ---

#!/bin/bash
# shellcheck disable=SC1091,SC2128

[[ -d ./.git ]] || { echo "Script should be run from project root"; exit 1; }

if [ "$0" = "${BASH_SOURCE}" ]; then
  echo "This script should be sourced, not executed: 'source scripts/activate.sh' or '. scripts/activate.sh'"
  exit 1
fi

echo "Activating virtual environment"
source .venv/bin/activate


--- Start of scripts/cluster/logs.sh ---

#!/bin/bash
# shellcheck disable=SC1090,SC1091

set -aeu -o pipefail

kubectl logs -n tribe-platform-chat-dev deployment/chat-api -f


--- Start of scripts/cluster/dev.sh ---

#!/bin/bash
# shellcheck disable=SC1090,SC1091

set -aeu -o pipefail

[[ -d ./.git ]] || { echo "Script should be run from project root"; exit 1; }

CLUSTER_NAME=tribe-platform

if ! k3d cluster get "${CLUSTER_NAME}" >/dev/null; then
  echo "Cluster not found, creating..."
  ./scripts/cluster/up.sh
fi

skaffold dev --cleanup=false --keep-running-on-failure=true


--- Start of scripts/cluster/down.sh ---

#!/bin/bash
# shellcheck disable=SC1090,SC1091

set -aeu -o pipefail

CLUSTER_NAME=tribe-platform

if k3d cluster get "${CLUSTER_NAME}" >/dev/null; then
  k3d cluster delete "${CLUSTER_NAME}"
fi


--- Start of scripts/cluster/up.sh ---

#!/bin/bash
# shellcheck disable=SC1090,SC1091

set -aeu -o pipefail

[[ -d .git ]] || { echo "Script should be run from project root"; exit 1;}

CLUSTER_NAME=tribe-platform

if ! k3d cluster get "${CLUSTER_NAME}" >/dev/null; then
  k3d cluster create "${CLUSTER_NAME}" --config manifests/cluster/overlays/k3d/k3d.yaml
fi

if [[ $(kubectl config current-context) != k3d-* ]]; then
  echo
  echo "Currently selected context is not a k3d cluster!"
  echo
  echo "Make sure you have the correct cluster connected, or run scripts/cluster/down.sh and then scripts/cluster/up.sh"
  exit 1
fi

kubectl -n kube-system wait --for condition=available deployment/coredns

if [[ -f "secrets.env" ]]; then
  kubectl create ns external-secrets || true
  kubectl delete secret external-secrets-env -n external-secrets || true
  kubectl create secret generic external-secrets-env --from-env-file=secrets.env -n external-secrets
fi

kubectl apply -f https://github.com/fluxcd/flux2/releases/latest/download/install.yaml
kubectl wait --for=condition=available --all deployments -n flux-system --timeout 30m

kubectl apply -k ./manifests/cluster/overlays/k3d/deps
kubectl wait --for=condition=ready --all helmreleases -n flux-system --timeout 30m

skaffold run
